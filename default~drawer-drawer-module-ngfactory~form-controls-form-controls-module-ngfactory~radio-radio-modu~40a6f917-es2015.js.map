{"version":3,"sources":["/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/radio-group/fesm2015/terminus-ui-radio-group.js","/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/radio-group/terminus-ui-radio-group.d.ts.TsRadioGroupComponent.html","/home/runner/work/terminus-oss/terminus-oss/node_modules/@angular/material/fesm2015/radio.js","/home/runner/work/terminus-oss/terminus-oss/node_modules/@angular/material/radio/index.d.ts.MatRadioButton.html"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACA;AAC4G;AACnG;AACU;AACT;AACA;AACR;AAC6B;AACrB;AACI;AAC+B;AACc;;AAE1G;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,mFAA2B;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,gDAAgD;AAChD;AACA,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe,yFAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mFAAU;AACtB;AACA;AACA,iBAAiB,+DAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mFAAU;AACtB;AACA;AACA,iBAAiB,+DAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mFAAU;AACtB;AACA;AACA,iBAAiB,+DAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8FAAuB;AAC7C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,sEAAY;AACxB;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2D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wHAA+B,KAE7B,wMAGC,KACC,sJAAgC,kFAEhC,MAEA,oJAA8B,KAC5B,0fAAiE,IAiDnE,+YAKC,iDAtDe,gDAAkD,YAAhE,YAAiE,EAAnD,oBAAkD,GAmDhE,wCAA2C,sBAF7C,YAKC,EAHC,SAA2C,mDA1D7C,mBAA8B,QAFhC,YAGC,EADC,SAA8B,GAEE,kDAEhC;2GApDJ,8YAAgC,IA4ChC,8YAA+B,iDA5CjB,oBAAiB,WAA/B,YAAgC,EAAlB,SAAiB,GA4CjB,mBAAgB,WAA9B,YAA+B,EAAjB,SAAgB;;;;;;;;;;;;;;;;AC7C9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiP;AACpI;AAC5D;AACa;AACO;AAClB;AAC0B;;AAE7E;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA,mCAAmC;AACnC,WAAW,EAGV;AACD,WAAW,EAAE;AACb,sCAAsC,4DAAc;AACpD;AACA;AACA,CAAC;AACD;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,aAAa,gEAAiB;AAC9B,iBAAiB,gEAAU;AAC3B,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAWV;AACD;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB,mBAAmB;AACnC;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB,oBAAoB;AACrC;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,oBAAoB,uBAAuB;AAC3C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,oBAAoB,uBAAuB;AAC3C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,yBAAyB,mFAAqB;AAC9C;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,oBAAoB,uBAAuB;AAC3C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,yBAAyB,mFAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,4DAA4D,EAAE;AAC9D;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,KAAK,OAAO,+DAAiB;AAC7B;AACA;AACA,cAAc,OAAO,oDAAM,EAAE;AAC7B,eAAe,OAAO,6DAAe,SAAS,gEAAU;AACxD,4BAA4B;AAC5B;AACA,yCAAyC,oBAAoB,IAAI;AACjE,aAAa,OAAO,mDAAK,EAAE;AAC3B,YAAY,OAAO,mDAAK,EAAE;AAC1B,qBAAqB,OAAO,mDAAK,EAAE;AACnC,aAAa,OAAO,mDAAK,EAAE;AAC3B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B;AACA,WAAW,EAgFV;AACD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,WAAW,EAKV;AACD;AACA;AACA,WAAW,EAAE;AACb,iCAAiC,iFAAkB,CAAC,4EAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB;AAChB;AACA,mBAAmB,sBAAsB;AACzC;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,gCAAgC,mFAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB,oBAAoB;AACrC;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,0BAA0B,mFAAqB;AAC/C;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,yBAAyB,mFAAqB;AAC9C;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA,gBAAgB;AAChB;AACA,mBAAmB,WAAW,0BAA0B,QAAQ;AAChE;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA,KAAK,oCAAoC,OAAO,sDAAQ,EAAE,GAAG;AAC7D,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,8DAAY,EAAE;AAC1B,KAAK,OAAO,kFAAyB,EAAE;AACvC,KAAK,6BAA6B,OAAO,sDAAQ,EAAE,GAAG,OAAO,oDAAM,SAAS,0FAAqB,IAAI,GAAG;AACxG,KAAK,gCAAgC,OAAO,sDAAQ,EAAE,GAAG,OAAO,oDAAM,sCAAsC;AAC5G;AACA;AACA,UAAU,OAAO,mDAAK,EAAE;AACxB,YAAY,OAAO,mDAAK,EAAE;AAC1B,iBAAiB,OAAO,mDAAK,yBAAyB;AACtD,sBAAsB,OAAO,mDAAK,8BAA8B;AAChE,uBAAuB,OAAO,mDAAK,+BAA+B;AAClE,eAAe,OAAO,mDAAK,EAAE;AAC7B,aAAa,O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","file":"default~drawer-drawer-module-ngfactory~form-controls-form-controls-module-ngfactory~radio-radio-modu~40a6f917-es2015.js","sourcesContent":["import { __decorate, __metadata } from 'tslib';\nimport { CommonModule } from '@angular/common';\nimport { EventEmitter, isDevMode, ChangeDetectorRef, Input, Output, Component, ChangeDetectionStrategy, ViewEncapsulation, NgModule } from '@angular/core';\nimport { FlexLayoutModule } from '@angular/flex-layout';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { MatRippleModule } from '@angular/material/core';\nimport { MatRadioModule } from '@angular/material/radio';\nimport { TsIconModule } from '@terminus/ui-icon';\nimport { TsValidationMessagesModule } from '@terminus/ui-validation-messages';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { isFunction } from '@terminus/ngx-tools/type-guards';\nimport { hasRequiredControl, untilComponentDestroyed } from '@terminus/ngx-tools/utilities';\nimport { TsReactiveFormBaseComponent, ControlValueAccessorProviderFactory } from '@terminus/ui-utilities';\n\nvar TsRadioGroupComponent_1;\n/**\n * The change event as TsRadioChange. Used by {@link TsRadioGroupComponent}\n */\nclass TsRadioChange {\n    constructor(\n    // The group that emit the change event\n    source, \n    // The value of the TsRadioButton\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    value) {\n        this.source = source;\n        this.value = value;\n    }\n}\n/**\n * Unique ID for each instance\n */\nlet nextUniqueId = 0;\n/**\n * The radio UI Component\n *\n * @example\n * <ts-radio-group\n *              [ariaDescribedby]=\"Aria Describedby\"\n *              [ariaLabel]=\"Aria Label\"\n *              [ariaLabelledby]=\"Aria Labelledby\"\n *              [centeredContent]=\"false\"\n *              [formatUILabelFn]=\"myUIFormatter\"\n *              [formatUISubLabelFn]=\"myUISubFormatter\"\n *              [formatModelValueFn]=\"myModelFormatter\"\n *              [formControl]=\"myForm.get('myRadioGroup')\"\n *              [id]=\"uid\"\n *              [isDisabled]=\"true\"\n *              [isVisual]=\"false\"\n *              [name]=\"myName\"\n *              [options]=\"myItemsArray | $async\"\n *              [small]=false\n *              [theme]=\"primary\"\n *              (selectionChange)=\"doSomething($event)\"\n * ></ts-radio-group>\n *\n * <example-url>https://getterminus.github.io/ui-demos-release/components/radio-group</example-url>\n */\nlet TsRadioGroupComponent = TsRadioGroupComponent_1 = class TsRadioGroupComponent extends TsReactiveFormBaseComponent {\n    constructor(changeDetectorRef, domSanitizer) {\n        super();\n        this.changeDetectorRef = changeDetectorRef;\n        this.domSanitizer = domSanitizer;\n        /**\n         * Define the default component ID\n         */\n        this._uid = `ts-radio-group-${nextUniqueId++}`;\n        /**\n         * Define the ripple color.\n         * TODO: abstract out to a service or utility function or set as a global default for ripples\n         */\n        this.rippleColor = 'rgba(0, 83, 138, .1)';\n        // eslint:enable: @angular-eslint/no-input-rename\n        /**\n         * Define if the radio contents should be centered (used with the visual radio group layout)\n         */\n        this.centeredContent = true;\n        this._id = this._uid;\n        /**\n         * Define if the radio group is disabled\n         */\n        this.isDisabled = false;\n        /**\n         * Define if the radio group is visual (boxes) or standard (text)\n         */\n        this.isVisual = false;\n        this._name = this._uid;\n        /**\n         * Define whether a validation or a hint needed.\n         */\n        this.noValidationOrHint = false;\n        /**\n         * Define if the visual style should be large or small\n         */\n        this.small = false;\n        /**\n         * Define the theme. {@link TsStyleThemeTypes}\n         */\n        this.theme = 'primary';\n        /**\n         * Emit event when a selection occurs. {@link TsRadioChange}\n         */\n        this.selectionChange = new EventEmitter();\n    }\n    /**\n     * Getter to determine if the group is required\n     */\n    get isRequired() {\n        return hasRequiredControl(this.formControl);\n    }\n    /**\n     * Define a function to retrieve the UI value for an option\n     *\n     * @param value\n     */\n    set formatUILabelFn(value) {\n        if (!value) {\n            return;\n        }\n        if (isFunction(value)) {\n            this._formatUILabelFn = value;\n        }\n        else if (isDevMode()) {\n            throw Error(`TsRadioGroupComponent: 'formatUILabelFn' must be passed a 'TsRadioFormatFn'.`);\n        }\n    }\n    get formatUILabelFn() {\n        return this._formatUILabelFn;\n    }\n    /**\n     * Define a function to retrieve the UI value for an option\n     *\n     * @param value\n     */\n    set formatUISubLabelFn(value) {\n        if (!value) {\n            return;\n        }\n        if (isFunction(value)) {\n            this._formatUISubLabelFn = value;\n        }\n        else if (isDevMode()) {\n            throw Error(`TsRadioGroupComponent: 'formatUISubLabelFn' must be passed a 'TsRadioFormatFn'.`);\n        }\n    }\n    get formatUISubLabelFn() {\n        return this._formatUISubLabelFn;\n    }\n    /**\n     * Define a function to retrieve the UI value for an option\n     *\n     * @param value\n     */\n    set formatModelValueFn(value) {\n        if (!value) {\n            return;\n        }\n        if (isFunction(value)) {\n            this._formatModelValueFn = value;\n        }\n        else if (isDevMode()) {\n            throw Error(`TsRadioGroupComponent: 'formatModelValueFn' must be passed a 'TsRadioFormatFn'.`);\n        }\n    }\n    get formatModelValueFn() {\n        return this._formatModelValueFn;\n    }\n    /**\n     * Define an ID for the component\n     *\n     * @param value\n     */\n    set id(value) {\n        this._id = value || this._uid;\n    }\n    get id() {\n        return this._id;\n    }\n    /**\n     * The HTML name attribute applied to radio buttons in this group.\n     *\n     * @param value\n     */\n    set name(value) {\n        this._name = value ? value : this._uid;\n    }\n    get name() {\n        return this._name;\n    }\n    /**\n     * Accept an array of radio options in the {@link TsRadioOption} format\n     *\n     * @param value\n     */\n    set options(value) {\n        if (!value) {\n            return;\n        }\n        this._options = value;\n    }\n    get options() {\n        return this._options;\n    }\n    /**\n     * Update the change detector if the control value changes\n     */\n    ngOnInit() {\n        // istanbul ignore else\n        if (this.formControl) {\n            this.formControl.valueChanges\n                .pipe(untilComponentDestroyed(this))\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .subscribe((v) => {\n                this.writeValue(v);\n                this.changeDetectorRef.markForCheck();\n            });\n        }\n    }\n    /**\n     * Needed for untilComponentDestroyed\n     */\n    ngOnDestroy() { }\n    /**\n     * Retrieve a value determined by the passed in formatter\n     *\n     * @param option - The radio option\n     * @param formatter - The formatter function used to retrieve the value\n     * @returns The retrieved value\n     */\n    retrieveValue(option, formatter) {\n        return (formatter && formatter(option)) ? formatter(option) : option;\n    }\n    /**\n     * Handle changes\n     *\n     * @param option - The selected option\n     */\n    radioGroupChange(option) {\n        const change = new TsRadioChange(this, option.value);\n        this.selectionChange.emit(change);\n        this.changeDetectorRef.markForCheck();\n    }\n    /**\n     * Handles changes for visual radio groups\n     *\n     * @param option - The selected option\n     */\n    visualRadioGroupChange(option) {\n        const value = this.retrieveValue(option, this.formatModelValueFn);\n        const change = new TsRadioChange(this, value);\n        this.selectionChange.emit(change);\n        this.changeDetectorRef.markForCheck();\n    }\n    /**\n     * Function for tracking for-loops changes\n     *\n     * @param index - The item index\n     * @returns The unique ID\n     */\n    trackByFn(index) {\n        return index;\n    }\n};\nTsRadioGroupComponent.ctorParameters = () => [\n    { type: ChangeDetectorRef },\n    { type: DomSanitizer }\n];\n__decorate([\n    Input('aria-label'),\n    __metadata(\"design:type\", String)\n], TsRadioGroupComponent.prototype, \"ariaLabel\", void 0);\n__decorate([\n    Input('aria-labelledby'),\n    __metadata(\"design:type\", String)\n], TsRadioGroupComponent.prototype, \"ariaLabelledby\", void 0);\n__decorate([\n    Input('aria-describedby'),\n    __metadata(\"design:type\", String)\n], TsRadioGroupComponent.prototype, \"ariaDescribedby\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsRadioGroupComponent.prototype, \"centeredContent\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Function])\n], TsRadioGroupComponent.prototype, \"formatUILabelFn\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Function])\n], TsRadioGroupComponent.prototype, \"formatUISubLabelFn\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Function])\n], TsRadioGroupComponent.prototype, \"formatModelValueFn\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsRadioGroupComponent.prototype, \"id\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsRadioGroupComponent.prototype, \"isDisabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsRadioGroupComponent.prototype, \"isVisual\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsRadioGroupComponent.prototype, \"label\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsRadioGroupComponent.prototype, \"name\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsRadioGroupComponent.prototype, \"noValidationOrHint\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Array),\n    __metadata(\"design:paramtypes\", [Array])\n], TsRadioGroupComponent.prototype, \"options\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsRadioGroupComponent.prototype, \"small\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsRadioGroupComponent.prototype, \"theme\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsRadioGroupComponent.prototype, \"selectionChange\", void 0);\nTsRadioGroupComponent = TsRadioGroupComponent_1 = __decorate([\n    Component({\n        selector: 'ts-radio-group',\n        template: \"<!-- STANDARD MODE -->\\n<ng-container *ngIf=\\\"!isVisual\\\">\\n\\n  <mat-radio-group\\n    class=\\\"c-radio qa-radio-group\\\"\\n    [disabled]=\\\"isDisabled\\\"\\n    [required]=\\\"isRequired\\\"\\n    [class.c-radio--sublabel]=\\\"formatUISubLabelFn\\\"\\n    [ngClass]=\\\"{'c-radio-sublabel--with-validation': !noValidationOrHint}\\\"\\n    [(ngModel)]=\\\"value\\\"\\n  >\\n    <ng-container *ngFor=\\\"let option of options; trackBy: trackByFn\\\">\\n\\n      <mat-radio-button\\n        class=\\\"c-radio__control qa-radio-control\\\"\\n        [value]=\\\"retrieveValue(option, formatModelValueFn)\\\"\\n        [disabled]=\\\"option.disabled\\\"\\n        [name]=\\\"id\\\"\\n        (change)=\\\"radioGroupChange($event)\\\"\\n        #radio=\\\"matRadioButton\\\"\\n      >\\n        {{ retrieveValue(option, formatUILabelFn) }}\\n\\n        <small\\n          class=\\\"c-radio__control-sublabel\\\"\\n          *ngIf=\\\"formatUISubLabelFn\\\"\\n        >\\n          {{ retrieveValue(option, formatUISubLabelFn) }}\\n        </small>\\n      </mat-radio-button>\\n\\n    </ng-container>\\n\\n    <ts-validation-messages\\n      class=\\\"qa-radio-validation-messages\\\"\\n      *ngIf=\\\"formControl && !noValidationOrHint\\\"\\n      [control]=\\\"formControl\\\"\\n      [validateImmediately]=\\\"true\\\"\\n    ></ts-validation-messages>\\n  </mat-radio-group>\\n\\n</ng-container>\\n\\n\\n<!-- VISUAL MODE -->\\n<ng-container *ngIf=\\\"isVisual\\\">\\n\\n  <fieldset\\n    class=\\\"c-radio c-radio--visual qa-radio-group\\\"\\n    [class.c-radio--small]=\\\"small\\\"\\n  >\\n    <legend class=\\\"c-radio__legend\\\">\\n      {{ label }}\\n    </legend>\\n\\n    <div class=\\\"c-radio__options\\\">\\n      <ng-container *ngFor=\\\"let option of options; trackBy: trackByFn\\\">\\n        <label\\n          class=\\\"c-radio__control qa-radio-control\\\"\\n          [class.c-radio__control--disabled]=\\\"isDisabled || option.disabled\\\"\\n          (click)=\\\"visualRadioGroupChange(option)\\\"\\n        >\\n          <input\\n            type=\\\"radio\\\"\\n            class=\\\"c-radio__input\\\"\\n            [name]=\\\"id\\\"\\n            [value]=\\\"retrieveValue(option, formatModelValueFn)\\\"\\n            [disabled]=\\\"(isDisabled || option.disabled)\\\"\\n            [checked]=\\\"retrieveValue(option, formatModelValueFn) === value\\\"\\n            [attr.aria-label]=\\\"ariaLabel\\\"\\n            [attr.aria-labelledby]=\\\"ariaLabelledby\\\"\\n            [attr.aria-describedby]=\\\"ariaDescribedby\\\"\\n            [(ngModel)]=\\\"value\\\"\\n          >\\n          <div\\n            class=\\\"c-radio__content\\\"\\n            [class.c-radio__content--disabled]=\\\"isDisabled || option.disabled\\\"\\n            [class.c-radio__content--centered]=\\\"centeredContent\\\"\\n            mat-ripple\\n            [matRippleDisabled]=\\\"(isDisabled || option.disabled) ? 'disabled' : null\\\"\\n            [matRippleColor]=\\\"rippleColor\\\"\\n          >\\n            <ts-icon class=\\\"c-radio__content-checkmark\\\" [inline]=\\\"true\\\">\\n              done\\n            </ts-icon>\\n\\n            <ng-container *ngIf=\\\"!option.template\\\">\\n              <span class=\\\"c-radio__content-label\\\">\\n                {{ retrieveValue(option, formatUILabelFn) }}\\n              </span>\\n\\n              <small\\n                class=\\\"c-radio__control-sublabel\\\"\\n                *ngIf=\\\"formatUISubLabelFn\\\"\\n              >\\n                {{ retrieveValue(option, formatUISubLabelFn) }}\\n              </small>\\n            </ng-container>\\n\\n            <span *ngIf=\\\"option.template\\\" [innerHTML]=\\\"domSanitizer.bypassSecurityTrustHtml(option.template)\\\"></span>\\n          </div>\\n        </label>\\n      </ng-container>\\n    </div>\\n\\n    <ts-validation-messages\\n      class=\\\"qa-radio-validation-messages\\\"\\n      *ngIf=\\\"formControl  && !noValidationOrHint\\\"\\n      [control]=\\\"formControl\\\"\\n      [validateImmediately]=\\\"true\\\"\\n    ></ts-validation-messages>\\n  </fieldset>\\n\\n</ng-container>\\n\",\n        host: { class: 'ts-radio-group' },\n        providers: [ControlValueAccessorProviderFactory(TsRadioGroupComponent_1)],\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        encapsulation: ViewEncapsulation.None,\n        exportAs: 'tsRadioGroup',\n        styles: [\":root{--swift-ease-out-duration:var(--ts-animation-time-duration-400);--swift-ease-out-timing-function:cubic-bezier(.25, .8, .25, 1);--swift-ease-in-duration:var(--ts-animation-time-duration-300);--swift-ease-in-timing-function:cubic-bezier(.55, 0, .55, .2)}.cdk-drag{position:relative}.cdk-drag:not(.cdk-drag-placeholder){transition:transform 250ms cubic-bezier(0,0,.2,1)}.cdk-drag .cdk-drag-handle{color:#cecdd1;cursor:ns-resize;position:absolute;right:8px}.cdk-drag.cdk-drag-preview{--shadow:0 5px 5px -3px rgba(0, 0, 0, .2),0 8px 10px 1px rgba(0, 0, 0, .14),0 3px 14px 2px rgba(0, 0, 0, .12);background-color:#fafafa;box-shadow:var(--shadow);min-height:50px;padding:0!important}.cdk-drag.cdk-drag-preview .c-checkbox{margin-left:16px}.cdk-drag-placeholder{--drop-bg:#cce8d5;--drop-border:#7fd09c;background:var(--drop-bg);border:2px dotted var(--drop-border);cursor:ns-resize;transition:transform 250ms cubic-bezier(0,0,.2,1)}.u-visually-hidden{border:0;-webkit-clip-path:rect(0,0,0,0);clip-path:rect(0,0,0,0);display:block;height:1px;margin:-1px;overflow:hidden;padding:0;pointer-events:none;position:absolute;visibility:hidden;width:1px}.ts-radio-group{display:block}.ts-radio-group :not(.mat-form-field-label-wrapper){box-sizing:border-box}.ts-radio-group h1,.ts-radio-group h2,.ts-radio-group h3,.ts-radio-group h4,.ts-radio-group h5,.ts-radio-group p{margin:unset}.ts-radio-group .c-radio{font-family:Roboto,Helvetica Neue,Helvetica,Arial,sans-serif;font-size:16px;letter-spacing:.01em;font-weight:400;border:0;display:block;position:relative}.ts-radio-group .c-radio:not(.c-button):not(.c-input):not(.c-select):not(.ts-checkbox){line-height:20px}.c-radio .c-radio__control{display:block;margin-bottom:4px}.c-radio .c-radio__control-sublabel{font-family:Roboto,Helvetica Neue,Helvetica,Arial,sans-serif;font-size:12px;letter-spacing:.02em;color:#999;display:block;line-height:1.2em}.c-radio--sublabel.c-radio-sublabel--with-validation{padding-bottom:1.25em}.c-radio--sublabel .c-radio__control .mat-radio-label{align-items:start}.c-radio--visual.c-radio--small .c-radio__control{float:left;height:7rem;margin-bottom:12px;width:13.75rem}.c-radio--visual.c-radio--small .c-radio__control:not(:last-child){margin-right:12px}.c-radio--visual .c-radio__legend{all:unset}.c-radio--visual:not(.c-radio--small) .c-radio__options{display:-ms-grid;display:grid;grid-gap:12px;grid-template-columns:repeat(auto-fill,minmax(12em,1fr))}.c-radio--visual .c-radio__control{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transition:box-shadow 250ms cubic-bezier(.4,0,.2,1);background-position:center;background-repeat:no-repeat;background-size:cover;border-radius:3px;overflow:hidden;padding:16px;position:relative}.c-radio--visual .c-radio__control:active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.c-radio--visual .c-radio__control::before{content:\\\"\\\";display:block;position:relative;padding-top:100%;width:100%}.c-radio--visual .c-radio__content{bottom:0;left:0;position:absolute;right:0;top:0;align-items:center;border:1px solid #cecdd1;border-radius:3px;padding:16px;transition:border-color .2s ease-in}.c-radio--visual .c-radio__content:focus:not(.c-radio__content--disabled),.c-radio--visual .c-radio__content:hover:not(.c-radio__content--disabled){border-color:#00538a;cursor:pointer}.c-radio--visual .c-radio__content::after{border-color:#00538a #00538a transparent transparent;border-style:solid;border-width:1em;content:'';opacity:0;position:absolute;right:-1px;top:-1px;z-index:1}.c-radio--visual .c-radio__content--centered{display:flex;flex-direction:column;justify-content:center}.c-radio--visual .c-radio__content--disabled{color:#999;cursor:not-allowed}.c-radio--visual .c-radio__content-checkmark{color:#fafafa;opacity:0;position:absolute;right:.1em;top:-.2em;transition:opacity .2s;will-change:opacity;z-index:2}.c-radio--visual .c-radio__input{display:none}.c-radio--visual .c-radio__input:checked~.c-radio__content:not(.c-radio__content--disabled){border:1px solid #00538a}.c-radio--visual .c-radio__input:checked~.c-radio__content.c-radio__content--disabled{border:1px solid #757575;color:#757575}.c-radio--visual .c-radio__input:checked~.c-radio__content.c-radio__content--disabled::after{border-right-color:#757575;border-top-color:#757575}.c-radio--visual .c-radio__input:checked~.c-radio__content .c-radio__content-checkmark,.c-radio--visual .c-radio__input:checked~.c-radio__content::after{opacity:1}\"]\n    }),\n    __metadata(\"design:paramtypes\", [ChangeDetectorRef,\n        DomSanitizer])\n], TsRadioGroupComponent);\n\nlet TsRadioGroupModule = class TsRadioGroupModule {\n};\nTsRadioGroupModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            FlexLayoutModule,\n            FormsModule,\n            MatRadioModule,\n            MatRippleModule,\n            ReactiveFormsModule,\n            TsIconModule,\n            TsValidationMessagesModule,\n        ],\n        exports: [TsRadioGroupComponent],\n        declarations: [TsRadioGroupComponent],\n    })\n], TsRadioGroupModule);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TsRadioChange, TsRadioGroupComponent, TsRadioGroupModule };\n//# sourceMappingURL=terminus-ui-radio-group.js.map\n","<!-- STANDARD MODE -->\n<ng-container *ngIf=\"!isVisual\">\n\n  <mat-radio-group\n    class=\"c-radio qa-radio-group\"\n    [disabled]=\"isDisabled\"\n    [required]=\"isRequired\"\n    [class.c-radio--sublabel]=\"formatUISubLabelFn\"\n    [ngClass]=\"{'c-radio-sublabel--with-validation': !noValidationOrHint}\"\n    [(ngModel)]=\"value\"\n  >\n    <ng-container *ngFor=\"let option of options; trackBy: trackByFn\">\n\n      <mat-radio-button\n        class=\"c-radio__control qa-radio-control\"\n        [value]=\"retrieveValue(option, formatModelValueFn)\"\n        [disabled]=\"option.disabled\"\n        [name]=\"id\"\n        (change)=\"radioGroupChange($event)\"\n        #radio=\"matRadioButton\"\n      >\n        {{ retrieveValue(option, formatUILabelFn) }}\n\n        <small\n          class=\"c-radio__control-sublabel\"\n          *ngIf=\"formatUISubLabelFn\"\n        >\n          {{ retrieveValue(option, formatUISubLabelFn) }}\n        </small>\n      </mat-radio-button>\n\n    </ng-container>\n\n    <ts-validation-messages\n      class=\"qa-radio-validation-messages\"\n      *ngIf=\"formControl && !noValidationOrHint\"\n      [control]=\"formControl\"\n      [validateImmediately]=\"true\"\n    ></ts-validation-messages>\n  </mat-radio-group>\n\n</ng-container>\n\n\n<!-- VISUAL MODE -->\n<ng-container *ngIf=\"isVisual\">\n\n  <fieldset\n    class=\"c-radio c-radio--visual qa-radio-group\"\n    [class.c-radio--small]=\"small\"\n  >\n    <legend class=\"c-radio__legend\">\n      {{ label }}\n    </legend>\n\n    <div class=\"c-radio__options\">\n      <ng-container *ngFor=\"let option of options; trackBy: trackByFn\">\n        <label\n          class=\"c-radio__control qa-radio-control\"\n          [class.c-radio__control--disabled]=\"isDisabled || option.disabled\"\n          (click)=\"visualRadioGroupChange(option)\"\n        >\n          <input\n            type=\"radio\"\n            class=\"c-radio__input\"\n            [name]=\"id\"\n            [value]=\"retrieveValue(option, formatModelValueFn)\"\n            [disabled]=\"(isDisabled || option.disabled)\"\n            [checked]=\"retrieveValue(option, formatModelValueFn) === value\"\n            [attr.aria-label]=\"ariaLabel\"\n            [attr.aria-labelledby]=\"ariaLabelledby\"\n            [attr.aria-describedby]=\"ariaDescribedby\"\n            [(ngModel)]=\"value\"\n          >\n          <div\n            class=\"c-radio__content\"\n            [class.c-radio__content--disabled]=\"isDisabled || option.disabled\"\n            [class.c-radio__content--centered]=\"centeredContent\"\n            mat-ripple\n            [matRippleDisabled]=\"(isDisabled || option.disabled) ? 'disabled' : null\"\n            [matRippleColor]=\"rippleColor\"\n          >\n            <ts-icon class=\"c-radio__content-checkmark\" [inline]=\"true\">\n              done\n            </ts-icon>\n\n            <ng-container *ngIf=\"!option.template\">\n              <span class=\"c-radio__content-label\">\n                {{ retrieveValue(option, formatUILabelFn) }}\n              </span>\n\n              <small\n                class=\"c-radio__control-sublabel\"\n                *ngIf=\"formatUISubLabelFn\"\n              >\n                {{ retrieveValue(option, formatUISubLabelFn) }}\n              </small>\n            </ng-container>\n\n            <span *ngIf=\"option.template\" [innerHTML]=\"domSanitizer.bypassSecurityTrustHtml(option.template)\"></span>\n          </div>\n        </label>\n      </ng-container>\n    </div>\n\n    <ts-validation-messages\n      class=\"qa-radio-validation-messages\"\n      *ngIf=\"formControl  && !noValidationOrHint\"\n      [control]=\"formControl\"\n      [validateImmediately]=\"true\"\n    ></ts-validation-messages>\n  </fieldset>\n\n</ng-container>\n","import { InjectionToken, forwardRef, EventEmitter, Directive, ChangeDetectorRef, Output, ContentChildren, Input, Optional, ElementRef, Inject, ViewChild, Component, ViewEncapsulation, ChangeDetectionStrategy, NgModule } from '@angular/core';\nimport { mixinDisableRipple, mixinTabIndex, MatRippleModule, MatCommonModule } from '@angular/material/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/radio/radio.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction MatRadioDefaultOptions() { }\nif (false) {\n    /** @type {?} */\n    MatRadioDefaultOptions.prototype.color;\n}\n/** @type {?} */\nconst MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken('mat-radio-default-options', {\n    providedIn: 'root',\n    factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * @return {?}\n */\nfunction MAT_RADIO_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        color: 'accent'\n    };\n}\n// Increasing integer for generating unique ids for radio components.\n/** @type {?} */\nlet nextUniqueId = 0;\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * \\@docs-private\n * @type {?}\n */\nconst MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef((/**\n     * @return {?}\n     */\n    () => MatRadioGroup)),\n    multi: true\n};\n/**\n * Change event object emitted by MatRadio and MatRadioGroup.\n */\nclass MatRadioChange {\n    /**\n     * @param {?} source\n     * @param {?} value\n     */\n    constructor(source, value) {\n        this.source = source;\n        this.value = value;\n    }\n}\nif (false) {\n    /**\n     * The MatRadioButton that emits the change event.\n     * @type {?}\n     */\n    MatRadioChange.prototype.source;\n    /**\n     * The value of the MatRadioButton.\n     * @type {?}\n     */\n    MatRadioChange.prototype.value;\n}\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\nclass MatRadioGroup {\n    /**\n     * @param {?} _changeDetector\n     */\n    constructor(_changeDetector) {\n        this._changeDetector = _changeDetector;\n        /**\n         * Selected value for the radio group.\n         */\n        this._value = null;\n        /**\n         * The HTML name attribute applied to radio buttons in this group.\n         */\n        this._name = `mat-radio-group-${nextUniqueId++}`;\n        /**\n         * The currently selected radio button. Should match value.\n         */\n        this._selected = null;\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'\n         */\n        this._labelPosition = 'after';\n        /**\n         * Whether the radio group is disabled.\n         */\n        this._disabled = false;\n        /**\n         * Whether the radio group is required.\n         */\n        this._required = false;\n        /**\n         * The method to be called in order to update ngModel\n         */\n        this._controlValueAccessorChangeFn = (/**\n         * @return {?}\n         */\n        () => { });\n        /**\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\n         * \\@docs-private\n         */\n        this.onTouched = (/**\n         * @return {?}\n         */\n        () => { });\n        /**\n         * Event emitted when the group value changes.\n         * Change events are only emitted when the value changes due to user interaction with\n         * a radio button (the same behavior as `<input type-\"radio\">`).\n         */\n        this.change = new EventEmitter();\n    }\n    /**\n     * Name of the radio button group. All radio buttons inside this group will use this name.\n     * @return {?}\n     */\n    get name() { return this._name; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set name(value) {\n        this._name = value;\n        this._updateRadioButtonNames();\n    }\n    /**\n     * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'\n     * @return {?}\n     */\n    get labelPosition() {\n        return this._labelPosition;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set labelPosition(v) {\n        this._labelPosition = v === 'before' ? 'before' : 'after';\n        this._markRadiosForCheck();\n    }\n    /**\n     * Value for the radio-group. Should equal the value of the selected radio button if there is\n     * a corresponding radio button with a matching value. If there is not such a corresponding\n     * radio button, this value persists to be applied in case a new radio button is added with a\n     * matching value.\n     * @return {?}\n     */\n    get value() { return this._value; }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n    set value(newValue) {\n        if (this._value !== newValue) {\n            // Set this before proceeding to ensure no circular loop occurs with selection.\n            this._value = newValue;\n            this._updateSelectedRadioFromValue();\n            this._checkSelectedRadioButton();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _checkSelectedRadioButton() {\n        if (this._selected && !this._selected.checked) {\n            this._selected.checked = true;\n        }\n    }\n    /**\n     * The currently selected radio button. If set to a new radio button, the radio group value\n     * will be updated to match the new selected button.\n     * @return {?}\n     */\n    get selected() { return this._selected; }\n    /**\n     * @param {?} selected\n     * @return {?}\n     */\n    set selected(selected) {\n        this._selected = selected;\n        this.value = selected ? selected.value : null;\n        this._checkSelectedRadioButton();\n    }\n    /**\n     * Whether the radio group is disabled\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._markRadiosForCheck();\n    }\n    /**\n     * Whether the radio group is required\n     * @return {?}\n     */\n    get required() { return this._required; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set required(value) {\n        this._required = coerceBooleanProperty(value);\n        this._markRadiosForCheck();\n    }\n    /**\n     * Initialize properties once content children are available.\n     * This allows us to propagate relevant attributes to associated buttons.\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        // Mark this component as initialized in AfterContentInit because the initial value can\n        // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n        // NgModel occurs *after* the OnInit of the MatRadioGroup.\n        this._isInitialized = true;\n    }\n    /**\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n     * radio buttons upon their blur.\n     * @return {?}\n     */\n    _touch() {\n        if (this.onTouched) {\n            this.onTouched();\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _updateRadioButtonNames() {\n        if (this._radios) {\n            this._radios.forEach((/**\n             * @param {?} radio\n             * @return {?}\n             */\n            radio => {\n                radio.name = this.name;\n                radio._markForCheck();\n            }));\n        }\n    }\n    /**\n     * Updates the `selected` radio button from the internal _value state.\n     * @private\n     * @return {?}\n     */\n    _updateSelectedRadioFromValue() {\n        // If the value already matches the selected radio, do nothing.\n        /** @type {?} */\n        const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n        if (this._radios && !isAlreadySelected) {\n            this._selected = null;\n            this._radios.forEach((/**\n             * @param {?} radio\n             * @return {?}\n             */\n            radio => {\n                radio.checked = this.value === radio.value;\n                if (radio.checked) {\n                    this._selected = radio;\n                }\n            }));\n        }\n    }\n    /**\n     * Dispatch change event with current selection and group value.\n     * @return {?}\n     */\n    _emitChangeEvent() {\n        if (this._isInitialized) {\n            this.change.emit(new MatRadioChange((/** @type {?} */ (this._selected)), this._value));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _markRadiosForCheck() {\n        if (this._radios) {\n            this._radios.forEach((/**\n             * @param {?} radio\n             * @return {?}\n             */\n            radio => radio._markForCheck()));\n        }\n    }\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param {?} value\n     * @return {?}\n     */\n    writeValue(value) {\n        this.value = value;\n        this._changeDetector.markForCheck();\n    }\n    /**\n     * Registers a callback to be triggered when the model value changes.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n    registerOnChange(fn) {\n        this._controlValueAccessorChangeFn = fn;\n    }\n    /**\n     * Registers a callback to be triggered when the control is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    /**\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n     * @param {?} isDisabled Whether the control should be disabled.\n     * @return {?}\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this._changeDetector.markForCheck();\n    }\n}\nMatRadioGroup.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-radio-group',\n                exportAs: 'matRadioGroup',\n                providers: [MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],\n                host: {\n                    'role': 'radiogroup',\n                    'class': 'mat-radio-group',\n                },\n            },] }\n];\n/** @nocollapse */\nMatRadioGroup.ctorParameters = () => [\n    { type: ChangeDetectorRef }\n];\nMatRadioGroup.propDecorators = {\n    change: [{ type: Output }],\n    _radios: [{ type: ContentChildren, args: [forwardRef((/**\n                 * @return {?}\n                 */\n                () => MatRadioButton)), { descendants: true },] }],\n    color: [{ type: Input }],\n    name: [{ type: Input }],\n    labelPosition: [{ type: Input }],\n    value: [{ type: Input }],\n    selected: [{ type: Input }],\n    disabled: [{ type: Input }],\n    required: [{ type: Input }]\n};\nif (false) {\n    /** @type {?} */\n    MatRadioGroup.ngAcceptInputType_disabled;\n    /** @type {?} */\n    MatRadioGroup.ngAcceptInputType_required;\n    /**\n     * Selected value for the radio group.\n     * @type {?}\n     * @private\n     */\n    MatRadioGroup.prototype._value;\n    /**\n     * The HTML name attribute applied to radio buttons in this group.\n     * @type {?}\n     * @private\n     */\n    MatRadioGroup.prototype._name;\n    /**\n     * The currently selected radio button. Should match value.\n     * @type {?}\n     * @private\n     */\n    MatRadioGroup.prototype._selected;\n    /**\n     * Whether the `value` has been set to its initial value.\n     * @type {?}\n     * @private\n     */\n    MatRadioGroup.prototype._isInitialized;\n    /**\n     * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'\n     * @type {?}\n     * @private\n     */\n    MatRadioGroup.prototype._labelPosition;\n    /**\n     * Whether the radio group is disabled.\n     * @type {?}\n     * @private\n     */\n    MatRadioGroup.prototype._disabled;\n    /**\n     * Whether the radio group is required.\n     * @type {?}\n     * @private\n     */\n    MatRadioGroup.prototype._required;\n    /**\n     * The method to be called in order to update ngModel\n     * @type {?}\n     */\n    MatRadioGroup.prototype._controlValueAccessorChangeFn;\n    /**\n     * onTouch function registered via registerOnTouch (ControlValueAccessor).\n     * \\@docs-private\n     * @type {?}\n     */\n    MatRadioGroup.prototype.onTouched;\n    /**\n     * Event emitted when the group value changes.\n     * Change events are only emitted when the value changes due to user interaction with\n     * a radio button (the same behavior as `<input type-\"radio\">`).\n     * @type {?}\n     */\n    MatRadioGroup.prototype.change;\n    /**\n     * Child radio buttons.\n     * @type {?}\n     */\n    MatRadioGroup.prototype._radios;\n    /**\n     * Theme color for all of the radio buttons in the group.\n     * @type {?}\n     */\n    MatRadioGroup.prototype.color;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatRadioGroup.prototype._changeDetector;\n}\n// Boilerplate for applying mixins to MatRadioButton.\n/**\n * \\@docs-private\n */\nclass MatRadioButtonBase {\n    /**\n     * @param {?} _elementRef\n     */\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nif (false) {\n    /** @type {?} */\n    MatRadioButtonBase.prototype.disabled;\n    /** @type {?} */\n    MatRadioButtonBase.prototype._elementRef;\n}\n// As per Material design specifications the selection control radio should use the accent color\n// palette by default. https://material.io/guidelines/components/selection-controls.html\n/** @type {?} */\nconst _MatRadioButtonMixinBase = mixinDisableRipple(mixinTabIndex(MatRadioButtonBase));\n/**\n * Base class with all of the `MatRadioButton` functionality.\n * \\@docs-private\n * @abstract\n */\n// tslint:disable-next-line:class-name\nclass _MatRadioButtonBase extends _MatRadioButtonMixinBase {\n    /**\n     * @param {?} radioGroup\n     * @param {?} elementRef\n     * @param {?} _changeDetector\n     * @param {?} _focusMonitor\n     * @param {?} _radioDispatcher\n     * @param {?=} _animationMode\n     * @param {?=} _providerOverride\n     */\n    constructor(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher, _animationMode, _providerOverride) {\n        super(elementRef);\n        this._changeDetector = _changeDetector;\n        this._focusMonitor = _focusMonitor;\n        this._radioDispatcher = _radioDispatcher;\n        this._animationMode = _animationMode;\n        this._providerOverride = _providerOverride;\n        this._uniqueId = `mat-radio-${++nextUniqueId}`;\n        /**\n         * The unique ID for the radio button.\n         */\n        this.id = this._uniqueId;\n        /**\n         * Event emitted when the checked state of this radio button changes.\n         * Change events are only emitted when the value changes due to user interaction with\n         * the radio button (the same behavior as `<input type-\"radio\">`).\n         */\n        this.change = new EventEmitter();\n        /**\n         * Whether this radio is checked.\n         */\n        this._checked = false;\n        /**\n         * Value assigned to this radio.\n         */\n        this._value = null;\n        /**\n         * Unregister function for _radioDispatcher\n         */\n        this._removeUniqueSelectionListener = (/**\n         * @return {?}\n         */\n        () => { });\n        // Assertions. Ideally these should be stripped out by the compiler.\n        // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n        this.radioGroup = radioGroup;\n        this._removeUniqueSelectionListener =\n            _radioDispatcher.listen((/**\n             * @param {?} id\n             * @param {?} name\n             * @return {?}\n             */\n            (id, name) => {\n                if (id !== this.id && name === this.name) {\n                    this.checked = false;\n                }\n            }));\n    }\n    /**\n     * Whether this radio button is checked.\n     * @return {?}\n     */\n    get checked() { return this._checked; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set checked(value) {\n        /** @type {?} */\n        const newCheckedState = coerceBooleanProperty(value);\n        if (this._checked !== newCheckedState) {\n            this._checked = newCheckedState;\n            if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n                this.radioGroup.selected = this;\n            }\n            else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n                // When unchecking the selected radio button, update the selected radio\n                // property on the group.\n                this.radioGroup.selected = null;\n            }\n            if (newCheckedState) {\n                // Notify all radio buttons with the same name to un-check.\n                this._radioDispatcher.notify(this.id, this.name);\n            }\n            this._changeDetector.markForCheck();\n        }\n    }\n    /**\n     * The value of this radio button.\n     * @return {?}\n     */\n    get value() { return this._value; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set value(value) {\n        if (this._value !== value) {\n            this._value = value;\n            if (this.radioGroup !== null) {\n                if (!this.checked) {\n                    // Update checked when the value changed to match the radio group's value\n                    this.checked = this.radioGroup.value === value;\n                }\n                if (this.checked) {\n                    this.radioGroup.selected = this;\n                }\n            }\n        }\n    }\n    /**\n     * Whether the label should appear after or before the radio button. Defaults to 'after'\n     * @return {?}\n     */\n    get labelPosition() {\n        return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set labelPosition(value) {\n        this._labelPosition = value;\n    }\n    /**\n     * Whether the radio button is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._setDisabled(coerceBooleanProperty(value));\n    }\n    /**\n     * Whether the radio button is required.\n     * @return {?}\n     */\n    get required() {\n        return this._required || (this.radioGroup && this.radioGroup.required);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set required(value) {\n        this._required = coerceBooleanProperty(value);\n    }\n    /**\n     * Theme color of the radio button.\n     * @return {?}\n     */\n    get color() {\n        return this._color ||\n            (this.radioGroup && this.radioGroup.color) ||\n            this._providerOverride && this._providerOverride.color || 'accent';\n    }\n    /**\n     * @param {?} newValue\n     * @return {?}\n     */\n    set color(newValue) { this._color = newValue; }\n    /**\n     * ID of the native input element inside `<mat-radio-button>`\n     * @return {?}\n     */\n    get inputId() { return `${this.id || this._uniqueId}-input`; }\n    /**\n     * Focuses the radio button.\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(options) {\n        this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);\n    }\n    /**\n     * Marks the radio button as needing checking for change detection.\n     * This method is exposed because the parent radio group will directly\n     * update bound properties of the radio button.\n     * @return {?}\n     */\n    _markForCheck() {\n        // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n        // update radio button's status\n        this._changeDetector.markForCheck();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this.radioGroup) {\n            // If the radio is inside a radio group, determine if it should be checked\n            this.checked = this.radioGroup.value === this._value;\n            // Copy name from parent radio group\n            this.name = this.radioGroup.name;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        this._focusMonitor\n            .monitor(this._elementRef, true)\n            .subscribe((/**\n         * @param {?} focusOrigin\n         * @return {?}\n         */\n        focusOrigin => {\n            if (!focusOrigin && this.radioGroup) {\n                this.radioGroup._touch();\n            }\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n        this._removeUniqueSelectionListener();\n    }\n    /**\n     * Dispatch change event with current value.\n     * @private\n     * @return {?}\n     */\n    _emitChangeEvent() {\n        this.change.emit(new MatRadioChange(this, this._value));\n    }\n    /**\n     * @return {?}\n     */\n    _isRippleDisabled() {\n        return this.disableRipple || this.disabled;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    _onInputClick(event) {\n        // We have to stop propagation for click events on the visual hidden input element.\n        // By default, when a user clicks on a label element, a generated click event will be\n        // dispatched on the associated input element. Since we are using a label element as our\n        // root container, the click event on the `radio-button` will be executed twice.\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\n        // This will lead to multiple click events.\n        // Preventing bubbling for the second event will solve that issue.\n        event.stopPropagation();\n    }\n    /**\n     * Triggered when the radio button received a click or the input recognized any change.\n     * Clicking on a label element, will trigger a change event on the associated input.\n     * @param {?} event\n     * @return {?}\n     */\n    _onInputChange(event) {\n        // We always have to stop propagation on the change event.\n        // Otherwise the change event, from the input element, will bubble up and\n        // emit its event object to the `change` output.\n        event.stopPropagation();\n        /** @type {?} */\n        const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n        this.checked = true;\n        this._emitChangeEvent();\n        if (this.radioGroup) {\n            this.radioGroup._controlValueAccessorChangeFn(this.value);\n            if (groupValueChanged) {\n                this.radioGroup._emitChangeEvent();\n            }\n        }\n    }\n    /**\n     * Sets the disabled state and marks for check if a change occurred.\n     * @protected\n     * @param {?} value\n     * @return {?}\n     */\n    _setDisabled(value) {\n        if (this._disabled !== value) {\n            this._disabled = value;\n            this._changeDetector.markForCheck();\n        }\n    }\n}\n_MatRadioButtonBase.decorators = [\n    { type: Directive }\n];\n/** @nocollapse */\n_MatRadioButtonBase.ctorParameters = () => [\n    { type: MatRadioGroup, decorators: [{ type: Optional }] },\n    { type: ElementRef },\n    { type: ChangeDetectorRef },\n    { type: FocusMonitor },\n    { type: UniqueSelectionDispatcher },\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_RADIO_DEFAULT_OPTIONS,] }] }\n];\n_MatRadioButtonBase.propDecorators = {\n    id: [{ type: Input }],\n    name: [{ type: Input }],\n    ariaLabel: [{ type: Input, args: ['aria-label',] }],\n    ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }],\n    ariaDescribedby: [{ type: Input, args: ['aria-describedby',] }],\n    checked: [{ type: Input }],\n    value: [{ type: Input }],\n    labelPosition: [{ type: Input }],\n    disabled: [{ type: Input }],\n    required: [{ type: Input }],\n    color: [{ type: Input }],\n    change: [{ type: Output }],\n    _inputElement: [{ type: ViewChild, args: ['input',] }]\n};\nif (false) {\n    /** @type {?} */\n    _MatRadioButtonBase.ngAcceptInputType_checked;\n    /** @type {?} */\n    _MatRadioButtonBase.ngAcceptInputType_disabled;\n    /** @type {?} */\n    _MatRadioButtonBase.ngAcceptInputType_required;\n    /** @type {?} */\n    _MatRadioButtonBase.ngAcceptInputType_disableRipple;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._uniqueId;\n    /**\n     * The unique ID for the radio button.\n     * @type {?}\n     */\n    _MatRadioButtonBase.prototype.id;\n    /**\n     * Analog to HTML 'name' attribute used to group radios for unique selection.\n     * @type {?}\n     */\n    _MatRadioButtonBase.prototype.name;\n    /**\n     * Used to set the 'aria-label' attribute on the underlying input element.\n     * @type {?}\n     */\n    _MatRadioButtonBase.prototype.ariaLabel;\n    /**\n     * The 'aria-labelledby' attribute takes precedence as the element's text alternative.\n     * @type {?}\n     */\n    _MatRadioButtonBase.prototype.ariaLabelledby;\n    /**\n     * The 'aria-describedby' attribute is read after the element's label and field type.\n     * @type {?}\n     */\n    _MatRadioButtonBase.prototype.ariaDescribedby;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._labelPosition;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._color;\n    /**\n     * Event emitted when the checked state of this radio button changes.\n     * Change events are only emitted when the value changes due to user interaction with\n     * the radio button (the same behavior as `<input type-\"radio\">`).\n     * @type {?}\n     */\n    _MatRadioButtonBase.prototype.change;\n    /**\n     * The parent radio group. May or may not be present.\n     * @type {?}\n     */\n    _MatRadioButtonBase.prototype.radioGroup;\n    /**\n     * Whether this radio is checked.\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._checked;\n    /**\n     * Whether this radio is disabled.\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._disabled;\n    /**\n     * Whether this radio is required.\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._required;\n    /**\n     * Value assigned to this radio.\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._value;\n    /**\n     * Unregister function for _radioDispatcher\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._removeUniqueSelectionListener;\n    /**\n     * The native `<input type=radio>` element\n     * @type {?}\n     */\n    _MatRadioButtonBase.prototype._inputElement;\n    /**\n     * @type {?}\n     * @protected\n     */\n    _MatRadioButtonBase.prototype._changeDetector;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._focusMonitor;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._radioDispatcher;\n    /** @type {?} */\n    _MatRadioButtonBase.prototype._animationMode;\n    /**\n     * @type {?}\n     * @private\n     */\n    _MatRadioButtonBase.prototype._providerOverride;\n}\n/**\n * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\n */\nclass MatRadioButton extends _MatRadioButtonBase {\n}\nMatRadioButton.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-radio-button',\n                template: \"<!-- TODO(jelbourn): render the radio on either side of the content -->\\n<!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. -->\\n<label [attr.for]=\\\"inputId\\\" class=\\\"mat-radio-label\\\" #label>\\n  <!-- The actual 'radio' part of the control. -->\\n  <div class=\\\"mat-radio-container\\\">\\n    <div class=\\\"mat-radio-outer-circle\\\"></div>\\n    <div class=\\\"mat-radio-inner-circle\\\"></div>\\n    <input #input class=\\\"mat-radio-input cdk-visually-hidden\\\" type=\\\"radio\\\"\\n        [id]=\\\"inputId\\\"\\n        [checked]=\\\"checked\\\"\\n        [disabled]=\\\"disabled\\\"\\n        [tabIndex]=\\\"tabIndex\\\"\\n        [attr.name]=\\\"name\\\"\\n        [attr.value]=\\\"value\\\"\\n        [required]=\\\"required\\\"\\n        [attr.aria-label]=\\\"ariaLabel\\\"\\n        [attr.aria-labelledby]=\\\"ariaLabelledby\\\"\\n        [attr.aria-describedby]=\\\"ariaDescribedby\\\"\\n        (change)=\\\"_onInputChange($event)\\\"\\n        (click)=\\\"_onInputClick($event)\\\">\\n\\n    <!-- The ripple comes after the input so that we can target it with a CSS\\n         sibling selector when the input is focused. -->\\n    <div mat-ripple class=\\\"mat-radio-ripple mat-focus-indicator\\\"\\n         [matRippleTrigger]=\\\"label\\\"\\n         [matRippleDisabled]=\\\"_isRippleDisabled()\\\"\\n         [matRippleCentered]=\\\"true\\\"\\n         [matRippleRadius]=\\\"20\\\"\\n         [matRippleAnimation]=\\\"{enterDuration: 150}\\\">\\n\\n      <div class=\\\"mat-ripple-element mat-radio-persistent-ripple\\\"></div>\\n    </div>\\n  </div>\\n\\n  <!-- The label content for radio control. -->\\n  <div class=\\\"mat-radio-label-content\\\" [class.mat-radio-label-before]=\\\"labelPosition == 'before'\\\">\\n    <!-- Add an invisible span so JAWS can read the label -->\\n    <span style=\\\"display:none\\\">&nbsp;</span>\\n    <ng-content></ng-content>\\n  </div>\\n</label>\\n\",\n                inputs: ['disableRipple', 'tabIndex'],\n                encapsulation: ViewEncapsulation.None,\n                exportAs: 'matRadioButton',\n                host: {\n                    'class': 'mat-radio-button',\n                    '[class.mat-radio-checked]': 'checked',\n                    '[class.mat-radio-disabled]': 'disabled',\n                    '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                    '[class.mat-primary]': 'color === \"primary\"',\n                    '[class.mat-accent]': 'color === \"accent\"',\n                    '[class.mat-warn]': 'color === \"warn\"',\n                    // Needs to be -1 so the `focus` event still fires.\n                    '[attr.tabindex]': '-1',\n                    '[attr.id]': 'id',\n                    '[attr.aria-label]': 'null',\n                    '[attr.aria-labelledby]': 'null',\n                    '[attr.aria-describedby]': 'null',\n                    // Note: under normal conditions focus shouldn't land on this element, however it may be\n                    // programmatically set, for example inside of a focus trap, in this case we want to forward\n                    // the focus to the native element.\n                    '(focus)': '_inputElement.nativeElement.focus()',\n                },\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                styles: [\".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle;width:100%}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:transform ease 280ms,background-color ease 280ms;width:20px;transform:scale(0.001)}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-checked .mat-radio-inner-circle{transform:scale(0.5)}.cdk-high-contrast-active .mat-radio-checked .mat-radio-inner-circle{border:solid 10px}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-persistent-ripple,.mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-persistent-ripple,.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple{opacity:0}@media(hover: none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}.cdk-high-contrast-active .mat-radio-disabled{opacity:.5}\\n\"]\n            }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/radio/radio-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatRadioModule {\n}\nMatRadioModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [MatRippleModule, MatCommonModule],\n                exports: [MatRadioGroup, MatRadioButton, MatCommonModule],\n                declarations: [MatRadioGroup, MatRadioButton],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/radio/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_RADIO_DEFAULT_OPTIONS, MAT_RADIO_DEFAULT_OPTIONS_FACTORY, MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, MatRadioButton, MatRadioChange, MatRadioGroup, MatRadioModule, _MatRadioButtonBase };\n//# sourceMappingURL=radio.js.map\n","<!-- TODO(jelbourn): render the radio on either side of the content -->\n<!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. -->\n<label [attr.for]=\"inputId\" class=\"mat-radio-label\" #label>\n  <!-- The actual 'radio' part of the control. -->\n  <div class=\"mat-radio-container\">\n    <div class=\"mat-radio-outer-circle\"></div>\n    <div class=\"mat-radio-inner-circle\"></div>\n    <input #input class=\"mat-radio-input cdk-visually-hidden\" type=\"radio\"\n        [id]=\"inputId\"\n        [checked]=\"checked\"\n        [disabled]=\"disabled\"\n        [tabIndex]=\"tabIndex\"\n        [attr.name]=\"name\"\n        [attr.value]=\"value\"\n        [required]=\"required\"\n        [attr.aria-label]=\"ariaLabel\"\n        [attr.aria-labelledby]=\"ariaLabelledby\"\n        [attr.aria-describedby]=\"ariaDescribedby\"\n        (change)=\"_onInputChange($event)\"\n        (click)=\"_onInputClick($event)\">\n\n    <!-- The ripple comes after the input so that we can target it with a CSS\n         sibling selector when the input is focused. -->\n    <div mat-ripple class=\"mat-radio-ripple mat-focus-indicator\"\n         [matRippleTrigger]=\"label\"\n         [matRippleDisabled]=\"_isRippleDisabled()\"\n         [matRippleCentered]=\"true\"\n         [matRippleRadius]=\"20\"\n         [matRippleAnimation]=\"{enterDuration: 150}\">\n\n      <div class=\"mat-ripple-element mat-radio-persistent-ripple\"></div>\n    </div>\n  </div>\n\n  <!-- The label content for radio control. -->\n  <div class=\"mat-radio-label-content\" [class.mat-radio-label-before]=\"labelPosition == 'before'\">\n    <!-- Add an invisible span so JAWS can read the label -->\n    <span style=\"display:none\">&nbsp;</span>\n    <ng-content></ng-content>\n  </div>\n</label>\n"],"sourceRoot":"webpack:///"}