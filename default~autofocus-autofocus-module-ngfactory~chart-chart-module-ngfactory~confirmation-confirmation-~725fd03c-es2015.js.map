{"version":3,"sources":["/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/select/fesm2015/terminus-ui-select.js","/home/runner/work/terminus-oss/terminus-oss/node_modules/@angular/material/fesm2015/chips.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwD;AACiC;AAC1C;AACqM;AAC5L;AACqB;AACpB;AACA;AACqB;AACrB;AACuB;AAC/B;AACE;AAC8L;AACnK;AACf;AACL;AACgB;AACZ;AACF;AACI;AACiB;AAC7B;AACoB;AACqC;AAC3D;AAC+B;;AAEjF;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAO;AAC3B,QAAQ,kEAAK,SAAS,kEAAK;AAC3B;AACA;AACA;AACA,SAAS;AACT,QAAQ,kEAAK,YAAY,kEAAK;AAC9B;AACA;AACA;AACA,SAAS;AACT,QAAQ,kEAAK,qBAAqB,kEAAK;AACvC;AACA;AACA;AACA,SAAS;AACT,QAAQ,uEAAU,cAAc,oEAAO;AACvC,QAAQ,uEAAU,cAAc,oEAAO,sBAAsB,kEAAK,EAAE,aAAa;AACjF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,2BAA2B,wDAAU;AACrC,IAAI,+DAAS;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,yBAAyB,qEAAuB;AAChD,uBAAuB,+DAAiB;AACxC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAU;AACjC;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA,gCAAgC,6CAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAK,OAAO,mDAAK;AACzB;AACA;AACA;AACA,4CAA4C,6CAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA,gCAAgC,qDAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA,sCAAsC,0DAAY;AAClD;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA,oCAAoC,0DAAY;AAChD;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,2CAA2C,0DAAY;AACvD;AACA;AACA;AACA,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kFAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mFAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+DAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iFAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yFAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0FAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wEAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8FAAuB;AACjD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8FAAuB;AAChE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,QAAQ,iEAAS,QAAQ,8FAAuB;AAChD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sFAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4DAAI;AACrD;AACA;AACA,8EAA8E,qBAAqB;AACnG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4DAAI;AAChD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kEAAI,kBAAkB,kEAAI,gBAAgB,kEAAI,kBAAkB,kEAAI;AAC/F;AACA,sCAAsC,kEAAI,2BAA2B,kEAAI;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kEAAI,gCAAgC,kEAAI;AAC/E;AACA;AACA;AACA,wBAAwB,kEAAI,0BAA0B,kEAAI;AAC1D;AACA;AACA,wBAAwB,kEAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAI,4BAA4B,kEAAI;AAClE;AACA;AACA;AACA;AACA,mDAAmD,kEAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,kEAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iEAAS,wBAAwB,8FAAuB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,mDAAK;AACb,kBAAkB,8FAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6EAA0B;AACxD;AACA;AACA;AACA,oCAAoC,8FAAuB;AAC3D;AACA;AACA;AACA;AACA,SAAS;AACT,oCAAoC,8FAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iFAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yFAA4B;AACvD,sBAAsB,oFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yFAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oFAAW;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6EAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,kEAAa,EAAE;AAC3B,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,oDAAM,EAAE;AACpB,KAAK,OAAO,8EAAiB,EAAE;AAC/B,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,wDAAS,gBAAgB,OAAO,kDAAI,EAAE,GAAG,OAAO,sDAAQ,EAAE;AACtE;AACA,wDAAU;AACV,IAAI,kEAAY;AAChB,IAAI,wDAAU;AACd;AACA,wD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;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA,uBAAuB;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA,uBAAuB;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAO;AACnC;AACA;AACA;AACA,2BAA2B,4CAAO;AAClC;AACA;AACA;AACA,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA,2BAA2B,0DAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qEAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,oBAAoB,uBAAuB;AAC3C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,6BAA6B,mFAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,sBAAsB,oDAAoD;AAC1E;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,2BAA2B,mFAAqB;AAChD;AACA;AACA;AACA,gBAAgB;AAChB;AACA,qBAAqB,wBAAwB;AAC7C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,0BAA0B,mFAAqB;AAC/C;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4DAAM;AACvB,iBAAiB,+DAAS;AAC1B;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAI;AACtB;AACA,oBAAoB;AACpB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,mCAAmC,aAAa;AAChD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,oDAAM,EAAE;AACpB,KAAK,OAAO,8DAAQ,EAAE;AACtB,KAAK,gCAAgC,OAAO,sDAAQ,EAAE,GAAG,OAAO,oDAAM,SAAS,gFAAyB,IAAI,GAAG;AAC/G,KAAK,6BAA6B,OAAO,sDAAQ,EAAE,GAAG,OAAO,oDAAM,SAAS,0FAAqB,IAAI,GAAG;AACxG,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,6BAA6B,OAAO,uDAAS,uBAAuB,GAAG;AAC5E,KAAK,gCAAgC,OAAO,sDAAQ,EAAE,GAAG,OAAO,oDAAM,SAAS,wDAAQ,IAAI;AAC3F;AACA;AACA,cAAc,OAAO,0DAAY,0BAA0B;AAC3D,oBAAoB,OAAO,0DAAY,gCAAgC;AACvE,kBAAkB,OAAO,0DAAY,SAAS,gEAAU;AACxD,4BAA4B;AAC5B;AACA,yCAAyC;AACzC,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,aAAa,OAAO,mDAAK,EAAE;AAC3B,kBAAkB,OAAO,mDAAK,EAAE;AAChC,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,uBAAuB,OAAO,oDAAM,EAAE;AACtC,iBAAiB,OAAO,oDAAM,EAAE;AAChC,eAAe,OAAO,oDAAM,EAAE;AAC9B;AACA,WAAW,EA6HV;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK,gBAAgB;AACrB,KAAK,OAAO,wDAAU;AACtB;AACA,WAAW,EAMV;;AAED;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,WAAW,EAMV;AACD;AACA;AACA,UAAU;AACV;AACA,sCAAsC,4DAAc;;AAEpD;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAYV;AACD,WAAW,EAAE;AACb,8BAA8B,8EAAe;AAC7C;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAWV;AACD;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4CAAO;AACrC;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,eAAe,EAAE;AACjB;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,gBAAgB;AAChB;AACA,oBAAoB,uBAAuB;AAC3C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,yBAAyB,mFAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,uBAAuB,0BAA0B;AACjD;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB,oBAAoB;AACrC;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,oBAAoB,uBAAuB;AAC3C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,yBAAyB,mFAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,4BAA4B,oCAAoC;AAChE;AACA;AACA;AACA,gBAAgB;AAChB;AACA,oBAAoB,oEAAoE;AACxF;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,yBAAyB,mFAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,sBAAsB,yBAAyB;AAC/C;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,2BAA2B,mFAAqB;AAChD;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,kDAAK;AACpB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,kDAAK;AACpB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,kDAAK;AACpB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,kDAAK;AACpB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,+BAA+B,iEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAS;AAC/B;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA,qCAAqC,gEAAS;AAC9C,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,gEAAS,QAAQ,gEAAS;AAC1D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mCAAmC,wEAAc;AACjD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,mCAAmC,EAAE;AACrC;AACA,8BAA8B,+DAAS;AACvC;AACA;AACA;AACA;AACA,kCAAkC,0DAAI;AACtC;AACA;AACA;AACA,uCAAuC,yDAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB,EAAE;AAClB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AAC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AAE;AACjB,gBAAgB;AAChB;AACA,yBAAyB,kBAAkB,mFAAqB,QAAQ;AACxE;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB,kCAAkC;AACnD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uCAAuC,yDAAG,KAAK,4EAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAA6D;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,YAAY,4EAAc;AAC1B;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,gCAAgC,OAAO,oDAAM,sCAAsC;AACxF;AACA;AACA,gBAAgB,OAAO,mDAAK,8BAA8B;AAC1D,iBAAiB,OAAO,mDAAK,oCAAoC;AACjE,yBAAyB,OAAO,mDAAK,4CAA4C;AACjF,eAAe,OAAO,oDAAM,mCAAmC;AAC/D,mBAAmB,OAAO,mDAAK,EAAE;AACjC,UAAU,OAAO,mDAAK,EAAE;AACxB,gBAAgB,OAAO,mDAAK,EAAE;AAC9B;AACA,WAAW,EAyDV;;AAED;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAK;AAC7B,CAAC;AACD;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC;AACA;AACA,8CAA8C,EAAE;AAChD;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;;AAEA;AACA;AACA;;AAEuL;AACvL","file":"default~autofocus-autofocus-module-ngfactory~chart-chart-module-ngfactory~confirmation-confirmation-~725fd03c-es2015.js","sourcesContent":["import { __decorate, __metadata, __param } from 'tslib';\nimport { ViewportRuler, CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { Input, Component, ChangeDetectionStrategy, ViewEncapsulation, EventEmitter, isDevMode, ChangeDetectorRef, NgZone, ElementRef, Self, Optional, ContentChild, ViewChild, ContentChildren, QueryList, Output, NgModule } from '@angular/core';\nimport { FlexLayoutModule } from '@angular/flex-layout';\nimport { NgControl, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { MatChipsModule } from '@angular/material/chips';\nimport { MatRippleModule } from '@angular/material/core';\nimport { MatProgressSpinnerModule } from '@angular/material/progress-spinner';\nimport { TsCheckboxModule } from '@terminus/ui-checkbox';\nimport { TsFormFieldControl, TsFormFieldModule } from '@terminus/ui-form-field';\nimport { TsIconModule } from '@terminus/ui-icon';\nimport { TsInputModule } from '@terminus/ui-input';\nimport { allOptionsAreSelected, someOptionsAreSelected, countGroupLabelsBeforeOption, getOptionScrollPosition, toggleAllOptions, TsOptionComponent, TsOptgroupComponent, TS_OPTION_PARENT_COMPONENT, TsOptionModule } from '@terminus/ui-option';\nimport { TsValidationMessagesModule } from '@terminus/ui-validation-messages';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { MAT_CHECKBOX_DEFAULT_OPTIONS } from '@angular/material/checkbox';\nimport { Subject, defer, merge, BehaviorSubject } from 'rxjs';\nimport { startWith, take, takeUntil } from 'rxjs/operators';\nimport { TsDocumentService } from '@terminus/ngx-tools/browser';\nimport { coerceNumberProperty, coerceArray } from '@terminus/ngx-tools/coercion';\nimport { KEYS } from '@terminus/ngx-tools/keycodes';\nimport { isString, isUndefined } from '@terminus/ngx-tools/type-guards';\nimport { hasRequiredControl, untilComponentDestroyed, inputHasChanged } from '@terminus/ngx-tools/utilities';\nimport { TS_SPACING } from '@terminus/ui-spacing';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\n\n/**\n * The defined panel animations for the {@link TsSelectComponent}\n */\nconst tsSelectAnimations = {\n    /**\n     * This animation transforms the select's overlay panel on and off the page.\n     *\n     * When the panel is attached to the DOM, it expands its width by the amount of padding, scales it\n     * up to 100% on the Y axis, fades in its border, and translates slightly up and to the\n     * side to ensure the option text correctly overlaps the trigger text.\n     *\n     * When the panel is removed from the DOM, it simply fades out linearly.\n     */\n    transformPanel: trigger('transformPanel', [\n        state('void', style({\n            transform: 'scaleY(0.8)',\n            minWidth: '100%',\n            opacity: 0,\n        })),\n        state('showing', style({\n            opacity: 1,\n            minWidth: 'calc(100% + 32px)',\n            transform: 'scaleY(1)',\n        })),\n        state('showing-multiple', style({\n            opacity: 1,\n            minWidth: 'calc(100% + 24px)',\n            transform: 'scaleY(1)',\n        })),\n        transition('void => *', animate('120ms cubic-bezier(0, 0, 0.2, 1)')),\n        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 }))),\n    ]),\n};\n\n// Unique ID for each instance\nlet nextUniqueId = 0;\n/**\n * Allows the user to customize the trigger that is displayed when the select has a value.\n *\n * @deprecated Please use `TsSelectionListTriggerDirective`\n */\nlet TsSelectTriggerComponent = class TsSelectTriggerComponent {\n    constructor() {\n        /**\n         * Define the default component ID\n         */\n        this.uid = `ts-select-trigger-${nextUniqueId++}`;\n        this._id = this.uid;\n    }\n    /**\n     * Define an ID for the component\n     *\n     * @param value\n     */\n    set id(value) {\n        this._id = value || this.uid;\n    }\n    get id() {\n        return this._id;\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsSelectTriggerComponent.prototype, \"id\", null);\nTsSelectTriggerComponent = __decorate([\n    Component({\n        selector: 'ts-select-trigger',\n        template: `<ng-content></ng-content>`,\n        host: {\n            'class': 'ts-select-custom-trigger qa-select-custom-trigger',\n            '[attr.id]': 'id',\n        },\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        encapsulation: ViewEncapsulation.None,\n        exportAs: 'tsSelectTrigger'\n    })\n], TsSelectTriggerComponent);\n\nvar TsSelectComponent_1;\n/**\n * The following style constants are necessary to save here in order to properly calculate the alignment of the selected option over the\n * trigger element.\n */\n// The max height of the select's overlay panel\nconst SELECT_PANEL_MAX_HEIGHT = 256;\n// The panel's padding on the x-axis\nconst SELECT_PANEL_PADDING_X = 16;\nconst SELECT_ITEM_HEIGHT = 3;\n// The panel's x axis padding if it is indented (e.g. there is an option group)\n// eslint-disable-next-line @typescript-eslint/no-magic-numbers\nconst SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_PADDING_X * 2;\n// The height of the select items in `em` units\nconst SELECT_ITEM_HEIGHT_EM = SELECT_ITEM_HEIGHT;\n/**\n * Distance between the panel edge and the option text in multi-selection mode.\n *\n * Calculated as:\n * (SELECT_PANEL_PADDING_X * 1.5) + 20 = 44\n * The padding is multiplied by 1.5 because the checkbox's margin is half the padding.\n * The checkbox width is 16px.\n */\nconst SELECT_MULTIPLE_PANEL_PADDING_X = 0;\n/**\n * The select panel will only \"fit\" inside the viewport if it is positioned at this value or more away from the viewport boundary\n */\nconst SELECT_PANEL_VIEWPORT_PADDING = 8;\nconst DEFAULT_DELIMITER = ',';\n/**\n * The default compare with function used when the consumer does not define one\n *\n * @param o1\n * @param o2\n */\nconst DEFAULT_COMPARE_WITH = (o1, o2) => o1 === o2;\n/**\n * The select panel will only \"fit\" inside the viewport if it is positioned at this value or more away from the viewport boundary\n */\nconst TS_SELECT_PANEL_VIEWPORT_PADDING = 8;\n/**\n * The event object that is emitted when the select value has changed\n */\nclass TsSelectChange {\n    constructor(\n    // Reference to the select that emitted the change event\n    // eslint-disable-next-line deprecation/deprecation\n    source, \n    // The current value\n    value) {\n        this.source = source;\n        this.value = value;\n    }\n}\n// Unique ID for each instance\nlet nextUniqueId$1 = 0;\nconst DEFAULT_VIEWPORT_MARGIN = 100;\nconst ɵ0 = { clickAction: 'noop' };\n/**\n * A component to create a select menu\n *\n * @deprecated Please use `TsSelectionListComponent`\n *\n * @example\n * <ts-select\n *              [allowMultiple]=\"true\"\n *              [compareWith]=\"myCompareFn\"\n *              delimiter=\",\"\n *              [hideRequiredMarker]=\"true\"\n *              hint=\"My hint!\"\n *              id=\"my-id\"\n *              [isDisabled]=\"true\"\n *              [isFilterable]=\"true\"\n *              [isRequired]=\"true\"\n *              label=\"My label!\"\n *              placeholder=\"My placeholder!\"\n *              [showProgress]=\"true\"\n *              [showRefineSearchMessage]=\"true\"\n *              [showRefresh]=\"true\"\n *              [sortComparator]=\"myComparator\"\n *              tabIndex=\"-1\"\n *              theme=\"primary\"\n *              [totalHiddenResults]=\"1278\"\n *              [validateOnChange]=\"true\"\n *              value=\"My value!\"\n *              (closed)=\"panelWasClosed($event)\"\n *              (duplicateSelection)=\"duplicateWasSelected($event)\"\n *              (opened)=\"panelWasOpened($event)\"\n *              (optionDeselected)=\"optionWasDeselected($event)\"\n *              (optionSelected)=\"optionWasSelected($event)\"\n *              (optionsRefreshRequested)=\"refreshWasSelected()\"\n *              (queryChange)=\"searchQueryChanged($event)\"\n *              (selectionChange)=\"aSelectionWasChanged($event)\"\n *              (valueChange)=\"theValueWasChanged($event)\"\n * ></ts-select>\n *\n * <example-url>https://getterminus.github.io/ui-demos-release/components/select</example-url>\n */\nlet TsSelectComponent = TsSelectComponent_1 = class TsSelectComponent {\n    constructor(viewportRuler, changeDetectorRef, ngZone, documentService, elementRef, ngControl) {\n        this.viewportRuler = viewportRuler;\n        this.changeDetectorRef = changeDetectorRef;\n        this.ngZone = ngZone;\n        this.documentService = documentService;\n        this.elementRef = elementRef;\n        this.ngControl = ngControl;\n        /**\n         * Give the component an explicit name\n         */\n        this.componentName = 'TsSelectComponent';\n        /**\n         * Define the flex layout gap\n         */\n        this.flexGap = TS_SPACING.small[0];\n        /**\n         * Subject used to alert the parent {@link FormFieldComponent} when the label gap should be recalculated\n         *\n         * Implemented as part of TsFormFieldControl.\n         */\n        this.labelChanges = new Subject();\n        /**\n         * The y-offset of the overlay panel in relation to the trigger's top start corner.\n         * This must be adjusted to align the selected option text over the trigger text.\n         * when the panel opens. This will be changed based on the y-position of the selected option.\n         */\n        this.offsetY = 0;\n        /**\n         * The IDs of child options to be passed to the aria-owns attribute.\n         */\n        this.optionIds = '';\n        /**\n         * Combined stream of all of the child options' change events\n         */\n        this.optionSelectionChanges = \n        // eslint-disable-next-line deprecation/deprecation\n        defer(() => merge(...this.options.map(option => option.selectionChange)));\n        /**\n         * Emits when the panel element is finished transforming in.\n         */\n        this.panelDoneAnimatingStream = new Subject();\n        /**\n         * Whether or not the overlay panel is open\n         */\n        this.panelOpen = false;\n        /**\n         * This position config ensures that the top \"start\" corner of the overlay\n         * is aligned with with the top \"start\" of the origin by default (overlapping\n         * the trigger completely).\n         */\n        this.positions = [\n            {\n                originX: 'start',\n                originY: 'top',\n                overlayX: 'start',\n                overlayY: 'top',\n            },\n            {\n                originX: 'start',\n                originY: 'bottom',\n                overlayX: 'start',\n                overlayY: 'bottom',\n            },\n        ];\n        /**\n         * The scroll position of the overlay panel, calculated to center the selected option.\n         */\n        this.scrollTop = 0;\n        /**\n         * Store the search query\n         */\n        this.searchQuery = '';\n        // Since the FormFieldComponent is inside this template, we cannot use a provider to pass this component instance to the form field.\n        // Instead, we pass it manually through the template with this reference.\n        this.selfReference = this;\n        /*\n         * Implemented as part of TsFormFieldControl.\n         */\n        this.stateChanges = new Subject();\n        /**\n         * The value of the select panel's transform-origin property\n         */\n        this.transformOrigin = 'top';\n        /**\n         * The cached font-size of the trigger element\n         */\n        this.triggerFontSize = 0;\n        /**\n         * Define the default component ID\n         */\n        this.uid = `ts-select-${nextUniqueId$1++}`;\n        /**\n         * Management of the query string\n         */\n        this.querySubject = new BehaviorSubject('');\n        /**\n         * Margin between select panel edge and viewport edge\n         */\n        this.viewportMarginSpacing = DEFAULT_VIEWPORT_MARGIN;\n        /**\n         * Define if multiple selections are allowed\n         */\n        this.allowMultiple = false;\n        this._compareWith = DEFAULT_COMPARE_WITH;\n        this._delimiter = DEFAULT_DELIMITER;\n        /**\n         * Define if the required marker should be hidden\n         */\n        this.hideRequiredMarker = false;\n        this._id = this.uid;\n        /**\n         * Define if the control should be disabled\n         */\n        this.isDisabled = false;\n        /**\n         * Define if the select is filterable\n         */\n        this.isFilterable = false;\n        this._isRequired = false;\n        /**\n         * Define whether a validation or a hint needed.\n         */\n        this.noValidationOrHint = false;\n        /**\n         * Define if the component should currently be showing a progress spinner\n         */\n        this.showProgress = false;\n        /**\n         * Define if the component should expose a message telling the user to refine their search\n         */\n        this.showRefineSearchMessage = false;\n        /**\n         * Define if the select should show an option to trigger a refresh (by emitting an event)\n         */\n        this.showRefresh = false;\n        this._tabIndex = 0;\n        /**\n         * Define the component theme\n         */\n        this.theme = 'primary';\n        /**\n         * Define if validation messages should be shown immediately or on blur\n         */\n        this.validateOnChange = false;\n        /**\n         * Event for when the panel is closed\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event for when a duplicate selection is made\n         */\n        this.duplicateSelection = new EventEmitter();\n        /**\n         * Event for when the panel is opened\n         */\n        this.opened = new EventEmitter();\n        /**\n         * Event for when an option is removed\n         */\n        this.optionDeselected = new EventEmitter();\n        /**\n         * Event for when an option is selected\n         */\n        this.optionSelected = new EventEmitter();\n        /**\n         * Event for when the user requests a refresh of the available options\n         */\n        this.optionsRefreshRequested = new EventEmitter();\n        /**\n         * Event for when the query has changed, used by filterable select\n         */\n        this.queryChange = new EventEmitter();\n        /**\n         * Event for when the selections change\n         */\n        this.selectionChange = new EventEmitter();\n        /**\n         * Event that emits whenever the raw value of the select changes. This is here primarily\n         * to facilitate the two-way binding for the `value` input.\n         *\n         * Needed for {@link TsFormFieldComponent}.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Stub in onChange\n         *\n         * Needed for ControlValueAccessor (View -> model callback called when value changes)\n         */\n        // istanbul ignore next\n        this.onChange = () => { };\n        /**\n         * Stub in onTouched\n         *\n         * Needed for ControlValueAccessor (View -> model callback called when select has been touched)\n         */\n        // istanbul ignore next\n        this.onTouched = () => { };\n        this.document = this.documentService.document;\n        // This is the assigned FormControl or NgModel\n        // istanbul ignore else\n        if (this.ngControl) {\n            // Note: we provide the value accessor through here, instead of the `providers` to avoid running into a circular import.\n            this.ngControl.valueAccessor = this;\n        }\n    }\n    /**\n     * Whether all options are selected\n     */\n    get allOptionsSelected() {\n        return allOptionsAreSelected(this.options);\n    }\n    /**\n     * Whether the select has a value\n     */\n    get empty() {\n        return this.selectionModel && this.selectionModel.isEmpty();\n    }\n    /**\n     * Whether the input has focus\n     */\n    get focused() {\n        const el = this.inputElement && this.inputElement.nativeElement;\n        return (this.document.activeElement === el) || this.panelOpen;\n    }\n    /**\n     * Calculates the amount of items in the select. This includes options and group labels.\n     */\n    get itemCount() {\n        return this.options.length + this.optionGroups.length;\n    }\n    /**\n     * Calculates the height of the options\n     *\n     * Only called if at least one option exists\n     */\n    get itemHeight() {\n        // Try to use the 2nd option in case the first option is blank or a filter etc. Fall back to the first item if needed.\n        const options = this.options.toArray();\n        const option = options[1] || options[0];\n        return option && option.elementRef.nativeElement.offsetHeight;\n    }\n    /**\n     * Whether at least 1 option is selected, but not all options\n     */\n    get someOptionsSelected() {\n        return someOptionsAreSelected(this.options);\n    }\n    /**\n     * Determine if the label should float\n     */\n    get shouldLabelFloat() {\n        return this.focused || !this.empty || this.searchQuery.length > 0;\n    }\n    /**\n     * The value displayed in the select trigger\n     */\n    get selectTriggerValue() {\n        if (this.allowMultiple) {\n            const selectedOptions = this.selectionModel.selected.map(option => option.viewValue);\n            return selectedOptions.join(`${this.delimiter} `);\n        }\n        return this.selectionModel.selected[0].viewValue;\n    }\n    /**\n     * The currently selected option or options\n     */\n    get selected() {\n        return this.allowMultiple ? this.selectionModel.selected : this.selectionModel.selected[0];\n    }\n    /**\n     * Function to compare the option values with the selected values. The first argument\n     * is a value from an option. The second is a value from the selection. A boolean\n     * should be returned.\n     *\n     * Learn more about `compareWith` in the Angular docs:\n     * https://angular.io/api/forms/SelectControlValueAccessor#customizing-option-selection\n     *\n     * @param fn\n     */\n    set compareWith(fn) {\n        if (typeof fn !== 'function' && isDevMode()) {\n            // eslint-disable-next-line no-console\n            console.warn(`TsSelectComponent: \"compareWith\" must be a function. Falling back to the default.`);\n            this._compareWith = DEFAULT_COMPARE_WITH;\n        }\n        this._compareWith = fn;\n        // A different comparator means the selection could change so we need to reinitialize any selections\n        if (this.selectionModel) {\n            this.initializeSelection();\n        }\n    }\n    get compareWith() {\n        return this._compareWith;\n    }\n    /**\n     * Define the delimiter used in the list of selected options\n     *\n     * @param value\n     */\n    set delimiter(value) {\n        this._delimiter = isString(value) ? value : DEFAULT_DELIMITER;\n    }\n    get delimiter() {\n        return this._delimiter;\n    }\n    /**\n     * Define a hint for the input\n     *\n     * @param value\n     */\n    set hint(value) {\n        this._hint = value;\n    }\n    get hint() {\n        return this._hint;\n    }\n    /**\n     * Define an ID for the component\n     *\n     * @param value\n     */\n    set id(value) {\n        this._id = value || this.uid;\n    }\n    get id() {\n        return this._id;\n    }\n    /**\n     * Define if the control is required\n     *\n     * @param value\n     */\n    set isRequired(value) {\n        this._isRequired = value;\n    }\n    get isRequired() {\n        const ctrl = this.ngControl && this.ngControl.control;\n        const requiredFormControl = !!ctrl && hasRequiredControl(ctrl);\n        return this._isRequired || requiredFormControl;\n    }\n    /**\n     * Define the label text\n     *\n     * @param value\n     */\n    set label(value) {\n        this._label = value;\n    }\n    get label() {\n        return this._label;\n    }\n    /**\n     * Placeholder to be shown if no value has been selected\n     *\n     * @param value\n     */\n    set placeholder(value) {\n        this._placeholder = value;\n        this.stateChanges.next();\n    }\n    get placeholder() {\n        return this._placeholder;\n    }\n    /**\n     * Define the tab index for the component\n     *\n     * @param value\n     */\n    set tabIndex(value) {\n        this._tabIndex = coerceNumberProperty(value);\n    }\n    get tabIndex() {\n        return this._tabIndex;\n    }\n    /**\n     * Value of the select control\n     *\n     * @param newValue\n     */\n    set value(newValue) {\n        if (newValue !== this._value) {\n            this._value = newValue;\n        }\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Trigger change detection when the underlying form changes\n     */\n    ngOnInit() {\n        // TODO: re-initialize the selection model if this.allowMultiple changes (rather than throw error like material)\n        this.selectionModel = new SelectionModel(this.allowMultiple);\n        // Seed the control value\n        // NOTE: When the consumer is using an ngModel, the value is not set on the first cycle.\n        // We need to push it to the next event loop. When using a FormControl the value is there on the first run.\n        // istanbul ignore else\n        // eslint-disable-next-line dot-notation\n        if (this.ngControl && this.ngControl['form']) {\n            // Support dynamic form control updates\n            // istanbul ignore else\n            if (this.ngControl.valueChanges) {\n                this.ngControl.valueChanges\n                    .pipe(untilComponentDestroyed(this))\n                    .subscribe(newValue => {\n                    // istanbul ignore else\n                    if (newValue) {\n                        this.setSelectionByValue(newValue);\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * Initialize the key manager and set up change listeners\n     */\n    ngAfterContentInit() {\n        this.initKeyManager();\n        // NOTE: Known bug: This event will come through twice for each selection.\n        // NOTE: Selection model is created during OnInit so it cannot be null here\n        this.selectionModel.changed.pipe(untilComponentDestroyed(this)).subscribe(event => {\n            event.added.forEach(option => {\n                option.select();\n                this.optionSelected.emit(new TsSelectChange(this, option.value));\n            });\n            event.removed.forEach(option => {\n                option.deselect();\n                this.optionDeselected.emit(new TsSelectChange(this, option.value));\n            });\n        });\n        // If the array changes, reset options\n        this.options.changes.pipe(\n        // eslint-disable-next-line deprecation/deprecation\n        startWith(null), untilComponentDestroyed(this)).subscribe(() => {\n            this.resetOptions();\n            this.initializeSelection();\n        });\n    }\n    /**\n     * Trigger updates when the label is dynamically changed\n     *\n     * @param changes\n     */\n    ngOnChanges(changes) {\n        // Let the parent FormField know that it should update the ouline gap for the new label\n        // istanbul ignore else\n        if ((!!(inputHasChanged(changes, 'label')) && !changes.label.firstChange)) {\n            // Trigger change detection first so that the FormField will be working with the latest version\n            this.changeDetectorRef.detectChanges();\n            this.labelChanges.next();\n        }\n    }\n    /**\n     * Cleanup\n     */\n    ngOnDestroy() {\n        this.stateChanges.complete();\n    }\n    /**\n     * Toggles the overlay panel open or closed.\n     */\n    toggle() {\n        // istanbul ignore else\n        if (!this.isDisabled) {\n            this.panelOpen ? this.close() : this.open();\n        }\n    }\n    /**\n     * Open the overlay panel\n     */\n    open() {\n        if (this.isDisabled || !this.options || !this.options.length || this.panelOpen) {\n            return;\n        }\n        this.triggerRect = this.trigger.nativeElement.getBoundingClientRect();\n        // Note: The computed font-size will be a string pixel value (e.g. \"16px\").\n        // `parseInt` ignores the trailing 'px' and converts this to a number.\n        this.triggerFontSize = parseInt(getComputedStyle(this.trigger.nativeElement)['font-size'], 10);\n        this.panelOpen = true;\n        this.keyManager.withHorizontalOrientation(null);\n        this.highlightCorrectOption();\n        this.changeDetectorRef.markForCheck();\n        // Set the font size on the panel element once it exists.\n        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n            // istanbul ignore else\n            if (this.triggerFontSize && this.overlayDir.overlayRef && this.overlayDir.overlayRef.overlayElement) {\n                this.overlayDir.overlayRef.overlayElement.style.fontSize = `${this.triggerFontSize}px`;\n            }\n            this.options.first.elementRef.nativeElement.getBoundingClientRect();\n            this.calculateOverlayPosition();\n        });\n        // Alert the consumer\n        this.opened.emit();\n    }\n    /**\n     * Close the overlay panel\n     */\n    close() {\n        if (this.panelOpen) {\n            this.panelOpen = false;\n            this.keyManager.withHorizontalOrientation('ltr');\n            this.changeDetectorRef.markForCheck();\n            this.onTouched();\n            this.updateValueAndValidity();\n            // Alert the consumer\n            this.closed.emit();\n        }\n    }\n    /**\n     * Callback that is invoked when the overlay panel has been attached\n     */\n    onAttached() {\n        this.overlayDir.positionChange.pipe(take(1)).subscribe(() => {\n            this.changeDetectorRef.detectChanges();\n            this.setPanelScrollTop(this.scrollTop);\n        });\n    }\n    /**\n     * Handles all keydown events on the select\n     *\n     * @param event - The KeyboardEvent\n     */\n    handleKeydown(event) {\n        if (this.isDisabled) {\n            return;\n        }\n        this.panelOpen ? this.handleOpenKeydown(event) : this.handleClosedKeydown(event);\n    }\n    /**\n     * Handle keyboard events when the select panel is closed\n     *\n     * @param event - The KeyboardEvent\n     */\n    handleClosedKeydown(event) {\n        const keyCode = event.code;\n        const arrowKeys = [KEYS.DOWN_ARROW.code, KEYS.UP_ARROW.code, KEYS.LEFT_ARROW.code, KEYS.RIGHT_ARROW.code];\n        const isArrowKey = arrowKeys.indexOf(keyCode) >= 0;\n        const isOpenKey = keyCode === KEYS.ENTER.code || keyCode === KEYS.SPACE.code;\n        // Open the select on ALT + arrow key to match the native <select>\n        if (isOpenKey || ((this.allowMultiple || event.altKey) && isArrowKey)) {\n            // Prevent the page from scrolling down when space is pressed\n            event.preventDefault();\n            this.open();\n        }\n        else if (!this.allowMultiple) {\n            this.keyManager.onKeydown(event);\n        }\n    }\n    /**\n     * Handle keyboard events when the select panel is open\n     *\n     * @param event - The KeyboardEvent\n     */\n    // eslint-disable-next-line complexity\n    handleOpenKeydown(event) {\n        const keyCode = event.code;\n        const isArrowKey = keyCode === KEYS.DOWN_ARROW.code || keyCode === KEYS.UP_ARROW.code;\n        const manager = this.keyManager;\n        const target = event.target;\n        const isFilter = this.isFilterable && target.tagName.toLowerCase() === 'input';\n        if (keyCode === KEYS.HOME.code || keyCode === KEYS.END.code) {\n            // Focus the first/last item with HOME/END respectively\n            event.preventDefault();\n            keyCode === KEYS.HOME.code ? manager.setFirstItemActive() : manager.setLastItemActive();\n        }\n        else if (isArrowKey && event.altKey) {\n            // Close the select on ALT+ARROW to match the native <select>\n            event.preventDefault();\n            this.close();\n        }\n        else if ((keyCode === KEYS.ENTER.code || (keyCode === KEYS.SPACE.code && !isFilter)) && manager.activeItem) {\n            // Select the active item with SPACE or ENTER\n            event.preventDefault();\n            manager.activeItem.selectViaInteraction();\n        }\n        else if (this.allowMultiple && keyCode === KEYS.A.code && event.ctrlKey) {\n            // Select all with CTRL+A\n            event.preventDefault();\n            const hasDeselectedOptions = this.options.some(opt => !opt.isDisabled && !opt.selected);\n            this.options.forEach(option => {\n                // istanbul ignore else\n                if (!option.isDisabled) {\n                    hasDeselectedOptions ? option.select() : option.deselect();\n                }\n            });\n        }\n        else {\n            const shouldSelect = this.allowMultiple && isArrowKey && event.shiftKey;\n            if (isArrowKey && event.shiftKey) {\n                if (keyCode === KEYS.DOWN_ARROW.code) {\n                    manager.setNextItemActive();\n                }\n                else {\n                    manager.setPreviousItemActive();\n                }\n            }\n            else {\n                manager.onKeydown(event);\n            }\n            if (shouldSelect && manager.activeItem) {\n                manager.activeItem.selectViaInteraction();\n            }\n        }\n    }\n    /**\n     * Drops current option subscriptions and IDs and resets from scratch\n     */\n    resetOptions() {\n        this.optionSelectionChanges.pipe(takeUntil(this.options.changes), untilComponentDestroyed(this)).subscribe(event => {\n            this.onSelect(event.source, event.isUserInput);\n            // istanbul ignore else\n            if (event.isUserInput && !this.allowMultiple && this.panelOpen) {\n                this.close();\n                this.focus();\n            }\n        });\n        // Listen to changes in the internal state of the options and react accordingly.\n        // Handles cases like the labels of the selected options changing.\n        // eslint-disable-next-line deprecation/deprecation\n        merge(...this.options.map(option => option.stateChanges))\n            .pipe(untilComponentDestroyed(this))\n            .subscribe(() => {\n            this.changeDetectorRef.markForCheck();\n            this.stateChanges.next();\n        });\n        this.setOptionIds();\n    }\n    /**\n     * Handle the selection when an option is clicked\n     *\n     * @param option - The selected option\n     * @param isUserInput - Whether this selection happened from a user's click\n     */\n    onSelect(option, isUserInput) {\n        const wasSelected = this.selectionModel.isSelected(option);\n        // If not in multiple selection mode, clear any existing selection first\n        if (option.value == null && !this.allowMultiple) {\n            option.deselect();\n            this.selectionModel.clear();\n            this.propagateChanges(option.value);\n        }\n        else {\n            option.selected ? this.selectionModel.select(option) : this.selectionModel.deselect(option);\n            // istanbul ignore else\n            if (isUserInput) {\n                this.keyManager.setActiveItem(option);\n            }\n            // istanbul ignore else\n            if (this.allowMultiple) {\n                this.sortValues();\n                if (isUserInput) {\n                    // In case the user selected the option with their mouse, we\n                    // want to restore focus back to the trigger, in order to\n                    // prevent the select keyboard controls from clashing with\n                    // the ones from `TsOptionComponent`.\n                    this.focus();\n                }\n            }\n        }\n        // Only propagate if the selected option is not already in the selectionModel\n        if (wasSelected !== this.selectionModel.isSelected(option)) {\n            this.propagateChanges();\n        }\n        this.stateChanges.next();\n    }\n    /**\n     * Records option IDs to pass to the aria-owns property\n     */\n    setOptionIds() {\n        this.optionIds = this.options.map(option => option.id).join(' ');\n    }\n    /**\n     * Set up a key manager to listen to keyboard events on the overlay panel\n     */\n    initKeyManager() {\n        this.keyManager = new ActiveDescendantKeyManager(this.options)\n            .withTypeAhead()\n            .withVerticalOrientation()\n            .withHorizontalOrientation('ltr');\n        this.keyManager.tabOut.pipe(untilComponentDestroyed(this)).subscribe(() => {\n            // Restore focus to the trigger before closing. Ensures that the focus\n            // position won't be lost if the user got focus into the overlay.\n            this.focus();\n            this.close();\n        });\n        this.keyManager.change.pipe(untilComponentDestroyed(this)).subscribe(() => {\n            if (this.panelOpen && this.panel) {\n                this.scrollActiveOptionIntoView();\n            }\n            else if (!this.panelOpen && !this.allowMultiple && this.keyManager.activeItem) {\n                this.keyManager.activeItem.selectViaInteraction();\n            }\n        });\n    }\n    /**\n     * Focus the correct element\n     *\n     * When in standard select mode we should focus the select itself.\n     */\n    focus() {\n        this.elementRef.nativeElement.focus();\n    }\n    /**\n     * Sort the selected values in the selectedModel based on their order in the panel\n     */\n    sortValues() {\n        // istanbul ignore else\n        if (this.allowMultiple) {\n            const options = this.options.toArray();\n            this.selectionModel\n                .sort((a, b) => {\n                if (this.sortComparator) {\n                    return this.sortComparator(a, b, options);\n                }\n                return options.indexOf(a) - options.indexOf(b);\n            });\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Emit a change event to set the model value\n     *\n     * @param fallbackValue - A fallback value to use when no selection exists\n     */\n    propagateChanges(fallbackValue) {\n        let valueToEmit;\n        if (this.allowMultiple) {\n            valueToEmit = this.selected.map(option => option.value);\n        }\n        else {\n            valueToEmit = this.selected ? this.selected.value : fallbackValue;\n        }\n        this.value = valueToEmit;\n        this.valueChange.emit(valueToEmit);\n        this.onChange(valueToEmit);\n        this.selectionChange.emit(new TsSelectChange(this, valueToEmit));\n        this.changeDetectorRef.markForCheck();\n    }\n    /**\n     * Call FormControl updateValueAndValidity function to ensure value and valid status get updated.\n     */\n    updateValueAndValidity() {\n        if (this.ngControl && this.ngControl.control) {\n            this.ngControl.control.updateValueAndValidity();\n        }\n    }\n    /**\n     * Sets the select's value. Part of the ControlValueAccessor interface required to integrate with Angular's core forms API.\n     *\n     * NOTE: Currently we are not using this, but it still must be present since this component is acting as a CVA.\n     *\n     * @param value - New value to be written to the model\n     */\n    writeValue(value) { }\n    /**\n     * Save a callback function to be invoked when the select's value changes from user input.\n     * Part of the ControlValueAccessor interface required to integrate with Angular's core forms API.\n     *\n     * @param fn - Callback to be triggered when the value changes\n     */\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    /**\n     * Save a callback function to be invoked when the select is blurred by the user.\n     * Part of the ControlValueAccessor interface required to integrate with Angular's core forms API.\n     *\n     * @param fn - Callback to be triggered when the component has been touched\n     */\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    /**\n     * Disables the select.\n     * Part of the ControlValueAccessor interface required to integrate with Angular's core forms API.\n     *\n     * @param isDisabled - If the component is disabled\n     */\n    setDisabledState(isDisabled) {\n        this.isDisabled = isDisabled;\n        this.changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n    }\n    /**\n     * Initialize any existing selections into the selectionModel\n     */\n    initializeSelection() {\n        // Defer setting the value in order to avoid the \"Expression\n        // has changed after it was checked\" errors from Angular.\n        Promise.resolve().then(() => {\n            this.setSelectionByValue(this.ngControl ? this.ngControl.value : this.value);\n        });\n    }\n    /**\n     * Sets the selected option based on a value.\n     * If no option can be found with the designated value, the select trigger is cleared.\n     *\n     * @param value - The value to use to look up options\n     */\n    setSelectionByValue(value) {\n        if (this.allowMultiple && value) {\n            value = coerceArray(value);\n            this.selectionModel.clear();\n            value.forEach((currentValue) => this.selectOptionByValue(currentValue));\n            this.sortValues();\n        }\n        else {\n            this.selectionModel.clear();\n            const correspondingOption = this.selectOptionByValue(value);\n            // Shift focus to the active item. Note that we shouldn't do this in multiple\n            // mode, because we don't know what option the user interacted with last.\n            if (correspondingOption) {\n                this.keyManager.setActiveItem(correspondingOption);\n            }\n        }\n        this.changeDetectorRef.markForCheck();\n    }\n    /**\n     * Find and select an option based on its value\n     *\n     * @param value - The value to use when searching for a matching option\n     * @returns Option that has the corresponding value\n     */\n    selectOptionByValue(value) {\n        const correspondingOption = this.options.find((option) => {\n            try {\n                // Treat null as a special reset value.\n                return option.value != null && this.compareWith(option.value, value);\n            }\n            catch (error) {\n                // istanbul ignore else\n                if (isDevMode()) {\n                    // Notify developers of errors in their comparator.\n                    // eslint-disable-next-line no-console\n                    console.warn(error);\n                }\n                return false;\n            }\n        });\n        if (correspondingOption) {\n            this.selectionModel.select(correspondingOption);\n        }\n        return correspondingOption;\n    }\n    /**\n     * Scroll the active option into view\n     */\n    scrollActiveOptionIntoView() {\n        const activeOptionIndex = this.keyManager.activeItemIndex || 0;\n        const labelCount = countGroupLabelsBeforeOption(activeOptionIndex, this.options, this.optionGroups);\n        const total = getOptionScrollPosition(activeOptionIndex + labelCount, this.itemHeight, this.getPanelScrollTop(), SELECT_PANEL_MAX_HEIGHT);\n        this.setPanelScrollTop(total);\n    }\n    /**\n     * Calculate the scroll position and x- and y- offsets of the overlay panel\n     */\n    calculateOverlayPosition() {\n        const itemHeight = this.itemHeight;\n        const items = this.itemCount;\n        const panelHeight = Math.min(items * itemHeight, SELECT_PANEL_MAX_HEIGHT);\n        const scrollContainerHeight = items * itemHeight;\n        // The farthest the panel can be scrolled before it hits the bottom\n        const maxScroll = scrollContainerHeight - panelHeight;\n        // If no value is selected we open the popup to the first item.\n        // NOTE: Since we are checking the `empty` value first, we know that the selection model is not empty\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        let selectedOptionOffset = this.empty ? 0 : this.getOptionIndex(this.selectionModel.selected[0]);\n        // Make sure we take into account optgroups also\n        selectedOptionOffset += countGroupLabelsBeforeOption(selectedOptionOffset, this.options, this.optionGroups);\n        // We must maintain a scroll buffer so the selected option will be scrolled to the\n        // center of the overlay panel rather than the top.\n        // eslint-disable-next-line @typescript-eslint/no-magic-numbers\n        const scrollBuffer = panelHeight / 2;\n        this.scrollTop = this.calculateOverlayScroll(selectedOptionOffset, scrollBuffer, maxScroll);\n        this.offsetY = this.calculateOverlayOffsetY(selectedOptionOffset, scrollBuffer, maxScroll);\n        this.checkOverlayWithinViewport(maxScroll);\n    }\n    /**\n     * Calculate the scroll position of the select's overlay panel\n     *\n     * This attempts to center the selected option in the panel. If the option is too high or too low in the panel to be scrolled to the\n     * center, it clamps the scroll position to the min or max scroll positions respectively.\n     *\n     * @param selectedIndex - The index of the item to scroll to\n     * @param scrollBuffer - The amount to buffer the scroll\n     * @param maxScroll - The maximum amount the panel can scroll\n     */\n    calculateOverlayScroll(selectedIndex, scrollBuffer, maxScroll) {\n        const itemHeight = this.itemHeight;\n        const optionOffsetFromScrollTop = itemHeight * selectedIndex;\n        // eslint-disable-next-line @typescript-eslint/no-magic-numbers\n        const halfOptionHeight = itemHeight / 2;\n        // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the scroll container, then subtracts the scroll\n        // buffer to scroll the option down to the center of the overlay panel. Half the option height must be re-added to the scrollTop so the\n        // option is centered based on its middle, not its top edge.\n        const optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;\n        return Math.min(Math.max(0, optimalScrollPosition), maxScroll);\n    }\n    /**\n     * Calculates the y-offset of the select's overlay panel in relation to the top start corner of the trigger.\n     * It has to be adjusted in order for the selected option to be aligned over the trigger when the panel opens.\n     *\n     * @param selectedIndex - The index of the selected item\n     * @param scrollBuffer - The number of pixels to buffer the scroll by\n     * @param maxScroll - The farthest the panel can scroll\n     * @returns The overlay's Y offset\n     */\n    calculateOverlayOffsetY(selectedIndex, scrollBuffer, maxScroll) {\n        // NOTE: scrollBuffer is half of the panel height - which is really half of SELECT_PANEL_MAX_HEIGHT (when many options exist)\n        // NOTE: maxScroll is the height of all options minus the height of the panel\n        const itemHeight = this.itemHeight;\n        // eslint-disable-next-line @typescript-eslint/no-magic-numbers\n        const optionHeightAdjustment = (itemHeight - (this.triggerRect ? this.triggerRect.height : 0)) / 2;\n        const maxOptionsDisplayed = Math.floor(SELECT_PANEL_MAX_HEIGHT / itemHeight);\n        // scrollbuffer - options\n        let optionOffsetFromPanelTop;\n        if (this.scrollTop === 0) {\n            optionOffsetFromPanelTop = selectedIndex * itemHeight;\n        }\n        else if (this.scrollTop === maxScroll) {\n            const firstDisplayedIndex = this.itemCount - maxOptionsDisplayed;\n            const selectedDisplayIndex = selectedIndex - firstDisplayedIndex;\n            // The first item is partially out of the viewport. Therefore we need to calculate what\n            // portion of it is shown in the viewport and account for it in our offset.\n            const partialItemHeight = itemHeight - (((this.itemCount * itemHeight) - SELECT_PANEL_MAX_HEIGHT) % itemHeight);\n            // Because the panel height is longer than the height of the options alone,\n            // there is always extra padding at the top or bottom of the panel. When\n            // scrolled to the very bottom, this padding is at the top of the panel and\n            // must be added to the offset.\n            optionOffsetFromPanelTop = (selectedDisplayIndex * itemHeight) + partialItemHeight;\n        }\n        else {\n            // If the option was scrolled to the middle of the panel using a scroll buffer,\n            // its offset will be the scroll buffer minus the half height that was added to\n            // center it.\n            // eslint-disable-next-line @typescript-eslint/no-magic-numbers\n            optionOffsetFromPanelTop = scrollBuffer - (itemHeight / 2);\n        }\n        // The final offset is the option's offset from the top, adjusted for the height difference,\n        // multiplied by -1 to ensure that the overlay moves in the correct direction up the page.\n        // The value is rounded to prevent some browsers from blurring the content.\n        return Math.round((optionOffsetFromPanelTop * -1) - optionHeightAdjustment);\n    }\n    /**\n     * Check that the attempted overlay position will fit within the viewport.\n     *\n     * If it will not fit, tries to adjust the scroll position and the associated y-offset so the panel can open fully on-screen.\n     * If it still won't fit, sets the offset back to 0 to allow the fallback position to take over.\n     *\n     * @param maxScroll - The maximum amount to allow the panel to scroll\n     */\n    checkOverlayWithinViewport(maxScroll) {\n        const itemHeight = this.itemHeight;\n        const viewportSize = this.viewportRuler.getViewportSize();\n        // Space between top of trigger and top of viewport\n        const topSpaceAvailable = this.triggerRect ? (this.triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING) : 0;\n        // Viewport height - trigger bottom - viewport padding\n        const bottomSpaceAvailable = viewportSize.height - (this.triggerRect ? this.triggerRect.bottom : 0) - SELECT_PANEL_VIEWPORT_PADDING;\n        const panelHeightTop = Math.abs(this.offsetY);\n        // 256 when maxed out\n        const totalPanelHeight = Math.min(this.itemCount * itemHeight, SELECT_PANEL_MAX_HEIGHT);\n        // total panel - offsetY - trigger height\n        const panelHeightBottom = totalPanelHeight - panelHeightTop - (this.triggerRect ? this.triggerRect.height : 0);\n        if (panelHeightBottom > bottomSpaceAvailable) {\n            this.adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);\n        }\n        else if (panelHeightTop > topSpaceAvailable) {\n            this.adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);\n        }\n        else {\n            this.transformOrigin = this.getOriginBasedOnOption();\n        }\n    }\n    /**\n     * Adjust the overlay panel up to fit in the viewport\n     *\n     * @param panelHeightBottom - The height of the panel bottom\n     * @param bottomSpaceAvailable - The amount of available space at the bottom\n     */\n    adjustPanelUp(panelHeightBottom, bottomSpaceAvailable) {\n        // Browsers ignore fractional scroll offsets, so we need to round.\n        const distanceBelowViewport = Math.round(panelHeightBottom - bottomSpaceAvailable);\n        // Scrolls the panel up by the distance it was extending past the boundary, then\n        // adjusts the offset by that amount to move the panel up into the viewport.\n        this.scrollTop -= distanceBelowViewport;\n        // Don't allow the offset to be set below 0\n        this.offsetY = (this.offsetY - distanceBelowViewport) < 0 ? 0 : this.offsetY - distanceBelowViewport;\n        this.transformOrigin = this.getOriginBasedOnOption();\n        // If the panel is scrolled to the very top, it won't be able to fit the panel\n        // by scrolling, so set the offset to 0 to allow the fallback position to take effect.\n        // istanbul ignore else\n        if (this.scrollTop <= 0) {\n            this.scrollTop = 0;\n            this.offsetY = 0;\n            this.transformOrigin = `50% bottom 0px`;\n        }\n    }\n    /**\n     * Adjusts the overlay panel down to fit in the viewport\n     *\n     * @param panelHeightTop - The height of the panel top\n     * @param topSpaceAvailable - The amount of available space at the top\n     * @param maxScroll - The maximum amount the panel can be scrolled\n     */\n    adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll) {\n        // Browsers ignore fractional scroll offsets, so we need to round.\n        const distanceAboveViewport = Math.round(panelHeightTop - topSpaceAvailable);\n        // Scrolls the panel down by the distance it was extending past the boundary, then\n        // adjusts the offset by that amount to move the panel down into the viewport.\n        this.scrollTop += distanceAboveViewport;\n        // Don't allow the offset to be set below 0\n        this.offsetY = (this.offsetY + distanceAboveViewport) < 0 ? 0 : this.offsetY + distanceAboveViewport;\n        this.transformOrigin = this.getOriginBasedOnOption();\n        // If the panel is scrolled to the very bottom, it won't be able to fit the\n        // panel by scrolling, so set the offset to 0 to allow the fallback position\n        // to take effect.\n        // istanbul ignore else\n        if (this.scrollTop >= maxScroll) {\n            this.scrollTop = maxScroll;\n            this.offsetY = 0;\n            this.transformOrigin = `50% top 0px`;\n            return;\n        }\n    }\n    /**\n     * Set the transform origin point based on the selected option\n     *\n     * @returns The transform origin CSS string\n     */\n    getOriginBasedOnOption() {\n        const itemHeight = this.itemHeight;\n        /* eslint-disable @typescript-eslint/no-magic-numbers */\n        const optionHeightAdjustment = (itemHeight - (this.triggerRect ? this.triggerRect.height : 0)) / 2;\n        const originY = Math.abs(this.offsetY) - optionHeightAdjustment + (itemHeight / 2);\n        /* eslint-enable @typescript-eslint/no-magic-numbers */\n        return `50% ${originY}px 0px`;\n    }\n    /**\n     * Get the index of the provided option in the option list\n     *\n     * @param option - The option whose index should be found\n     * @returns The index of the option\n     */\n    getOptionIndex(option) {\n        return this.options.reduce((result, current, index) => {\n            // eslint-disable-next-line no-undefined\n            const optionIndexIfCurrent = option === current ? index : undefined;\n            return isUndefined(result) ? optionIndexIfCurrent : result;\n            // eslint-disable-next-line no-undefined\n        }, undefined);\n    }\n    /**\n     * Highlight the selected item.\n     *\n     * If no option is selected, it will highlight the first item instead.\n     */\n    highlightCorrectOption() {\n        // istanbul ignore else\n        if (this.keyManager) {\n            if (this.empty) {\n                this.keyManager.setFirstItemActive();\n            }\n            else {\n                this.keyManager.setActiveItem(this.selectionModel.selected[0]);\n            }\n        }\n    }\n    /**\n     * Toggle the selection all options\n     *\n     * If any are selected, it will unselect all & vice-versa.\n     */\n    toggleAllOptions() {\n        toggleAllOptions(this.options);\n    }\n    /**\n     * Ensure the correct element gets focus when the primary container is clicked.\n     *\n     * Implemented as part of TsFormFieldControl.\n     */\n    onContainerClick() {\n        this.focus();\n        // istanbul ignore else\n        if (!this.isDisabled) {\n            this.open();\n        }\n    }\n    /**\n     * Get the panel's scrollTop\n     *\n     * @returns The scrollTop number\n     */\n    getPanelScrollTop() {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n    /**\n     * Set the panel's scrollTop\n     *\n     * This allows us to manually scroll to display options above or below the fold, as they are not actually being focused when active.\n     *\n     *\n     * @param scrollTop - The number to set scrollTop to\n     */\n    setPanelScrollTop(scrollTop) {\n        // istanbul ignore else\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n};\nTsSelectComponent.ctorParameters = () => [\n    { type: ViewportRuler },\n    { type: ChangeDetectorRef },\n    { type: NgZone },\n    { type: TsDocumentService },\n    { type: ElementRef },\n    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] }\n];\n__decorate([\n    ContentChild(TsSelectTriggerComponent),\n    __metadata(\"design:type\", TsSelectTriggerComponent)\n], TsSelectComponent.prototype, \"customTrigger\", void 0);\n__decorate([\n    ViewChild('input'),\n    __metadata(\"design:type\", ElementRef)\n], TsSelectComponent.prototype, \"inputElement\", void 0);\n__decorate([\n    ViewChild('labelElement'),\n    __metadata(\"design:type\", ElementRef)\n], TsSelectComponent.prototype, \"labelElement\", void 0);\n__decorate([\n    ViewChild('trigger'),\n    __metadata(\"design:type\", ElementRef)\n], TsSelectComponent.prototype, \"trigger\", void 0);\n__decorate([\n    ViewChild(CdkConnectedOverlay),\n    __metadata(\"design:type\", CdkConnectedOverlay)\n], TsSelectComponent.prototype, \"overlayDir\", void 0);\n__decorate([\n    ViewChild('panel'),\n    __metadata(\"design:type\", ElementRef)\n], TsSelectComponent.prototype, \"panel\", void 0);\n__decorate([\n    ContentChildren(TsOptionComponent, { descendants: true }),\n    __metadata(\"design:type\", QueryList)\n], TsSelectComponent.prototype, \"options\", void 0);\n__decorate([\n    ContentChildren(TsOptgroupComponent),\n    __metadata(\"design:type\", QueryList)\n], TsSelectComponent.prototype, \"optionGroups\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsSelectComponent.prototype, \"allowMultiple\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Function])\n], TsSelectComponent.prototype, \"compareWith\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsSelectComponent.prototype, \"delimiter\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsSelectComponent.prototype, \"hideRequiredMarker\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsSelectComponent.prototype, \"hint\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsSelectComponent.prototype, \"id\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsSelectComponent.prototype, \"isDisabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsSelectComponent.prototype, \"isFilterable\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [Boolean])\n], TsSelectComponent.prototype, \"isRequired\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsSelectComponent.prototype, \"label\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsSelectComponent.prototype, \"noValidationOrHint\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsSelectComponent.prototype, \"placeholder\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsSelectComponent.prototype, \"showProgress\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsSelectComponent.prototype, \"showRefineSearchMessage\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsSelectComponent.prototype, \"showRefresh\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Function)\n], TsSelectComponent.prototype, \"sortComparator\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object),\n    __metadata(\"design:paramtypes\", [Object])\n], TsSelectComponent.prototype, \"tabIndex\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsSelectComponent.prototype, \"theme\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], TsSelectComponent.prototype, \"totalHiddenResults\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsSelectComponent.prototype, \"validateOnChange\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object),\n    __metadata(\"design:paramtypes\", [Object])\n], TsSelectComponent.prototype, \"value\", null);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsSelectComponent.prototype, \"closed\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsSelectComponent.prototype, \"duplicateSelection\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsSelectComponent.prototype, \"opened\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsSelectComponent.prototype, \"optionDeselected\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsSelectComponent.prototype, \"optionSelected\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsSelectComponent.prototype, \"optionsRefreshRequested\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsSelectComponent.prototype, \"queryChange\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsSelectComponent.prototype, \"selectionChange\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsSelectComponent.prototype, \"valueChange\", void 0);\nTsSelectComponent = TsSelectComponent_1 = __decorate([\n    Component({\n        selector: 'ts-select',\n        template: \"<ts-form-field\\n  [validateOnChange]=\\\"validateOnChange\\\"\\n  [control]=\\\"selfReference\\\"\\n  [hideRequiredMarker]=\\\"hideRequiredMarker\\\"\\n  [hint]=\\\"hint\\\"\\n  [id]=\\\"id\\\"\\n  [noValidationOrHint]=\\\"noValidationOrHint\\\"\\n  [theme]=\\\"theme\\\"\\n  cdk-overlay-origin\\n  #origin=\\\"cdkOverlayOrigin\\\"\\n>\\n  <ts-label *ngIf=\\\"label\\\">\\n    {{ label }}\\n  </ts-label>\\n\\n  <!--\\n     -SELECT TRIGGER\\n     -->\\n    <div\\n      class=\\\"ts-select-trigger qa-select-trigger\\\"\\n      [attr.id]=\\\"id\\\"\\n      [attr.tabindex]=\\\"tabIndex\\\"\\n      aria-hidden=\\\"true\\\"\\n      (click)=\\\"toggle()\\\"\\n      #trigger\\n    >\\n      <div class=\\\"ts-select-value\\\" [ngSwitch]=\\\"empty\\\">\\n        <span\\n          class=\\\"ts-select-placeholder\\\"\\n          *ngSwitchCase=\\\"true\\\"\\n        >\\n          {{ placeholder || '\\\\u00A0' }}\\n        </span>\\n\\n        <span class=\\\"ts-select-value-text qa-select-value-text\\\" *ngSwitchCase=\\\"false\\\" [ngSwitch]=\\\"!!customTrigger\\\">\\n          <span *ngSwitchDefault [attr.title]=\\\"selectTriggerValue\\\">\\n            {{ selectTriggerValue || '\\\\u00A0' }}\\n          </span>\\n\\n          <ng-content select=\\\"ts-select-trigger\\\" *ngSwitchCase=\\\"true\\\"></ng-content>\\n        </span>\\n      </div>\\n\\n      <div class=\\\"ts-select-arrow-wrapper qa-select-arrow-wrapper\\\">\\n        <div class=\\\"ts-select-arrow\\\"></div>\\n      </div>\\n    </div>\\n</ts-form-field>\\n\\n\\n<!--\\n   -SELECT PANEL\\n   -->\\n<ng-template\\n  cdk-connected-overlay\\n  cdkConnectedOverlayLockPosition\\n  cdkConnectedOverlayHasBackdrop\\n  cdkConnectedOverlayBackdropClass=\\\"cdk-overlay-transparent-backdrop\\\"\\n  [cdkConnectedOverlayViewportMargin]=\\\"viewportMarginSpacing\\\"\\n  [cdkConnectedOverlayOrigin]=\\\"origin\\\"\\n  [cdkConnectedOverlayOpen]=\\\"panelOpen\\\"\\n  [cdkConnectedOverlayPositions]=\\\"positions\\\"\\n  [cdkConnectedOverlayMinWidth]=\\\"triggerRect?.width\\\"\\n  [cdkConnectedOverlayWidth]=\\\"triggerRect?.width\\\"\\n  (backdropClick)=\\\"close()\\\"\\n  (attach)=\\\"onAttached()\\\"\\n  (detach)=\\\"close()\\\"\\n>\\n\\n  <div\\n    #panel\\n    class=\\\"ts-select-panel ts-{{ theme }} qa-select-panel\\\"\\n    [class.ts-select-panel--multiple]=\\\"allowMultiple\\\"\\n    [class.ts-select-panel--filter]=\\\"isFilterable\\\"\\n    [@transformPanel]=\\\"allowMultiple ? 'showing-multiple' : 'showing'\\\"\\n    (@transformPanel.done)=\\\"panelDoneAnimatingStream.next($event.toState)\\\"\\n    [style.transformOrigin]=\\\"transformOrigin\\\"\\n    [style.font-size.px]=\\\"triggerFontSize\\\"\\n    (keydown)=\\\"handleKeydown($event)\\\"\\n  >\\n    <div class=\\\"ts-select-panel__filter-input\\\" *ngIf=\\\"isFilterable\\\">\\n      <ts-input\\n        label=\\\"Begin typing to filter...\\\"\\n        [ngModel]=\\\"searchQuery\\\"\\n        (ngModelChange)=\\\"queryChange.emit($event)\\\"\\n      ></ts-input>\\n    </div>\\n\\n    <div\\n      class=\\\"ts-select-panel__toggle-all qa-select-toggle-all\\\"\\n      (click)=\\\"toggleAllOptions()\\\"\\n      *ngIf=\\\"allowMultiple\\\"\\n    >\\n      <ts-checkbox\\n        [isChecked]=\\\"allOptionsSelected\\\"\\n        [isIndeterminate]=\\\"someOptionsSelected\\\"\\n        theme=\\\"accent\\\"\\n      >\\n        {{ someOptionsSelected ? 'Deselect' : 'Select' }} All\\n\\n        <span\\n          class=\\\"ts-select-panel__count qa-select-selected-count\\\"\\n          *ngIf=\\\"selectionModel?.selected.length\\\"\\n        >\\n          {{ selectionModel?.selected.length }} selected\\n        </span>\\n      </ts-checkbox>\\n    </div>\\n\\n    <!-- Outlet for options passed in by consumer -->\\n    <ng-template *ngTemplateOutlet=\\\"contentTemplate\\\"></ng-template>\\n\\n    <div\\n      class=\\\"ts-select-panel__refresh\\\"\\n      *ngIf=\\\"showRefresh\\\"\\n      (click)=\\\"optionsRefreshRequested.emit()\\\"\\n    >\\n      <ts-icon>refresh</ts-icon>\\n      <span>\\n        Refresh &amp; reload to bring in new choices.\\n      </span>\\n    </div>\\n\\n    <div\\n      class=\\\"ts-select-panel__refine\\\"\\n      *ngIf=\\\"showRefineSearchMessage\\\"\\n    >\\n      Narrow your search to reveal {{ totalHiddenResults ? totalHiddenResults + ' ' : '' }}hidden results.\\n    </div>\\n  </div>\\n</ng-template>\\n\\n\\n<ng-template #contentTemplate>\\n  <ng-content></ng-content>\\n</ng-template>\\n\",\n        host: {\n            'class': 'ts-select',\n            '[class.ts-select--required]': 'isRequired',\n            '[class.ts-select--disabled]': 'isDisabled',\n            '[attr.aria-owns]': 'panelOpen ? optionIds : null',\n            '[attr.aria-required]': 'isRequired.toString()',\n            '[attr.aria-multiselectable]': 'allowMultiple',\n            '[attr.tabindex]': 'tabIndex',\n            '(keydown)': 'handleKeydown($event)',\n        },\n        animations: [\n            tsSelectAnimations.transformPanel,\n        ],\n        providers: [\n            {\n                provide: TsFormFieldControl,\n                // eslint-disable-next-line deprecation/deprecation\n                useExisting: TsSelectComponent_1,\n            },\n            {\n                provide: TS_OPTION_PARENT_COMPONENT,\n                // eslint-disable-next-line deprecation/deprecation\n                useExisting: TsSelectComponent_1,\n            },\n            // Since we handle all option selection/deselection functionality we tell the underlying MatCheckbox to do nothing on click.\n            {\n                provide: MAT_CHECKBOX_DEFAULT_OPTIONS,\n                useValue: ɵ0,\n            },\n        ],\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        encapsulation: ViewEncapsulation.None,\n        exportAs: 'tsSelect',\n        styles: [\":root{--swift-ease-out-duration:var(--ts-animation-time-duration-400);--swift-ease-out-timing-function:cubic-bezier(.25, .8, .25, 1);--swift-ease-in-duration:var(--ts-animation-time-duration-300);--swift-ease-in-timing-function:cubic-bezier(.55, 0, .55, .2)}.cdk-drag{position:relative}.cdk-drag:not(.cdk-drag-placeholder){transition:transform 250ms cubic-bezier(0,0,.2,1)}.cdk-drag .cdk-drag-handle{color:#cecdd1;cursor:ns-resize;position:absolute;right:8px}.cdk-drag.cdk-drag-preview{--shadow:0 5px 5px -3px rgba(0, 0, 0, .2),0 8px 10px 1px rgba(0, 0, 0, .14),0 3px 14px 2px rgba(0, 0, 0, .12);background-color:#fafafa;box-shadow:var(--shadow);min-height:50px;padding:0!important}.cdk-drag.cdk-drag-preview .c-checkbox{margin-left:16px}.cdk-drag-placeholder{--drop-bg:#cce8d5;--drop-border:#7fd09c;background:var(--drop-bg);border:2px dotted var(--drop-border);cursor:ns-resize;transition:transform 250ms cubic-bezier(0,0,.2,1)}.u-visually-hidden{border:0;-webkit-clip-path:rect(0,0,0,0);clip-path:rect(0,0,0,0);display:block;height:1px;margin:-1px;overflow:hidden;padding:0;pointer-events:none;position:absolute;visibility:hidden;width:1px}.ts-select{display:block;outline:0}.ts-select :not(.mat-form-field-label-wrapper){box-sizing:border-box}.ts-select h1,.ts-select h2,.ts-select h3,.ts-select h4,.ts-select h5,.ts-select p{margin:unset}.ts-select .ts-form-field.ts-form-field--float .ts-select-arrow-wrapper,.ts-select .ts-form-field:not(.ts-form-field--float) .ts-select-arrow-wrapper{display:table-cell;transform:translateY(-10%);vertical-align:middle}.ts-select .ts-select-trigger{box-sizing:border-box;cursor:pointer;display:inline-table;position:relative}.ts-select .ts-select-trigger--hidden{border:0;-webkit-clip-path:rect(0,0,0,0);clip-path:rect(0,0,0,0);display:block;height:1px;margin:-1px;overflow:hidden;padding:0;pointer-events:none;position:absolute;visibility:hidden;width:1px}.ts-option--disabled .ts-select .ts-select-trigger,.ts-select.ts-select--disabled .ts-select-trigger{cursor:not-allowed;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ts-select.ts-select--disabled .ts-select-arrow{color:#999}.ts-select .ts-select-value{display:table-cell;max-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%}.ts-select .ts-select-value-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ts-select .ts-select-arrow{border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;height:0;margin:0 4px;width:0}.cdk-overlay-pane .ts-select-panel__filter-input{background-color:#fafafa;border-bottom:1px solid #cecdd1;left:0;padding:8px;position:absolute;right:-24px;top:0;width:calc(100% - 16px);z-index:501}.cdk-overlay-pane .ts-select-panel__filter-input .ts-form-field .ts-form-field__wrapper{padding-bottom:0}.ts-select-panel{max-height:256px;overflow:auto}.ts-select-panel.ts-select-panel--filter{padding-top:85px}.ts-select-panel .ts-optgroup .ts-option .ts-checkbox{padding-left:16px}.ts-select-panel .ts-select-panel__toggle-all{background-color:#f2f0f7;border-bottom:1px solid #999;position:relative}.ts-select-panel .ts-select-panel__toggle-all .ts-checkbox{line-height:3em}.ts-select-panel .ts-select-panel__count{font-family:Roboto,Helvetica Neue,Helvetica,Arial,sans-serif;font-size:12px;letter-spacing:.02em;color:#999;position:absolute;right:12px}.ts-select-panel .ts-select-panel__refresh{letter-spacing:.01em;font-weight:500;font-family:Roboto,Helvetica Neue,Helvetica,Arial,sans-serif;font-size:12px;letter-spacing:.02em;background-color:#f2f0f7;color:#757575;cursor:pointer;height:48px;line-height:48px;padding:0 16px;transition:color .2s}.ts-select-panel .ts-select-panel__refresh .ts-icon{height:24px;vertical-align:text-bottom}.ts-select-panel .ts-select-panel__refresh:focus,.ts-select-panel .ts-select-panel__refresh:hover{color:#00538a}.ts-select-panel .ts-select-panel__refine{font-family:Roboto,Helvetica Neue,Helvetica,Arial,sans-serif;font-size:12px;letter-spacing:.02em;color:#999;font-style:italic;padding:12px 16px}.ts-paginator .ts-select{display:inline-block;position:relative;width:5em}.ts-paginator .ts-select.ts-select--disabled .ts-select-arrow-wrapper{transform:translateY(0)}\"]\n    }),\n    __param(5, Self()), __param(5, Optional()),\n    __metadata(\"design:paramtypes\", [ViewportRuler,\n        ChangeDetectorRef,\n        NgZone,\n        TsDocumentService,\n        ElementRef,\n        NgControl])\n], TsSelectComponent);\n\n// @deprecated Please use `TsSelectionListModule`\nlet TsSelectModule = class TsSelectModule {\n};\nTsSelectModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            FlexLayoutModule,\n            FormsModule,\n            MatChipsModule,\n            MatProgressSpinnerModule,\n            MatRippleModule,\n            OverlayModule,\n            ReactiveFormsModule,\n            TsCheckboxModule,\n            TsFormFieldModule,\n            TsIconModule,\n            TsInputModule,\n            TsOptionModule,\n            TsValidationMessagesModule,\n        ],\n        exports: [\n            TsSelectComponent,\n            TsSelectTriggerComponent,\n        ],\n        declarations: [\n            TsSelectComponent,\n            TsSelectTriggerComponent,\n        ],\n    })\n], TsSelectModule);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_COMPARE_WITH, SELECT_ITEM_HEIGHT_EM, SELECT_MULTIPLE_PANEL_PADDING_X, SELECT_PANEL_INDENT_PADDING_X, SELECT_PANEL_MAX_HEIGHT, SELECT_PANEL_PADDING_X, SELECT_PANEL_VIEWPORT_PADDING, TS_SELECT_PANEL_VIEWPORT_PADDING, TsSelectChange, TsSelectComponent, TsSelectModule, TsSelectTriggerComponent, tsSelectAnimations, ɵ0 };\n//# sourceMappingURL=terminus-ui-select.js.map\n","import { SPACE, BACKSPACE, DELETE, HOME, END, TAB, hasModifierKey, ENTER } from '@angular/cdk/keycodes';\nimport { Directive, EventEmitter, ElementRef, NgZone, Optional, Inject, ChangeDetectorRef, Attribute, ContentChild, forwardRef, Input, Output, InjectionToken, Component, ViewEncapsulation, ChangeDetectionStrategy, Self, ContentChildren, NgModule } from '@angular/core';\nimport { mixinTabIndex, mixinColor, mixinDisableRipple, mixinDisabled, RippleRenderer, MAT_RIPPLE_GLOBAL_OPTIONS, mixinErrorState, ErrorStateMatcher } from '@angular/material/core';\nimport { DOCUMENT } from '@angular/common';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { Subject, merge } from 'rxjs';\nimport { take, takeUntil, startWith } from 'rxjs/operators';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { NgForm, FormGroupDirective, NgControl } from '@angular/forms';\nimport { MatFormFieldControl } from '@angular/material/form-field';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/chips/chip.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Represents an event fired on an individual `mat-chip`.\n * @record\n */\nfunction MatChipEvent() { }\nif (false) {\n    /**\n     * The chip the event was fired on.\n     * @type {?}\n     */\n    MatChipEvent.prototype.chip;\n}\n/**\n * Event object emitted by MatChip when selected or deselected.\n */\nclass MatChipSelectionChange {\n    /**\n     * @param {?} source\n     * @param {?} selected\n     * @param {?=} isUserInput\n     */\n    constructor(source, selected, isUserInput = false) {\n        this.source = source;\n        this.selected = selected;\n        this.isUserInput = isUserInput;\n    }\n}\nif (false) {\n    /**\n     * Reference to the chip that emitted the event.\n     * @type {?}\n     */\n    MatChipSelectionChange.prototype.source;\n    /**\n     * Whether the chip that emitted the event is selected.\n     * @type {?}\n     */\n    MatChipSelectionChange.prototype.selected;\n    /**\n     * Whether the selection change was a result of a user interaction.\n     * @type {?}\n     */\n    MatChipSelectionChange.prototype.isUserInput;\n}\n// Boilerplate for applying mixins to MatChip.\n/**\n * \\@docs-private\n */\nclass MatChipBase {\n    /**\n     * @param {?} _elementRef\n     */\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nif (false) {\n    /** @type {?} */\n    MatChipBase.prototype._elementRef;\n}\n/** @type {?} */\nconst _MatChipMixinBase = mixinTabIndex(mixinColor(mixinDisableRipple(mixinDisabled(MatChipBase)), 'primary'), -1);\n/**\n * Dummy directive to add CSS class to chip avatar.\n * \\@docs-private\n */\nclass MatChipAvatar {\n}\nMatChipAvatar.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-chip-avatar, [matChipAvatar]',\n                host: { 'class': 'mat-chip-avatar' }\n            },] }\n];\n/**\n * Dummy directive to add CSS class to chip trailing icon.\n * \\@docs-private\n */\nclass MatChipTrailingIcon {\n}\nMatChipTrailingIcon.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',\n                host: { 'class': 'mat-chip-trailing-icon' }\n            },] }\n];\n/**\n * Material design styled Chip component. Used inside the MatChipList component.\n */\nclass MatChip extends _MatChipMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _ngZone\n     * @param {?} platform\n     * @param {?} globalRippleOptions\n     * @param {?=} animationMode\n     * @param {?=} _changeDetectorRef\n     * @param {?=} tabIndex\n     * @param {?=} _document\n     */\n    constructor(_elementRef, _ngZone, platform, globalRippleOptions, \n    // @breaking-change 8.0.0 `animationMode` parameter to become required.\n    animationMode, _changeDetectorRef, tabIndex, \n    // @breaking-change 11.0.0 `_document` parameter to become required.\n    _document) {\n        super(_elementRef);\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._changeDetectorRef = _changeDetectorRef;\n        /**\n         * Whether the chip has focus.\n         */\n        this._hasFocus = false;\n        /**\n         * Whether the chip list is selectable\n         */\n        this.chipListSelectable = true;\n        /**\n         * Whether the chip list is in multi-selection mode.\n         */\n        this._chipListMultiple = false;\n        this._selected = false;\n        this._selectable = true;\n        this._removable = true;\n        /**\n         * Emits when the chip is focused.\n         */\n        this._onFocus = new Subject();\n        /**\n         * Emits when the chip is blured.\n         */\n        this._onBlur = new Subject();\n        /**\n         * Emitted when the chip is selected or deselected.\n         */\n        this.selectionChange = new EventEmitter();\n        /**\n         * Emitted when the chip is destroyed.\n         */\n        this.destroyed = new EventEmitter();\n        /**\n         * Emitted when a chip is to be removed.\n         */\n        this.removed = new EventEmitter();\n        this._addHostClassName();\n        // Dynamically create the ripple target, append it within the chip, and use it as the\n        // chip's ripple target. Adding the class '.mat-chip-ripple' ensures that it will have\n        // the proper styles.\n        this._chipRippleTarget = (_document || document).createElement('div');\n        this._chipRippleTarget.classList.add('mat-chip-ripple');\n        this._elementRef.nativeElement.appendChild(this._chipRippleTarget);\n        this._chipRipple = new RippleRenderer(this, _ngZone, this._chipRippleTarget, platform);\n        this._chipRipple.setupTriggerEvents(_elementRef);\n        this.rippleConfig = globalRippleOptions || {};\n        this._animationsDisabled = animationMode === 'NoopAnimations';\n        this.tabIndex = tabIndex != null ? (parseInt(tabIndex) || -1) : -1;\n    }\n    /**\n     * Whether ripples are disabled on interaction\n     * \\@docs-private\n     * @return {?}\n     */\n    get rippleDisabled() {\n        return this.disabled || this.disableRipple || !!this.rippleConfig.disabled;\n    }\n    /**\n     * Whether the chip is selected.\n     * @return {?}\n     */\n    get selected() { return this._selected; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set selected(value) {\n        /** @type {?} */\n        const coercedValue = coerceBooleanProperty(value);\n        if (coercedValue !== this._selected) {\n            this._selected = coercedValue;\n            this._dispatchSelectionChange();\n        }\n    }\n    /**\n     * The value of the chip. Defaults to the content inside `<mat-chip>` tags.\n     * @return {?}\n     */\n    get value() {\n        return this._value !== undefined\n            ? this._value\n            : this._elementRef.nativeElement.textContent;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set value(value) { this._value = value; }\n    /**\n     * Whether or not the chip is selectable. When a chip is not selectable,\n     * changes to its selected state are always ignored. By default a chip is\n     * selectable, and it becomes non-selectable if its parent chip list is\n     * not selectable.\n     * @return {?}\n     */\n    get selectable() { return this._selectable && this.chipListSelectable; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set selectable(value) {\n        this._selectable = coerceBooleanProperty(value);\n    }\n    /**\n     * Determines whether or not the chip displays the remove styling and emits (removed) events.\n     * @return {?}\n     */\n    get removable() { return this._removable; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set removable(value) {\n        this._removable = coerceBooleanProperty(value);\n    }\n    /**\n     * The ARIA selected applied to the chip.\n     * @return {?}\n     */\n    get ariaSelected() {\n        // Remove the `aria-selected` when the chip is deselected in single-selection mode, because\n        // it adds noise to NVDA users where \"not selected\" will be read out for each chip.\n        return this.selectable && (this._chipListMultiple || this.selected) ?\n            this.selected.toString() : null;\n    }\n    /**\n     * @return {?}\n     */\n    _addHostClassName() {\n        /** @type {?} */\n        const basicChipAttrName = 'mat-basic-chip';\n        /** @type {?} */\n        const element = (/** @type {?} */ (this._elementRef.nativeElement));\n        if (element.hasAttribute(basicChipAttrName) ||\n            element.tagName.toLowerCase() === basicChipAttrName) {\n            element.classList.add(basicChipAttrName);\n            return;\n        }\n        else {\n            element.classList.add('mat-standard-chip');\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.destroyed.emit({ chip: this });\n        this._chipRipple._removeTriggerEvents();\n    }\n    /**\n     * Selects the chip.\n     * @return {?}\n     */\n    select() {\n        if (!this._selected) {\n            this._selected = true;\n            this._dispatchSelectionChange();\n            this._markForCheck();\n        }\n    }\n    /**\n     * Deselects the chip.\n     * @return {?}\n     */\n    deselect() {\n        if (this._selected) {\n            this._selected = false;\n            this._dispatchSelectionChange();\n            this._markForCheck();\n        }\n    }\n    /**\n     * Select this chip and emit selected event\n     * @return {?}\n     */\n    selectViaInteraction() {\n        if (!this._selected) {\n            this._selected = true;\n            this._dispatchSelectionChange(true);\n            this._markForCheck();\n        }\n    }\n    /**\n     * Toggles the current selected state of this chip.\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    toggleSelected(isUserInput = false) {\n        this._selected = !this.selected;\n        this._dispatchSelectionChange(isUserInput);\n        this._markForCheck();\n        return this.selected;\n    }\n    /**\n     * Allows for programmatic focusing of the chip.\n     * @return {?}\n     */\n    focus() {\n        if (!this._hasFocus) {\n            this._elementRef.nativeElement.focus();\n            this._onFocus.next({ chip: this });\n        }\n        this._hasFocus = true;\n    }\n    /**\n     * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n     * @return {?}\n     */\n    remove() {\n        if (this.removable) {\n            this.removed.emit({ chip: this });\n        }\n    }\n    /**\n     * Handles click events on the chip.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleClick(event) {\n        if (this.disabled) {\n            event.preventDefault();\n        }\n        else {\n            event.stopPropagation();\n        }\n    }\n    /**\n     * Handle custom key presses.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        if (this.disabled) {\n            return;\n        }\n        switch (event.keyCode) {\n            case DELETE:\n            case BACKSPACE:\n                // If we are removable, remove the focused chip\n                this.remove();\n                // Always prevent so page navigation does not occur\n                event.preventDefault();\n                break;\n            case SPACE:\n                // If we are selectable, toggle the focused chip\n                if (this.selectable) {\n                    this.toggleSelected(true);\n                }\n                // Always prevent space from scrolling the page since the list has focus\n                event.preventDefault();\n                break;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _blur() {\n        // When animations are enabled, Angular may end up removing the chip from the DOM a little\n        // earlier than usual, causing it to be blurred and throwing off the logic in the chip list\n        // that moves focus not the next item. To work around the issue, we defer marking the chip\n        // as not focused until the next time the zone stabilizes.\n        this._ngZone.onStable\n            .asObservable()\n            .pipe(take(1))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._ngZone.run((/**\n             * @return {?}\n             */\n            () => {\n                this._hasFocus = false;\n                this._onBlur.next({ chip: this });\n            }));\n        }));\n    }\n    /**\n     * @private\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    _dispatchSelectionChange(isUserInput = false) {\n        this.selectionChange.emit({\n            source: this,\n            isUserInput,\n            selected: this._selected\n        });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _markForCheck() {\n        // @breaking-change 9.0.0 Remove this method once the _changeDetectorRef is a required param.\n        if (this._changeDetectorRef) {\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n}\nMatChip.decorators = [\n    { type: Directive, args: [{\n                selector: `mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]`,\n                inputs: ['color', 'disabled', 'disableRipple', 'tabIndex'],\n                exportAs: 'matChip',\n                host: {\n                    'class': 'mat-chip mat-focus-indicator',\n                    '[attr.tabindex]': 'disabled ? null : tabIndex',\n                    'role': 'option',\n                    '[class.mat-chip-selected]': 'selected',\n                    '[class.mat-chip-with-avatar]': 'avatar',\n                    '[class.mat-chip-with-trailing-icon]': 'trailingIcon || removeIcon',\n                    '[class.mat-chip-disabled]': 'disabled',\n                    '[class._mat-animation-noopable]': '_animationsDisabled',\n                    '[attr.disabled]': 'disabled || null',\n                    '[attr.aria-disabled]': 'disabled.toString()',\n                    '[attr.aria-selected]': 'ariaSelected',\n                    '(click)': '_handleClick($event)',\n                    '(keydown)': '_handleKeydown($event)',\n                    '(focus)': 'focus()',\n                    '(blur)': '_blur()',\n                },\n            },] }\n];\n/** @nocollapse */\nMatChip.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone },\n    { type: Platform },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] }] },\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },\n    { type: ChangeDetectorRef },\n    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }\n];\nMatChip.propDecorators = {\n    avatar: [{ type: ContentChild, args: [MatChipAvatar,] }],\n    trailingIcon: [{ type: ContentChild, args: [MatChipTrailingIcon,] }],\n    removeIcon: [{ type: ContentChild, args: [forwardRef((/**\n                 * @return {?}\n                 */\n                () => MatChipRemove)),] }],\n    selected: [{ type: Input }],\n    value: [{ type: Input }],\n    selectable: [{ type: Input }],\n    removable: [{ type: Input }],\n    selectionChange: [{ type: Output }],\n    destroyed: [{ type: Output }],\n    removed: [{ type: Output }]\n};\nif (false) {\n    /** @type {?} */\n    MatChip.ngAcceptInputType_selected;\n    /** @type {?} */\n    MatChip.ngAcceptInputType_selectable;\n    /** @type {?} */\n    MatChip.ngAcceptInputType_removable;\n    /** @type {?} */\n    MatChip.ngAcceptInputType_disabled;\n    /** @type {?} */\n    MatChip.ngAcceptInputType_disableRipple;\n    /**\n     * Reference to the RippleRenderer for the chip.\n     * @type {?}\n     * @private\n     */\n    MatChip.prototype._chipRipple;\n    /**\n     * Reference to the element that acts as the chip's ripple target. This element is\n     * dynamically added as a child node of the chip. The chip itself cannot be used as the\n     * ripple target because it must be the host of the focus indicator.\n     * @type {?}\n     * @private\n     */\n    MatChip.prototype._chipRippleTarget;\n    /**\n     * Ripple configuration for ripples that are launched on pointer down. The ripple config\n     * is set to the global ripple options since we don't have any configurable options for\n     * the chip ripples.\n     * \\@docs-private\n     * @type {?}\n     */\n    MatChip.prototype.rippleConfig;\n    /**\n     * Whether the chip has focus.\n     * @type {?}\n     */\n    MatChip.prototype._hasFocus;\n    /**\n     * Whether animations for the chip are enabled.\n     * @type {?}\n     */\n    MatChip.prototype._animationsDisabled;\n    /**\n     * Whether the chip list is selectable\n     * @type {?}\n     */\n    MatChip.prototype.chipListSelectable;\n    /**\n     * Whether the chip list is in multi-selection mode.\n     * @type {?}\n     */\n    MatChip.prototype._chipListMultiple;\n    /**\n     * The chip avatar\n     * @type {?}\n     */\n    MatChip.prototype.avatar;\n    /**\n     * The chip's trailing icon.\n     * @type {?}\n     */\n    MatChip.prototype.trailingIcon;\n    /**\n     * The chip's remove toggler.\n     * @type {?}\n     */\n    MatChip.prototype.removeIcon;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChip.prototype._selected;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChip.prototype._value;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChip.prototype._selectable;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChip.prototype._removable;\n    /**\n     * Emits when the chip is focused.\n     * @type {?}\n     */\n    MatChip.prototype._onFocus;\n    /**\n     * Emits when the chip is blured.\n     * @type {?}\n     */\n    MatChip.prototype._onBlur;\n    /**\n     * Emitted when the chip is selected or deselected.\n     * @type {?}\n     */\n    MatChip.prototype.selectionChange;\n    /**\n     * Emitted when the chip is destroyed.\n     * @type {?}\n     */\n    MatChip.prototype.destroyed;\n    /**\n     * Emitted when a chip is to be removed.\n     * @type {?}\n     */\n    MatChip.prototype.removed;\n    /** @type {?} */\n    MatChip.prototype._elementRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatChip.prototype._ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatChip.prototype._changeDetectorRef;\n}\n/**\n * Applies proper (click) support and adds styling for use with the Material Design \"cancel\" icon\n * available at https://material.io/icons/#ic_cancel.\n *\n * Example:\n *\n *     `<mat-chip>\n *       <mat-icon matChipRemove>cancel</mat-icon>\n *     </mat-chip>`\n *\n * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning\n * styles to properly center the icon within the chip.\n */\nclass MatChipRemove {\n    /**\n     * @param {?} _parentChip\n     * @param {?=} elementRef\n     */\n    constructor(_parentChip, \n    // @breaking-change 11.0.0 `elementRef` parameter to be made required.\n    elementRef) {\n        this._parentChip = _parentChip;\n        // @breaking-change 11.0.0 Remove null check for `elementRef`.\n        if (elementRef && elementRef.nativeElement.nodeName === 'BUTTON') {\n            elementRef.nativeElement.setAttribute('type', 'button');\n        }\n    }\n    /**\n     * Calls the parent chip's public `remove()` method if applicable.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleClick(event) {\n        /** @type {?} */\n        const parentChip = this._parentChip;\n        if (parentChip.removable && !parentChip.disabled) {\n            parentChip.remove();\n        }\n        // We need to stop event propagation because otherwise the event will bubble up to the\n        // form field and cause the `onContainerClick` method to be invoked. This method would then\n        // reset the focused chip that has been focused after chip removal. Usually the parent\n        // the parent click listener of the `MatChip` would prevent propagation, but it can happen\n        // that the chip is being removed before the event bubbles up.\n        event.stopPropagation();\n    }\n}\nMatChipRemove.decorators = [\n    { type: Directive, args: [{\n                selector: '[matChipRemove]',\n                host: {\n                    'class': 'mat-chip-remove mat-chip-trailing-icon',\n                    '(click)': '_handleClick($event)',\n                }\n            },] }\n];\n/** @nocollapse */\nMatChipRemove.ctorParameters = () => [\n    { type: MatChip },\n    { type: ElementRef }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChipRemove.prototype._parentChip;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/chips/chip-default-options.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default options, for the chips module, that can be overridden.\n * @record\n */\nfunction MatChipsDefaultOptions() { }\nif (false) {\n    /**\n     * The list of key codes that will trigger a chipEnd event.\n     * @type {?}\n     */\n    MatChipsDefaultOptions.prototype.separatorKeyCodes;\n}\n/**\n * Injection token to be used to override the default options for the chips module.\n * @type {?}\n */\nconst MAT_CHIPS_DEFAULT_OPTIONS = new InjectionToken('mat-chips-default-options');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/chips/chip-list.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatChipList.\n/**\n * \\@docs-private\n */\nclass MatChipListBase {\n    /**\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} ngControl\n     */\n    constructor(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n}\nif (false) {\n    /** @type {?} */\n    MatChipListBase.prototype._defaultErrorStateMatcher;\n    /** @type {?} */\n    MatChipListBase.prototype._parentForm;\n    /** @type {?} */\n    MatChipListBase.prototype._parentFormGroup;\n    /**\n     * \\@docs-private\n     * @type {?}\n     */\n    MatChipListBase.prototype.ngControl;\n}\n/** @type {?} */\nconst _MatChipListMixinBase = mixinErrorState(MatChipListBase);\n// Increasing integer for generating unique ids for chip-list components.\n/** @type {?} */\nlet nextUniqueId = 0;\n/**\n * Change event object that is emitted when the chip list value has changed.\n */\nclass MatChipListChange {\n    /**\n     * @param {?} source\n     * @param {?} value\n     */\n    constructor(source, value) {\n        this.source = source;\n        this.value = value;\n    }\n}\nif (false) {\n    /**\n     * Chip list that emitted the event.\n     * @type {?}\n     */\n    MatChipListChange.prototype.source;\n    /**\n     * Value of the chip list when the event was emitted.\n     * @type {?}\n     */\n    MatChipListChange.prototype.value;\n}\n/**\n * A material design chips component (named ChipList for its similarity to the List component).\n */\nclass MatChipList extends _MatChipListMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _changeDetectorRef\n     * @param {?} _dir\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} ngControl\n     */\n    constructor(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, ngControl) {\n        super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n        this._elementRef = _elementRef;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this.ngControl = ngControl;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.controlType = 'mat-chip-list';\n        /**\n         * When a chip is destroyed, we store the index of the destroyed chip until the chips\n         * query list notifies about the update. This is necessary because we cannot determine an\n         * appropriate chip that should receive focus until the array of chips updated completely.\n         */\n        this._lastDestroyedChipIndex = null;\n        /**\n         * Subject that emits when the component has been destroyed.\n         */\n        this._destroyed = new Subject();\n        /**\n         * Uid of the chip list\n         */\n        this._uid = `mat-chip-list-${nextUniqueId++}`;\n        /**\n         * Tab index for the chip list.\n         */\n        this._tabIndex = 0;\n        /**\n         * User defined tab index.\n         * When it is not null, use user defined tab index. Otherwise use _tabIndex\n         */\n        this._userTabIndex = null;\n        /**\n         * Function when touched\n         */\n        this._onTouched = (/**\n         * @return {?}\n         */\n        () => { });\n        /**\n         * Function when changed\n         */\n        this._onChange = (/**\n         * @return {?}\n         */\n        () => { });\n        this._multiple = false;\n        this._compareWith = (/**\n         * @param {?} o1\n         * @param {?} o2\n         * @return {?}\n         */\n        (o1, o2) => o1 === o2);\n        this._required = false;\n        this._disabled = false;\n        /**\n         * Orientation of the chip list.\n         */\n        this.ariaOrientation = 'horizontal';\n        this._selectable = true;\n        /**\n         * Event emitted when the selected chip list value has been changed by the user.\n         */\n        this.change = new EventEmitter();\n        /**\n         * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n         * to facilitate the two-way binding for the `value` input.\n         * \\@docs-private\n         */\n        this.valueChange = new EventEmitter();\n        if (this.ngControl) {\n            this.ngControl.valueAccessor = this;\n        }\n    }\n    /**\n     * The array of selected chips inside chip list.\n     * @return {?}\n     */\n    get selected() {\n        return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\n    }\n    /**\n     * The ARIA role applied to the chip list.\n     * @return {?}\n     */\n    get role() { return this.empty ? null : 'listbox'; }\n    /**\n     * Whether the user should be allowed to select multiple chips.\n     * @return {?}\n     */\n    get multiple() { return this._multiple; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set multiple(value) {\n        this._multiple = coerceBooleanProperty(value);\n        this._syncChipsState();\n    }\n    /**\n     * A function to compare the option values with the selected values. The first argument\n     * is a value from an option. The second is a value from the selection. A boolean\n     * should be returned.\n     * @return {?}\n     */\n    get compareWith() { return this._compareWith; }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    set compareWith(fn) {\n        this._compareWith = fn;\n        if (this._selectionModel) {\n            // A different comparator means the selection could change.\n            this._initializeSelection();\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get value() { return this._value; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set value(value) {\n        this.writeValue(value);\n        this._value = value;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get id() {\n        return this._chipInput ? this._chipInput.id : this._uid;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get required() { return this._required; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set required(value) {\n        this._required = coerceBooleanProperty(value);\n        this.stateChanges.next();\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get placeholder() {\n        return this._chipInput ? this._chipInput.placeholder : this._placeholder;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set placeholder(value) {\n        this._placeholder = value;\n        this.stateChanges.next();\n    }\n    /**\n     * Whether any chips or the matChipInput inside of this chip-list has focus.\n     * @return {?}\n     */\n    get focused() {\n        return (this._chipInput && this._chipInput.focused) || this._hasFocusedChip();\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get empty() {\n        return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get shouldLabelFloat() { return !this.empty || this.focused; }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get disabled() { return this.ngControl ? !!this.ngControl.disabled : this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._syncChipsState();\n    }\n    /**\n     * Whether or not this chip list is selectable. When a chip list is not selectable,\n     * the selected states for all the chips inside the chip list are always ignored.\n     * @return {?}\n     */\n    get selectable() { return this._selectable; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set selectable(value) {\n        this._selectable = coerceBooleanProperty(value);\n        if (this.chips) {\n            this.chips.forEach((/**\n             * @param {?} chip\n             * @return {?}\n             */\n            chip => chip.chipListSelectable = this._selectable));\n        }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set tabIndex(value) {\n        this._userTabIndex = value;\n        this._tabIndex = value;\n    }\n    /**\n     * Combined stream of all of the child chips' selection change events.\n     * @return {?}\n     */\n    get chipSelectionChanges() {\n        return merge(...this.chips.map((/**\n         * @param {?} chip\n         * @return {?}\n         */\n        chip => chip.selectionChange)));\n    }\n    /**\n     * Combined stream of all of the child chips' focus change events.\n     * @return {?}\n     */\n    get chipFocusChanges() {\n        return merge(...this.chips.map((/**\n         * @param {?} chip\n         * @return {?}\n         */\n        chip => chip._onFocus)));\n    }\n    /**\n     * Combined stream of all of the child chips' blur change events.\n     * @return {?}\n     */\n    get chipBlurChanges() {\n        return merge(...this.chips.map((/**\n         * @param {?} chip\n         * @return {?}\n         */\n        chip => chip._onBlur)));\n    }\n    /**\n     * Combined stream of all of the child chips' remove change events.\n     * @return {?}\n     */\n    get chipRemoveChanges() {\n        return merge(...this.chips.map((/**\n         * @param {?} chip\n         * @return {?}\n         */\n        chip => chip.destroyed)));\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._keyManager = new FocusKeyManager(this.chips)\n            .withWrap()\n            .withVerticalOrientation()\n            .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');\n        if (this._dir) {\n            this._dir.change\n                .pipe(takeUntil(this._destroyed))\n                .subscribe((/**\n             * @param {?} dir\n             * @return {?}\n             */\n            dir => this._keyManager.withHorizontalOrientation(dir)));\n        }\n        this._keyManager.tabOut.pipe(takeUntil(this._destroyed)).subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._allowFocusEscape();\n        }));\n        // When the list changes, re-subscribe\n        this.chips.changes.pipe(startWith(null), takeUntil(this._destroyed)).subscribe((/**\n         * @return {?}\n         */\n        () => {\n            if (this.disabled) {\n                // Since this happens after the content has been\n                // checked, we need to defer it to the next tick.\n                Promise.resolve().then((/**\n                 * @return {?}\n                 */\n                () => {\n                    this._syncChipsState();\n                }));\n            }\n            this._resetChips();\n            // Reset chips selected/deselected status\n            this._initializeSelection();\n            // Check to see if we need to update our tab index\n            this._updateTabIndex();\n            // Check to see if we have a destroyed chip and need to refocus\n            this._updateFocusForDestroyedChips();\n            this.stateChanges.next();\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this._selectionModel = new SelectionModel(this.multiple, undefined, false);\n        this.stateChanges.next();\n    }\n    /**\n     * @return {?}\n     */\n    ngDoCheck() {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n            if (this.ngControl.disabled !== this._disabled) {\n                this.disabled = !!this.ngControl.disabled;\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n        this.stateChanges.complete();\n        this._dropSubscriptions();\n    }\n    /**\n     * Associates an HTML input element with this chip list.\n     * @param {?} inputElement\n     * @return {?}\n     */\n    registerInput(inputElement) {\n        this._chipInput = inputElement;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    setDescribedByIds(ids) { this._ariaDescribedby = ids.join(' '); }\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    writeValue(value) {\n        if (this.chips) {\n            this._setSelectionByValue(value, false);\n        }\n    }\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    registerOnChange(fn) {\n        this._onChange = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    registerOnTouched(fn) {\n        this._onTouched = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this.stateChanges.next();\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} event\n     * @return {?}\n     */\n    onContainerClick(event) {\n        if (!this._originatesFromChip(event)) {\n            this.focus();\n        }\n    }\n    /**\n     * Focuses the first non-disabled chip in this chip list, or the associated input when there\n     * are no eligible chips.\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(options) {\n        if (this.disabled) {\n            return;\n        }\n        // TODO: ARIA says this should focus the first `selected` chip if any are selected.\n        // Focus on first element if there's no chipInput inside chip-list\n        if (this._chipInput && this._chipInput.focused) {\n            // do nothing\n        }\n        else if (this.chips.length > 0) {\n            this._keyManager.setFirstItemActive();\n            this.stateChanges.next();\n        }\n        else {\n            this._focusInput(options);\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Attempt to focus an input if we have one.\n     * @param {?=} options\n     * @return {?}\n     */\n    _focusInput(options) {\n        if (this._chipInput) {\n            this._chipInput.focus(options);\n        }\n    }\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     * @param {?} event\n     * @return {?}\n     */\n    _keydown(event) {\n        /** @type {?} */\n        const target = (/** @type {?} */ (event.target));\n        // If they are on an empty input and hit backspace, focus the last chip\n        if (event.keyCode === BACKSPACE && this._isInputEmpty(target)) {\n            this._keyManager.setLastItemActive();\n            event.preventDefault();\n        }\n        else if (target && target.classList.contains('mat-chip')) {\n            if (event.keyCode === HOME) {\n                this._keyManager.setFirstItemActive();\n                event.preventDefault();\n            }\n            else if (event.keyCode === END) {\n                this._keyManager.setLastItemActive();\n                event.preventDefault();\n            }\n            else {\n                this._keyManager.onKeydown(event);\n            }\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     * @protected\n     * @return {?}\n     */\n    _updateTabIndex() {\n        // If we have 0 chips, we should not allow keyboard focus\n        this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);\n    }\n    /**\n     * If the amount of chips changed, we need to update the\n     * key manager state and focus the next closest chip.\n     * @protected\n     * @return {?}\n     */\n    _updateFocusForDestroyedChips() {\n        // Move focus to the closest chip. If no other chips remain, focus the chip-list itself.\n        if (this._lastDestroyedChipIndex != null) {\n            if (this.chips.length) {\n                /** @type {?} */\n                const newChipIndex = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);\n                this._keyManager.setActiveItem(newChipIndex);\n            }\n            else {\n                this.focus();\n            }\n        }\n        this._lastDestroyedChipIndex = null;\n    }\n    /**\n     * Utility to ensure all indexes are valid.\n     *\n     * @private\n     * @param {?} index The index to be checked.\n     * @return {?} True if the index is valid for our list of chips.\n     */\n    _isValidIndex(index) {\n        return index >= 0 && index < this.chips.length;\n    }\n    /**\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _isInputEmpty(element) {\n        if (element && element.nodeName.toLowerCase() === 'input') {\n            /** @type {?} */\n            let input = (/** @type {?} */ (element));\n            return !input.value;\n        }\n        return false;\n    }\n    /**\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    _setSelectionByValue(value, isUserInput = true) {\n        this._clearSelection();\n        this.chips.forEach((/**\n         * @param {?} chip\n         * @return {?}\n         */\n        chip => chip.deselect()));\n        if (Array.isArray(value)) {\n            value.forEach((/**\n             * @param {?} currentValue\n             * @return {?}\n             */\n            currentValue => this._selectValue(currentValue, isUserInput)));\n            this._sortValues();\n        }\n        else {\n            /** @type {?} */\n            const correspondingChip = this._selectValue(value, isUserInput);\n            // Shift focus to the active item. Note that we shouldn't do this in multiple\n            // mode, because we don't know what chip the user interacted with last.\n            if (correspondingChip) {\n                if (isUserInput) {\n                    this._keyManager.setActiveItem(correspondingChip);\n                }\n            }\n        }\n    }\n    /**\n     * Finds and selects the chip based on its value.\n     * @private\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?} Chip that has the corresponding value.\n     */\n    _selectValue(value, isUserInput = true) {\n        /** @type {?} */\n        const correspondingChip = this.chips.find((/**\n         * @param {?} chip\n         * @return {?}\n         */\n        chip => {\n            return chip.value != null && this._compareWith(chip.value, value);\n        }));\n        if (correspondingChip) {\n            isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();\n            this._selectionModel.select(correspondingChip);\n        }\n        return correspondingChip;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _initializeSelection() {\n        // Defer setting the value in order to avoid the \"Expression\n        // has changed after it was checked\" errors from Angular.\n        Promise.resolve().then((/**\n         * @return {?}\n         */\n        () => {\n            if (this.ngControl || this._value) {\n                this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value, false);\n                this.stateChanges.next();\n            }\n        }));\n    }\n    /**\n     * Deselects every chip in the list.\n     * @private\n     * @param {?=} skip Chip that should not be deselected.\n     * @return {?}\n     */\n    _clearSelection(skip) {\n        this._selectionModel.clear();\n        this.chips.forEach((/**\n         * @param {?} chip\n         * @return {?}\n         */\n        chip => {\n            if (chip !== skip) {\n                chip.deselect();\n            }\n        }));\n        this.stateChanges.next();\n    }\n    /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     * @private\n     * @return {?}\n     */\n    _sortValues() {\n        if (this._multiple) {\n            this._selectionModel.clear();\n            this.chips.forEach((/**\n             * @param {?} chip\n             * @return {?}\n             */\n            chip => {\n                if (chip.selected) {\n                    this._selectionModel.select(chip);\n                }\n            }));\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Emits change event to set the model value.\n     * @private\n     * @param {?=} fallbackValue\n     * @return {?}\n     */\n    _propagateChanges(fallbackValue) {\n        /** @type {?} */\n        let valueToEmit = null;\n        if (Array.isArray(this.selected)) {\n            valueToEmit = this.selected.map((/**\n             * @param {?} chip\n             * @return {?}\n             */\n            chip => chip.value));\n        }\n        else {\n            valueToEmit = this.selected ? this.selected.value : fallbackValue;\n        }\n        this._value = valueToEmit;\n        this.change.emit(new MatChipListChange(this, valueToEmit));\n        this.valueChange.emit(valueToEmit);\n        this._onChange(valueToEmit);\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * When blurred, mark the field as touched when focus moved outside the chip list.\n     * @return {?}\n     */\n    _blur() {\n        if (!this._hasFocusedChip()) {\n            this._keyManager.setActiveItem(-1);\n        }\n        if (!this.disabled) {\n            if (this._chipInput) {\n                // If there's a chip input, we should check whether the focus moved to chip input.\n                // If the focus is not moved to chip input, mark the field as touched. If the focus moved\n                // to chip input, do nothing.\n                // Timeout is needed to wait for the focus() event trigger on chip input.\n                setTimeout((/**\n                 * @return {?}\n                 */\n                () => {\n                    if (!this.focused) {\n                        this._markAsTouched();\n                    }\n                }));\n            }\n            else {\n                // If there's no chip input, then mark the field as touched.\n                this._markAsTouched();\n            }\n        }\n    }\n    /**\n     * Mark the field as touched\n     * @return {?}\n     */\n    _markAsTouched() {\n        this._onTouched();\n        this._changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n    }\n    /**\n     * Removes the `tabindex` from the chip list and resets it back afterwards, allowing the\n     * user to tab out of it. This prevents the list from capturing focus and redirecting\n     * it back to the first chip, creating a focus trap, if it user tries to tab away.\n     * @return {?}\n     */\n    _allowFocusEscape() {\n        if (this._tabIndex !== -1) {\n            this._tabIndex = -1;\n            setTimeout((/**\n             * @return {?}\n             */\n            () => {\n                this._tabIndex = this._userTabIndex || 0;\n                this._changeDetectorRef.markForCheck();\n            }));\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _resetChips() {\n        this._dropSubscriptions();\n        this._listenToChipsFocus();\n        this._listenToChipsSelection();\n        this._listenToChipsRemoved();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _dropSubscriptions() {\n        if (this._chipFocusSubscription) {\n            this._chipFocusSubscription.unsubscribe();\n            this._chipFocusSubscription = null;\n        }\n        if (this._chipBlurSubscription) {\n            this._chipBlurSubscription.unsubscribe();\n            this._chipBlurSubscription = null;\n        }\n        if (this._chipSelectionSubscription) {\n            this._chipSelectionSubscription.unsubscribe();\n            this._chipSelectionSubscription = null;\n        }\n        if (this._chipRemoveSubscription) {\n            this._chipRemoveSubscription.unsubscribe();\n            this._chipRemoveSubscription = null;\n        }\n    }\n    /**\n     * Listens to user-generated selection events on each chip.\n     * @private\n     * @return {?}\n     */\n    _listenToChipsSelection() {\n        this._chipSelectionSubscription = this.chipSelectionChanges.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            event.source.selected\n                ? this._selectionModel.select(event.source)\n                : this._selectionModel.deselect(event.source);\n            // For single selection chip list, make sure the deselected value is unselected.\n            if (!this.multiple) {\n                this.chips.forEach((/**\n                 * @param {?} chip\n                 * @return {?}\n                 */\n                chip => {\n                    if (!this._selectionModel.isSelected(chip) && chip.selected) {\n                        chip.deselect();\n                    }\n                }));\n            }\n            if (event.isUserInput) {\n                this._propagateChanges();\n            }\n        }));\n    }\n    /**\n     * Listens to user-generated selection events on each chip.\n     * @private\n     * @return {?}\n     */\n    _listenToChipsFocus() {\n        this._chipFocusSubscription = this.chipFocusChanges.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            /** @type {?} */\n            let chipIndex = this.chips.toArray().indexOf(event.chip);\n            if (this._isValidIndex(chipIndex)) {\n                this._keyManager.updateActiveItem(chipIndex);\n            }\n            this.stateChanges.next();\n        }));\n        this._chipBlurSubscription = this.chipBlurChanges.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._blur();\n            this.stateChanges.next();\n        }));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _listenToChipsRemoved() {\n        this._chipRemoveSubscription = this.chipRemoveChanges.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            /** @type {?} */\n            const chip = event.chip;\n            /** @type {?} */\n            const chipIndex = this.chips.toArray().indexOf(event.chip);\n            // In case the chip that will be removed is currently focused, we temporarily store\n            // the index in order to be able to determine an appropriate sibling chip that will\n            // receive focus.\n            if (this._isValidIndex(chipIndex) && chip._hasFocus) {\n                this._lastDestroyedChipIndex = chipIndex;\n            }\n        }));\n    }\n    /**\n     * Checks whether an event comes from inside a chip element.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _originatesFromChip(event) {\n        /** @type {?} */\n        let currentElement = (/** @type {?} */ (event.target));\n        while (currentElement && currentElement !== this._elementRef.nativeElement) {\n            if (currentElement.classList.contains('mat-chip')) {\n                return true;\n            }\n            currentElement = currentElement.parentElement;\n        }\n        return false;\n    }\n    /**\n     * Checks whether any of the chips is focused.\n     * @private\n     * @return {?}\n     */\n    _hasFocusedChip() {\n        return this.chips.some((/**\n         * @param {?} chip\n         * @return {?}\n         */\n        chip => chip._hasFocus));\n    }\n    /**\n     * Syncs the list's state with the individual chips.\n     * @private\n     * @return {?}\n     */\n    _syncChipsState() {\n        if (this.chips) {\n            this.chips.forEach((/**\n             * @param {?} chip\n             * @return {?}\n             */\n            chip => {\n                chip.disabled = this._disabled;\n                chip._chipListMultiple = this.multiple;\n            }));\n        }\n    }\n}\nMatChipList.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-chip-list',\n                template: `<div class=\"mat-chip-list-wrapper\"><ng-content></ng-content></div>`,\n                exportAs: 'matChipList',\n                host: {\n                    '[attr.tabindex]': 'disabled ? null : _tabIndex',\n                    '[attr.aria-describedby]': '_ariaDescribedby || null',\n                    '[attr.aria-required]': 'role ? required : null',\n                    '[attr.aria-disabled]': 'disabled.toString()',\n                    '[attr.aria-invalid]': 'errorState',\n                    '[attr.aria-multiselectable]': 'multiple',\n                    '[attr.role]': 'role',\n                    '[class.mat-chip-list-disabled]': 'disabled',\n                    '[class.mat-chip-list-invalid]': 'errorState',\n                    '[class.mat-chip-list-required]': 'required',\n                    '[attr.aria-orientation]': 'ariaOrientation',\n                    'class': 'mat-chip-list',\n                    '(focus)': 'focus()',\n                    '(blur)': '_blur()',\n                    '(keydown)': '_keydown($event)',\n                    '[id]': '_uid',\n                },\n                providers: [{ provide: MatFormFieldControl, useExisting: MatChipList }],\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                styles: [\".mat-chip{position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;transform:translateZ(0);border:none;-webkit-appearance:none;-moz-appearance:none}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:\\\"\\\";pointer-events:none;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:none}.mat-standard-chip:focus::after{opacity:.16}.cdk-high-contrast-active .mat-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-standard-chip:focus{outline:dotted 2px}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit;overflow:hidden}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper input.mat-input-element,.mat-chip-list-wrapper .mat-standard-chip{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}\\n\"]\n            }] }\n];\n/** @nocollapse */\nMatChipList.ctorParameters = () => [\n    { type: ElementRef },\n    { type: ChangeDetectorRef },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: NgForm, decorators: [{ type: Optional }] },\n    { type: FormGroupDirective, decorators: [{ type: Optional }] },\n    { type: ErrorStateMatcher },\n    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] }\n];\nMatChipList.propDecorators = {\n    errorStateMatcher: [{ type: Input }],\n    multiple: [{ type: Input }],\n    compareWith: [{ type: Input }],\n    value: [{ type: Input }],\n    required: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    disabled: [{ type: Input }],\n    ariaOrientation: [{ type: Input, args: ['aria-orientation',] }],\n    selectable: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    change: [{ type: Output }],\n    valueChange: [{ type: Output }],\n    chips: [{ type: ContentChildren, args: [MatChip, {\n                    // We need to use `descendants: true`, because Ivy will no longer match\n                    // indirect descendants if it's left as false.\n                    descendants: true\n                },] }]\n};\nif (false) {\n    /** @type {?} */\n    MatChipList.ngAcceptInputType_multiple;\n    /** @type {?} */\n    MatChipList.ngAcceptInputType_required;\n    /** @type {?} */\n    MatChipList.ngAcceptInputType_disabled;\n    /** @type {?} */\n    MatChipList.ngAcceptInputType_selectable;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @type {?}\n     */\n    MatChipList.prototype.controlType;\n    /**\n     * When a chip is destroyed, we store the index of the destroyed chip until the chips\n     * query list notifies about the update. This is necessary because we cannot determine an\n     * appropriate chip that should receive focus until the array of chips updated completely.\n     * @type {?}\n     * @private\n     */\n    MatChipList.prototype._lastDestroyedChipIndex;\n    /**\n     * Subject that emits when the component has been destroyed.\n     * @type {?}\n     * @private\n     */\n    MatChipList.prototype._destroyed;\n    /**\n     * Subscription to focus changes in the chips.\n     * @type {?}\n     * @private\n     */\n    MatChipList.prototype._chipFocusSubscription;\n    /**\n     * Subscription to blur changes in the chips.\n     * @type {?}\n     * @private\n     */\n    MatChipList.prototype._chipBlurSubscription;\n    /**\n     * Subscription to selection changes in chips.\n     * @type {?}\n     * @private\n     */\n    MatChipList.prototype._chipSelectionSubscription;\n    /**\n     * Subscription to remove changes in chips.\n     * @type {?}\n     * @private\n     */\n    MatChipList.prototype._chipRemoveSubscription;\n    /**\n     * The chip input to add more chips\n     * @type {?}\n     * @protected\n     */\n    MatChipList.prototype._chipInput;\n    /**\n     * Uid of the chip list\n     * @type {?}\n     */\n    MatChipList.prototype._uid;\n    /**\n     * The aria-describedby attribute on the chip list for improved a11y.\n     * @type {?}\n     */\n    MatChipList.prototype._ariaDescribedby;\n    /**\n     * Tab index for the chip list.\n     * @type {?}\n     */\n    MatChipList.prototype._tabIndex;\n    /**\n     * User defined tab index.\n     * When it is not null, use user defined tab index. Otherwise use _tabIndex\n     * @type {?}\n     */\n    MatChipList.prototype._userTabIndex;\n    /**\n     * The FocusKeyManager which handles focus.\n     * @type {?}\n     */\n    MatChipList.prototype._keyManager;\n    /**\n     * Function when touched\n     * @type {?}\n     */\n    MatChipList.prototype._onTouched;\n    /**\n     * Function when changed\n     * @type {?}\n     */\n    MatChipList.prototype._onChange;\n    /** @type {?} */\n    MatChipList.prototype._selectionModel;\n    /**\n     * An object used to control when error messages are shown.\n     * @type {?}\n     */\n    MatChipList.prototype.errorStateMatcher;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatChipList.prototype._multiple;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatChipList.prototype._compareWith;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChipList.prototype._value;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChipList.prototype._required;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChipList.prototype._placeholder;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChipList.prototype._disabled;\n    /**\n     * Orientation of the chip list.\n     * @type {?}\n     */\n    MatChipList.prototype.ariaOrientation;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChipList.prototype._selectable;\n    /**\n     * Event emitted when the selected chip list value has been changed by the user.\n     * @type {?}\n     */\n    MatChipList.prototype.change;\n    /**\n     * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n     * to facilitate the two-way binding for the `value` input.\n     * \\@docs-private\n     * @type {?}\n     */\n    MatChipList.prototype.valueChange;\n    /**\n     * The chip components contained within this chip list.\n     * @type {?}\n     */\n    MatChipList.prototype.chips;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChipList.prototype._elementRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatChipList.prototype._changeDetectorRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatChipList.prototype._dir;\n    /**\n     * \\@docs-private\n     * @type {?}\n     */\n    MatChipList.prototype.ngControl;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/chips/chip-input.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Represents an input event on a `matChipInput`.\n * @record\n */\nfunction MatChipInputEvent() { }\nif (false) {\n    /**\n     * The native `<input>` element that the event is being fired for.\n     * @type {?}\n     */\n    MatChipInputEvent.prototype.input;\n    /**\n     * The value of the input.\n     * @type {?}\n     */\n    MatChipInputEvent.prototype.value;\n}\n// Increasing integer for generating unique ids.\n/** @type {?} */\nlet nextUniqueId$1 = 0;\n/**\n * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.\n * May be placed inside or outside of an `<mat-chip-list>`.\n */\nclass MatChipInput {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _defaultOptions\n     */\n    constructor(_elementRef, _defaultOptions) {\n        this._elementRef = _elementRef;\n        this._defaultOptions = _defaultOptions;\n        /**\n         * Whether the control is focused.\n         */\n        this.focused = false;\n        this._addOnBlur = false;\n        /**\n         * The list of key codes that will trigger a chipEnd event.\n         *\n         * Defaults to `[ENTER]`.\n         */\n        this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;\n        /**\n         * Emitted when a chip is to be added.\n         */\n        this.chipEnd = new EventEmitter();\n        /**\n         * The input's placeholder text.\n         */\n        this.placeholder = '';\n        /**\n         * Unique id for the input.\n         */\n        this.id = `mat-chip-list-input-${nextUniqueId$1++}`;\n        this._disabled = false;\n        this._inputElement = (/** @type {?} */ (this._elementRef.nativeElement));\n    }\n    /**\n     * Register input for chip list\n     * @param {?} value\n     * @return {?}\n     */\n    set chipList(value) {\n        if (value) {\n            this._chipList = value;\n            this._chipList.registerInput(this);\n        }\n    }\n    /**\n     * Whether or not the chipEnd event will be emitted when the input is blurred.\n     * @return {?}\n     */\n    get addOnBlur() { return this._addOnBlur; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set addOnBlur(value) { this._addOnBlur = coerceBooleanProperty(value); }\n    /**\n     * Whether the input is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled || (this._chipList && this._chipList.disabled); }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) { this._disabled = coerceBooleanProperty(value); }\n    /**\n     * Whether the input is empty.\n     * @return {?}\n     */\n    get empty() { return !this._inputElement.value; }\n    /**\n     * @return {?}\n     */\n    ngOnChanges() {\n        this._chipList.stateChanges.next();\n    }\n    /**\n     * Utility method to make host definition/tests more clear.\n     * @param {?=} event\n     * @return {?}\n     */\n    _keydown(event) {\n        // Allow the user's focus to escape when they're tabbing forward. Note that we don't\n        // want to do this when going backwards, because focus should go back to the first chip.\n        if (event && event.keyCode === TAB && !hasModifierKey(event, 'shiftKey')) {\n            this._chipList._allowFocusEscape();\n        }\n        this._emitChipEnd(event);\n    }\n    /**\n     * Checks to see if the blur should emit the (chipEnd) event.\n     * @return {?}\n     */\n    _blur() {\n        if (this.addOnBlur) {\n            this._emitChipEnd();\n        }\n        this.focused = false;\n        // Blur the chip list if it is not focused\n        if (!this._chipList.focused) {\n            this._chipList._blur();\n        }\n        this._chipList.stateChanges.next();\n    }\n    /**\n     * @return {?}\n     */\n    _focus() {\n        this.focused = true;\n        this._chipList.stateChanges.next();\n    }\n    /**\n     * Checks to see if the (chipEnd) event needs to be emitted.\n     * @param {?=} event\n     * @return {?}\n     */\n    _emitChipEnd(event) {\n        if (!this._inputElement.value && !!event) {\n            this._chipList._keydown(event);\n        }\n        if (!event || this._isSeparatorKey(event)) {\n            this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });\n            if (event) {\n                event.preventDefault();\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _onInput() {\n        // Let chip list know whenever the value changes.\n        this._chipList.stateChanges.next();\n    }\n    /**\n     * Focuses the input.\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(options) {\n        this._inputElement.focus(options);\n    }\n    /**\n     * Checks whether a keycode is one of the configured separators.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _isSeparatorKey(event) {\n        if (hasModifierKey(event)) {\n            return false;\n        }\n        /** @type {?} */\n        const separators = this.separatorKeyCodes;\n        /** @type {?} */\n        const keyCode = event.keyCode;\n        return Array.isArray(separators) ? separators.indexOf(keyCode) > -1 : separators.has(keyCode);\n    }\n}\nMatChipInput.decorators = [\n    { type: Directive, args: [{\n                selector: 'input[matChipInputFor]',\n                exportAs: 'matChipInput, matChipInputFor',\n                host: {\n                    'class': 'mat-chip-input mat-input-element',\n                    '(keydown)': '_keydown($event)',\n                    '(blur)': '_blur()',\n                    '(focus)': '_focus()',\n                    '(input)': '_onInput()',\n                    '[id]': 'id',\n                    '[attr.disabled]': 'disabled || null',\n                    '[attr.placeholder]': 'placeholder || null',\n                    '[attr.aria-invalid]': '_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null',\n                    '[attr.aria-required]': '_chipList && _chipList.required || null',\n                }\n            },] }\n];\n/** @nocollapse */\nMatChipInput.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_CHIPS_DEFAULT_OPTIONS,] }] }\n];\nMatChipInput.propDecorators = {\n    chipList: [{ type: Input, args: ['matChipInputFor',] }],\n    addOnBlur: [{ type: Input, args: ['matChipInputAddOnBlur',] }],\n    separatorKeyCodes: [{ type: Input, args: ['matChipInputSeparatorKeyCodes',] }],\n    chipEnd: [{ type: Output, args: ['matChipInputTokenEnd',] }],\n    placeholder: [{ type: Input }],\n    id: [{ type: Input }],\n    disabled: [{ type: Input }]\n};\nif (false) {\n    /** @type {?} */\n    MatChipInput.ngAcceptInputType_addOnBlur;\n    /** @type {?} */\n    MatChipInput.ngAcceptInputType_disabled;\n    /**\n     * Whether the control is focused.\n     * @type {?}\n     */\n    MatChipInput.prototype.focused;\n    /** @type {?} */\n    MatChipInput.prototype._chipList;\n    /** @type {?} */\n    MatChipInput.prototype._addOnBlur;\n    /**\n     * The list of key codes that will trigger a chipEnd event.\n     *\n     * Defaults to `[ENTER]`.\n     * @type {?}\n     */\n    MatChipInput.prototype.separatorKeyCodes;\n    /**\n     * Emitted when a chip is to be added.\n     * @type {?}\n     */\n    MatChipInput.prototype.chipEnd;\n    /**\n     * The input's placeholder text.\n     * @type {?}\n     */\n    MatChipInput.prototype.placeholder;\n    /**\n     * Unique id for the input.\n     * @type {?}\n     */\n    MatChipInput.prototype.id;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatChipInput.prototype._disabled;\n    /**\n     * The native input element to which this directive is attached.\n     * @type {?}\n     * @protected\n     */\n    MatChipInput.prototype._inputElement;\n    /**\n     * @type {?}\n     * @protected\n     */\n    MatChipInput.prototype._elementRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatChipInput.prototype._defaultOptions;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/chips/chips-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CHIP_DECLARATIONS = [\n    MatChipList,\n    MatChip,\n    MatChipInput,\n    MatChipRemove,\n    MatChipAvatar,\n    MatChipTrailingIcon,\n];\nconst ɵ0 = ({\n    separatorKeyCodes: [ENTER]\n});\nclass MatChipsModule {\n}\nMatChipsModule.decorators = [\n    { type: NgModule, args: [{\n                exports: CHIP_DECLARATIONS,\n                declarations: CHIP_DECLARATIONS,\n                providers: [\n                    ErrorStateMatcher,\n                    {\n                        provide: MAT_CHIPS_DEFAULT_OPTIONS,\n                        useValue: (/** @type {?} */ (ɵ0))\n                    }\n                ]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/chips/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_CHIPS_DEFAULT_OPTIONS, MatChip, MatChipAvatar, MatChipInput, MatChipList, MatChipListChange, MatChipRemove, MatChipSelectionChange, MatChipTrailingIcon, MatChipsModule };\n//# sourceMappingURL=chips.js.map\n"],"sourceRoot":"webpack:///"}