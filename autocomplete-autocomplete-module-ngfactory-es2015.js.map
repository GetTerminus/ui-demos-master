{"version":3,"sources":["/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/autocomplete/fesm2015/terminus-ui-autocomplete.js","/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/autocomplete/terminus-ui-autocomplete.d.ts.TsAutocompleteComponent.html","/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/autocomplete/terminus-ui-autocomplete.d.ts.TsAutocompletePanelComponent.html","/home/runner/work/terminus-oss/terminus-oss/node_modules/@angular/material/fesm2015/autocomplete.js","./src/app/components/autocomplete/autocomplete-routing.module.ts","./src/app/components/autocomplete/autocomplete.component.html","./src/app/components/autocomplete/autocomplete.component.ts","./src/app/components/autocomplete/autocomplete.module.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwD;AACoC;AAC7C;AAC2Q;AAClQ;AACqD;AACpD;AACA;AACqB;AACrB;AACmB;AAC0B;AACrD;AACE;AACsJ;AAC3H;AACf;AACV;AAC2B;AAC8B;AAC9C;AAC2B;AACvC;AACiD;AAC3C;AACoB;AACpB;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6EAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,wDAAU;AACtB;AACA,wDAAU;AACV,IAAI,+DAAS,CAAC,yDAAW;AACzB,IAAI,wDAAU,gBAAgB,yDAAW;AACzC;AACA,wDAAU;AACV,IAAI,+DAAS,WAAW,eAAe;AACvC,IAAI,wDAAU,gBAAgB,wDAAU;AACxC;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU,gBAAgB,uDAAS;AACvC;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU,gBAAgB,uDAAS;AACvC;AACA,wDAAU;AACV,IAAI,4DAAM;AACV,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,4DAAM;AACV,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,4DAAM;AACV,IAAI,wDAAU;AACd;AACA,gEAAgE,wDAAU;AAC1E,IAAI,+DAAS;AACb;AACA;AACA,eAAe,uDAAuD;AACtE;AACA;AACA,yBAAyB,+EAA0B;AACnD;AACA;AACA,aAAa;AACb;AACA,yBAAyB,qEAAuB;AAChD,uBAAuB,+DAAiB;AACxC;AACA,wBAAwB,gEAAgE,+DAA+D,+DAA+D,8DAA8D,UAAU,kBAAkB,qCAAqC,kDAAkD,2BAA2B,cAAc,iBAAiB,kBAAkB,UAAU,2BAA2B,8GAA8G,yBAAyB,yBAAyB,gBAAgB,oBAAoB,uCAAuC,iBAAiB,sBAAsB,kBAAkB,sBAAsB,0BAA0B,qCAAqC,iBAAiB,kDAAkD,mBAAmB,SAAS,gCAAgC,wBAAwB,cAAc,WAAW,YAAY,gBAAgB,UAAU,oBAAoB,kBAAkB,kBAAkB,UAAU,8BAA8B,uGAAuG,mBAAmB,8BAA8B,+BAA+B,cAAc,iBAAiB,eAAe,gBAAgB,cAAc,iCAAiC,kBAAkB,kBAAkB,WAAW,6CAA6C,8BAA8B,mBAAmB,yFAAyF,mBAAmB,mEAAmE,kBAAkB,WAAW,gBAAgB,sDAAsD,mBAAmB,qDAAqD,kBAAkB,2DAA2D,0BAA0B,qDAAqD,gBAAgB;AAC9lE,KAAK;AACL,IAAI,wDAAU,uBAAuB,+DAAiB;AACtD,QAAQ,wDAAU;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4DAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4DAAO;AAClB;AACA;AACA;AACA;AACA;AACA,kFAAkF,wBAAwB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6CAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAK;AACrC;AACA;AACA,uBAAuB,mDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAI,KAAK,iEAAS;AACxC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAY;AAChD;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAK,sEAAsE,8DAAM;AAChG;AACA,4FAA4F,gDAAE,WAAW,2DAAG,4BAA4B,4EAAuB;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2FAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAI;AAC5B;AACA;AACA,6CAA6C,kEAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kEAAI,8BAA8B,kEAAI;AACjF,8CAA8C,kEAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+DAAS;AAChD,sBAAsB,wEAAgB;AACtC;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE;AACA;AACA,8BAA8B,mEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAI,gCAAgC,kEAAI;AAC3E;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gDAAgD,8BAA8B;AAC9E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yFAA4B;AACvD,kCAAkC,oFAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8EAAO;AAClC,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,4DAAI;AACzE;AACA;AACA;AACA,QAAQ,2DAAG;AACX;AACA,QAAQ,6DAAK;AACb;AACA;AACA,eAAe,mDAAK;AACpB;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAS;AACjB;AACA;AACA;AACA,SAAS,GAAG,4DAAI,KAAK,8FAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,4DAAO,EAAE;AACrB,KAAK,OAAO,8DAAgB,EAAE;AAC9B,KAAK,OAAO,oDAAM,EAAE;AACpB,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,8EAAiB,EAAE;AAC/B,KAAK,OAAO,kEAAa,EAAE;AAC3B,KAAK,gCAAgC,OAAO,oDAAM,4CAA4C,GAAG;AACjG,KAAK,OAAO,6EAAoB,gBAAgB,OAAO,sDAAQ,EAAE,GAAG,OAAO,kDAAI,EAAE;AACjF;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,oEAAoE,wDAAU;AAC9E,IAAI,+DAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,gEAAiB;AAC1C;AACA,6BAA6B,gEAAU;AACvC;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL,IAAI,qDAAO,IAAI,4DAAM;AACrB,IAAI,qDAAO,IAAI,8DAAQ,KAAK,qDAAO,IAAI,0DAAI;AAC3C,IAAI,wDAAU,uBAAuB,wDAAU;AAC/C,QAAQ,4DAAO;AACf,QAAQ,8DAAgB;AACxB,QAAQ,oDAAM;AACd,QAAQ,+DAAiB;AACzB,QAAQ,8EAAiB;AACzB,QAAQ,kEAAa,UAAU,6EAAoB;AACnD;;AAEA;AACA,0CAA0C,4FAA4B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0DAAW;AACtD;AACA,6CAA6C,2BAA2B;AACxE;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,gCAAgC,6CAAO;AACvC;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA,sCAAsC,0DAAY;AAClD;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,oCAAoC,0DAAY;AAChD;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA,yBAAyB,0DAAY;AACrC;AACA;AACA;AACA,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0FAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yFAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0FAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gFAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8FAAuB;AACjD;AACA;AACA;AACA,yEAAyE,mBAAmB;AAC5F;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gFAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,+BAA+B,8FAAuB;AACtD;AACA,QAAQ,oEAAY;AACpB;AACA;AACA,QAAQ,iEAAS,UAAU,gDAAE;AAC7B;AACA,QAAQ,4EAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uDAAuD,8FAAuB;AAC9E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8FAAuB,QAAQ,8DAAM;AACpE;AACA,QAAQ,oEAAY;AACpB;AACA,QAAQ,4EAAoB;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6EAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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AA6C,4DAAc;AAC3D;AACA;AACA,CAAC;AACD;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC;AACA;AACA;AACA,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,kBAAkB,uCAAuC;AACzD;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iCAAiC,oCAAoC;AACrE;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,sCAAsC,mFAAqB;AAC3D;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA,aAAa,eAAe,EAAE,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,+BAA+B,4EAA0B;AACzD;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uCAAuC,8DAA8D;AACrG,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA,+BAA+B,+DAAiB;AAChD,iCAAiC,qEAAuB;AACxD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,qBAAqB,UAAU,kFAA2B;AAC1D;AACA,kDAAkD,gBAAgB,gBAAgB,cAAc,iCAAiC,kBAAkB,eAAe,iBAAiB,kBAAkB,WAAW,8BAA8B,+BAA+B,iDAAiD,mBAAmB,gDAAgD,kBAAkB,sDAAsD,gBAAgB,2BAA2B,4BAA4B,gDAAgD,gBAAgB,kDAAkD,kBAAkB;AACppB,aAAa;AACb;AACA;AACA;AACA,KAAK,OAAO,+DAAiB,EAAE;AAC/B,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,gCAAgC,OAAO,oDAAM,6CAA6C;AAC/F;AACA;AACA,gBAAgB,OAAO,uDAAS,SAAS,yDAAW,GAAG,eAAe,IAAI;AAC1E,aAAa,OAAO,uDAAS,oBAAoB;AACjD,eAAe,OAAO,6DAAe,SAAS,gEAAS,GAAG,oBAAoB,IAAI;AAClF,oBAAoB,OAAO,6DAAe,SAAS,kEAAW,GAAG,oBAAoB,IAAI;AACzF,mBAAmB,OAAO,mDAAK,EAAE;AACjC,6BAA6B,OAAO,mDAAK,EAAE;AAC3C,kBAAkB,OAAO,mDAAK,EAAE;AAChC,sBAAsB,OAAO,oDAAM,EAAE;AACrC,cAAc,OAAO,oDAAM,EAAE;AAC7B,cAAc,OAAO,oDAAM,EAAE;AAC7B,uBAAuB,OAAO,oDAAM,EAAE;AACtC,iBAAiB,OAAO,mDAAK,oBAAoB;AACjD;AACA,WAAW,EA+FV;;AAED;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK,OAAO,wDAAU;AACtB;AACA,WAAW,EAMV;;AAED;AACA;AACA;AACA,cAAc,wGAAwG;AACtH;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,6CAA6C,4DAAc;AAC3D;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,WAAW,4DAAO;AAClB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,aAAa,iEAAiB;AAC9B,iBAAiB,gEAAU;AAC3B,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iDAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,4CAAO;AAC/C;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,EAAE,KAAK,kDAAK;AACxD,oBAAoB;AACpB;AACA;AACA;AACA,uBAAuB,kDAAK;AAC5B,2BAA2B,EAAE;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAI,KAAK,iEAAS;AACxC,wBAAwB;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gCAAgC,mCAAmC;AACnE;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,qCAAqC,mFAAqB;AAC1D;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,aAAa;AACb,yCAAyC,6EAAc;AACvD;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,kDAAK,kEAAkE,8DAAM;AAC5F,oBAAoB;AACpB;AACA;AACA,gDAAgD,8DAAM;AACtD,wBAAwB;AACxB;AACA;AACA,YAAY,+CAAE;AACd;AACA,QAAQ,2DAAG;AACX,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,kCAAkC,+EAAwB;AAC1D;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,kDAAK,aAAa,EAAE,KAAK,sDAAS,yCAAyC,EAAE,KAAK,sDAAS;AAC1G,kBAAkB,8DAAM;AACxB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,4CAA4C,EAAE;AAC9C;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAM;AAC9B;AACA;AACA,6CAA6C,2DAAK;AAClD;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB,2CAA2C,8DAAQ,gBAAgB,gEAAU;AAC7E,8CAA8C,yDAAG;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,iCAAiC,EAAE;AACnC,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,2BAA2B,4FAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,sCAAsC,uFAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB,oEAAoE,4DAAI;AACxE,mBAAmB,EAAE;AACrB,qEAAqE,2DAAG;AACxE,oBAAoB;AACpB;AACA;AACA;AACA;AACA,QAAQ,6DAAK;AACb;AACA,eAAe,kDAAK;AACpB;AACA;AACA;AACA,QAAQ,iEAAS;AACjB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,4DAAI;AACZ;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,+BAA+B,mEAAc;AAC7C;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA,sCAAsC,4DAAM,uBAAuB,8DAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,+CAA+C,+BAA+B;AAC9E;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,kEAAa;AAChC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,aAAa,0EAA0E;AACvF,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,aAAa,sFAAsF;AACnG,aAAa;AACb;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","file":"autocomplete-autocomplete-module-ngfactory-es2015.js","sourcesContent":["import { __decorate, __metadata, __param } from 'tslib';\nimport { Overlay, OverlayConfig, ViewportRuler, OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { EventEmitter, ChangeDetectorRef, ElementRef, ViewChild, TemplateRef, Input, QueryList, Output, Component, ChangeDetectionStrategy, ViewEncapsulation, InjectionToken, isDevMode, ViewContainerRef, NgZone, Inject, Optional, Host, Directive, forwardRef, Self, ContentChildren, NgModule } from '@angular/core';\nimport { FlexLayoutModule } from '@angular/flex-layout';\nimport { NG_VALUE_ACCESSOR, FormControl, NgControl, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { MatRippleModule } from '@angular/material/core';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatProgressSpinnerModule } from '@angular/material/progress-spinner';\nimport { TsCheckboxModule } from '@terminus/ui-checkbox';\nimport { TsChipCollectionComponent, TsChipModule } from '@terminus/ui-chip';\nimport { TsFormFieldComponent, TsFormFieldControl, TsFormFieldModule } from '@terminus/ui-form-field';\nimport { TsIconModule } from '@terminus/ui-icon';\nimport { TsInputModule } from '@terminus/ui-input';\nimport { TS_OPTION_PARENT_COMPONENT, TsOptionSelectionChange, countGroupLabelsBeforeOption, getOptionScrollPosition, TsOptionComponent, TsOptgroupComponent, TsOptionModule } from '@terminus/ui-option';\nimport { TsValidationMessagesModule } from '@terminus/ui-validation-messages';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { Subject, defer, merge, Subscription, of, BehaviorSubject } from 'rxjs';\nimport { take, switchMap, filter, map, tap, delay, debounceTime, distinctUntilChanged } from 'rxjs/operators';\nimport { TsDocumentService } from '@terminus/ngx-tools/browser';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@terminus/ngx-tools/coercion';\nimport { KEYS } from '@terminus/ngx-tools/keycodes';\nimport { isUnset, untilComponentDestroyed, hasRequiredControl } from '@terminus/ngx-tools/utilities';\nimport { TsUILibraryError } from '@terminus/ui-utilities';\nimport { MatAutocompleteSelectedEvent } from '@angular/material/autocomplete';\nimport { isArray } from '@terminus/ngx-tools/type-guards';\n\nvar TsAutocompletePanelComponent_1;\n/**\n * Event object that is emitted when an autocomplete option is selected\n */\nclass TsAutocompletePanelSelectedEvent {\n    constructor(\n    // Reference to the autocomplete panel that emitted the event\n    // eslint-disable-next-line deprecation/deprecation\n    source, \n    // The option that was selected\n    option) {\n        this.source = source;\n        this.option = option;\n    }\n}\n// Unique ID for each instance\nlet nextUniqueId = 0;\n/**\n * The panel used to display autocomplete options when {@link TsOptionComponent} is in autocomplete mode.\n *\n * @deprecated Please use `TsSelectionListPanel`\n *\n * @example\n * <ts-autocomplete-panel\n *              [options]=\"myOptionsQueryList\"\n *              [optionGroups]=\"myOptionGroupsQueryList\"\n *              (optionsSelected)=\"doSomething($event)\"\n * ></ts-autocomplete-panel>\n */\nlet TsAutocompletePanelComponent = TsAutocompletePanelComponent_1 = class TsAutocompletePanelComponent {\n    constructor(changeDetectorRef, elementRef) {\n        this.changeDetectorRef = changeDetectorRef;\n        this.elementRef = elementRef;\n        /**\n         * Whether the autocomplete panel should be visible\n         */\n        this.showPanel = false;\n        /**\n         * Define the default component ID\n         */\n        this.uid = `ts-select-autocomplete-${nextUniqueId++}`;\n        /**\n         * Whether the autocomplete panel is open\n         */\n        this.isOpen = false;\n        /**\n         * Function that maps an option's control value to its display value in the trigger\n         */\n        this.displayWith = null;\n        this._id = this.uid;\n        /**\n         * Event that is emitted whenever an option from the list is selected\n         */\n        this.optionSelected = new EventEmitter();\n        /**\n         * Event that is emitted when the autocomplete panel is opened\n         */\n        this.opened = new EventEmitter();\n        /**\n         * Event that is emitted when the autocomplete panel is closed\n         */\n        this.closed = new EventEmitter();\n    }\n    /**\n     * Define an ID for the component\n     *\n     * @param value\n     */\n    set id(value) {\n        // Note: this ID is being set internally by `TsSelectComponent` so no fallback is needed.\n        this._id = value;\n    }\n    get id() {\n        return this._id;\n    }\n    /**\n     * Set up\n     */\n    ngAfterContentInit() {\n        this.keyManager = new ActiveDescendantKeyManager(this.options).withWrap();\n        // Set the initial visibility state.\n        this.setVisibility();\n    }\n    /**\n     * Emit the `select` event\n     *\n     * @param option\n     */\n    emitSelectEvent(option) {\n        const event = new TsAutocompletePanelSelectedEvent(this, option);\n        this.optionSelected.emit(event);\n    }\n    /**\n     * Return the panel's scrollTop\n     *\n     * @returns The scrolltop number\n     */\n    getScrollTop() {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n    /**\n     * Set the panel scrollTop.\n     *\n     * This allows us to manually scroll to display options above or below the fold, as they are not actually being focused when active.\n     *\n     * @param scrollTop - The number of pixels to move\n     */\n    setScrollTop(scrollTop) {\n        // istanbul ignore else\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n    /**\n     * Set the visibility of the panel based on whether options exist\n     */\n    setVisibility() {\n        this.showPanel = !!this.options.length;\n        this.changeDetectorRef.markForCheck();\n    }\n};\nTsAutocompletePanelComponent.ctorParameters = () => [\n    { type: ChangeDetectorRef },\n    { type: ElementRef }\n];\n__decorate([\n    ViewChild(TemplateRef),\n    __metadata(\"design:type\", TemplateRef)\n], TsAutocompletePanelComponent.prototype, \"template\", void 0);\n__decorate([\n    ViewChild('panel', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], TsAutocompletePanelComponent.prototype, \"panel\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Function)\n], TsAutocompletePanelComponent.prototype, \"displayWith\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsAutocompletePanelComponent.prototype, \"id\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", QueryList)\n], TsAutocompletePanelComponent.prototype, \"optionGroups\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", QueryList)\n], TsAutocompletePanelComponent.prototype, \"options\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompletePanelComponent.prototype, \"optionSelected\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompletePanelComponent.prototype, \"opened\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompletePanelComponent.prototype, \"closed\", void 0);\nTsAutocompletePanelComponent = TsAutocompletePanelComponent_1 = __decorate([\n    Component({\n        selector: 'ts-autocomplete-panel',\n        template: \"<ng-template>\\n  <div\\n    class=\\\"ts-autocomplete-panel__inner\\\"\\n    [class.ts-autocomplete-visible]=\\\"showPanel\\\"\\n    role=\\\"listbox\\\"\\n    [attr.id]=\\\"id\\\"\\n    #panel\\n  >\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\",\n        host: { class: 'ts-autocomplete-panel qa-autocomplete-panel' },\n        providers: [\n            {\n                provide: TS_OPTION_PARENT_COMPONENT,\n                // eslint-disable-next-line deprecation/deprecation\n                useExisting: TsAutocompletePanelComponent_1,\n            },\n        ],\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        encapsulation: ViewEncapsulation.None,\n        exportAs: 'tsAutocompletePanel',\n        styles: [\":root{--swift-ease-out-duration:var(--ts-animation-time-duration-400);--swift-ease-out-timing-function:cubic-bezier(.25, .8, .25, 1);--swift-ease-in-duration:var(--ts-animation-time-duration-300);--swift-ease-in-timing-function:cubic-bezier(.55, 0, .55, .2)}.cdk-drag{position:relative}.cdk-drag:not(.cdk-drag-placeholder){transition:transform 250ms cubic-bezier(0,0,.2,1)}.cdk-drag .cdk-drag-handle{color:#cecdd1;cursor:ns-resize;position:absolute;right:8px}.cdk-drag.cdk-drag-preview{--shadow:0 5px 5px -3px rgba(0, 0, 0, .2),0 8px 10px 1px rgba(0, 0, 0, .14),0 3px 14px 2px rgba(0, 0, 0, .12);background-color:#fafafa;box-shadow:var(--shadow);min-height:50px;padding:0!important}.cdk-drag.cdk-drag-preview .c-checkbox{margin-left:16px}.cdk-drag-placeholder{--drop-bg:#cce8d5;--drop-border:#7fd09c;background:var(--drop-bg);border:2px dotted var(--drop-border);cursor:ns-resize;transition:transform 250ms cubic-bezier(0,0,.2,1)}.u-visually-hidden{border:0;-webkit-clip-path:rect(0,0,0,0);clip-path:rect(0,0,0,0);display:block;height:1px;margin:-1px;overflow:hidden;padding:0;pointer-events:none;position:absolute;visibility:hidden;width:1px}.ts-autocomplete-panel__inner{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);background:#fafafa;border-bottom-left-radius:4px;border-bottom-right-radius:4px;color:#302d35;max-height:256px;max-width:none;min-width:112px;overflow:auto;-webkit-overflow-scrolling:touch;position:relative;visibility:hidden;width:100%}@media screen and (-ms-high-contrast:active){.ts-autocomplete-panel__inner{outline:solid 1px}}.ts-autocomplete-panel__inner .ts-option.ts-option--selected:not(.ts-active):not(:hover){background:#1777b6}.ts-autocomplete-panel__inner .ts-option:not(.ts-option--template){font-size:inherit;height:3em;line-height:3em}.ts-autocomplete-panel__inner.ts-autocomplete-visible{visibility:visible}.ts-autocomplete-panel__inner.ts-autocomplete-hidden{visibility:hidden}.ts-autocomplete-panel-above .ts-autocomplete-panel__inner{border-radius:4px 4px 0 0}.ts-autocomplete-panel__inner .ts-divider-horizontal{margin-top:-1px}\"]\n    }),\n    __metadata(\"design:paramtypes\", [ChangeDetectorRef,\n        ElementRef])\n], TsAutocompletePanelComponent);\n\nvar TsAutocompleteTriggerDirective_1;\n/**\n * The following style constants are necessary to save here in order to properly calculate the scrollTop of the panel.\n * Because we are not actually focusing the active item, scroll must be handled manually.\n */\n// The height of each autocomplete option.\nconst AUTOCOMPLETE_OPTION_HEIGHT = 48;\n// The total height of the autocomplete panel\nconst AUTOCOMPLETE_PANEL_HEIGHT = 256;\n// Injection token that determines the scroll handling while the autocomplete panel is open\nconst TS_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken('mat-autocomplete-scroll-strategy');\n/**\n * Define a scroll strategy factory\n *\n * @param overlay\n */\nconst TS_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY = (overlay) => () => overlay.scrollStrategies.reposition();\nconst TS_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: TS_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: TS_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n};\n// Unique ID for each instance\nlet nextUniqueId$1 = 0;\n/**\n * A directive that adds autocomplete trigger functionality to an input. Used in {@link TsSelectComponent}.\n *\n * @deprecated Please use `TsSelectionListTrigger`\n *\n * @example\n * <ts-input\n *              [tsAutocompleteTrigger]=\"myReferenceToAutocompletePanel\"\n *              [tsAutocompleteDisabled]=\"false\"\n *              autocomplete=\"off\"\n *              [reopenAfterSelection]=\"false\"\n * ></ts-input>\n */\nlet TsAutocompleteTriggerDirective = TsAutocompleteTriggerDirective_1 = class TsAutocompleteTriggerDirective {\n    constructor(elementRef, overlay, viewContainerRef, ngZone, changeDetectorRef, documentService, viewportRuler, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    scrollStrategy, formField) {\n        this.elementRef = elementRef;\n        this.overlay = overlay;\n        this.viewContainerRef = viewContainerRef;\n        this.ngZone = ngZone;\n        this.changeDetectorRef = changeDetectorRef;\n        this.documentService = documentService;\n        this.viewportRuler = viewportRuler;\n        this.formField = formField;\n        /**\n         * Whether the autocomplete can open the next time it is focused. Used to prevent a focused, closed autocomplete from being reopened if\n         * the user switches to another browser tab and then comes back.\n         */\n        this.canOpenOnNextFocus = true;\n        /**\n         * Stream of keyboard events that can close the panel\n         */\n        this.closeKeyEventStream = new Subject();\n        /*\n         * Note: In some cases `openPanel` can end up being called after the component is destroyed. This flag is to ensure that we don't try to\n         * run change detection on a destroyed view.\n         */\n        this.componentDestroyed = false;\n        /**\n         * Whether or not the label state is being overridden\n         */\n        this.manuallyFloatingLabel = false;\n        /**\n         * Stream of autocomplete option selections\n         */\n        this.optionSelections = defer(() => {\n            if (this.autocompletePanel && this.autocompletePanel.options) {\n                // eslint-disable-next-line deprecation/deprecation\n                return merge(...this.autocompletePanel.options.map(option => option.selectionChange));\n            }\n            // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n            // In that case, return a stream that we'll replace with the real one once everything is in place.\n            return this.ngZone.onStable\n                .asObservable()\n                // TODO: Refactor deprecation\n                // eslint-disable-next-line deprecation/deprecation\n                .pipe(take(1), switchMap(() => this.optionSelections));\n        });\n        /**\n         * Store whether the overlay is currently attached\n         */\n        this.overlayAttached = false;\n        /**\n         * Subscription to viewport size changes\n         */\n        this.viewportSubscription = Subscription.EMPTY;\n        /**\n         * Define the default component ID\n         */\n        this.uid = `ts-autocomplete-trigger-${nextUniqueId$1++}`;\n        /**\n         * The `autocomplete` attribute to be set on the input element.\n         *\n         * NOTE: Input has specific naming since it is accepting a standard HTML data attribute.\n         */\n        // eslint-disable-next-line @angular-eslint/no-input-rename\n        this.autocompleteAttribute = 'off';\n        this._autocompleteDisabled = false;\n        this._reopenAfterSelection = false;\n        /**\n         * View -> model callback called when value changes\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.onChange = () => { };\n        /**\n         * View -> model callback called when autocomplete has been touched\n         */\n        this.onTouched = () => { };\n        /**\n         * Event handler for when the window is blurred.\n         *\n         * Needs to be an arrow function in order to preserve the context.\n         */\n        this.windowBlurHandler = () => {\n            // If the user blurred the window while the autocomplete is focused, it means that it'll be\n            // refocused when they come back. In this case we want to skip the first focus event, if the\n            // pane was closed, in order to avoid reopening it unintentionally.\n            this.canOpenOnNextFocus = this.document.activeElement !== this.elementRef.nativeElement || this.panelOpen;\n        };\n        if (typeof window !== 'undefined') {\n            ngZone.runOutsideAngular(() => {\n                window.addEventListener('blur', this.windowBlurHandler);\n            });\n        }\n        this.scrollStrategy = scrollStrategy;\n        this.document = this.documentService.document;\n    }\n    /**\n     * The currently active option, coerced to TsOptionComponent type\n     */\n    get activeOption() {\n        if (this.autocompletePanel && this.autocompletePanel.keyManager) {\n            return this.autocompletePanel.keyManager.activeItem;\n        }\n        return null;\n    }\n    /**\n     * A stream of actions that should close the autocomplete panel, including when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions() {\n        var _a;\n        // eslint-disable-next-line deprecation/deprecation\n        return merge(this.optionSelections, this.autocompletePanel.keyManager.tabOut.pipe(filter(() => this.overlayAttached)), this.closeKeyEventStream, \n        // eslint-disable-next-line deprecation/deprecation\n        ((_a = this.overlayRef) === null || _a === void 0 ? void 0 : _a.backdropClick()) || of('')).pipe(map(event => (event instanceof TsOptionSelectionChange ? event : null)));\n    }\n    /**\n     * Whether or not the autocomplete panel is open\n     */\n    get panelOpen() {\n        return this.overlayAttached && this.autocompletePanel.showPanel;\n    }\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will act as a regular input and the user won't be able to open the\n     * panel.\n     *\n     * @param value\n     */\n    // eslint-disable-next-line @angular-eslint/no-input-rename\n    set autocompleteDisabled(value) {\n        this._autocompleteDisabled = coerceBooleanProperty(value);\n    }\n    get autocompleteDisabled() {\n        return this._autocompleteDisabled;\n    }\n    /**\n     * Define if the autocomplete panel should reopen after a selection is made\n     *\n     * @param value\n     */\n    set reopenAfterSelection(value) {\n        this._reopenAfterSelection = value;\n    }\n    get reopenAfterSelection() {\n        return this._reopenAfterSelection;\n    }\n    /**\n     * Clean up subscriptions and destroy the panel\n     */\n    ngOnDestroy() {\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('blur', this.windowBlurHandler);\n        }\n        this.viewportSubscription.unsubscribe();\n        this.componentDestroyed = true;\n        this.destroyPanel();\n        this.closeKeyEventStream.complete();\n    }\n    /**\n     * Close the autocomplete suggestion panel\n     *\n     * @param overrideReopenFlag - Whether the panel should reopen\n     */\n    closePanel(overrideReopenFlag) {\n        this.resetLabel();\n        if (!this.overlayAttached) {\n            return;\n        }\n        if (this.panelOpen) {\n            // Only emit if the panel was visible.\n            this.autocompletePanel.closed.emit();\n        }\n        this.autocompletePanel.isOpen = this.overlayAttached = false;\n        if (this.overlayRef && this.overlayRef.hasAttached()) {\n            this.overlayRef.detach();\n            this.closingActionsSubscription.unsubscribe();\n        }\n        // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n        if (!this.componentDestroyed) {\n            // We need to trigger change detection manually, because `fromEvent` doesn't seem to do it at the proper time.  This ensures that the\n            // label is reset when the user clicks outside.\n            this.changeDetectorRef.detectChanges();\n        }\n        if (this.reopenAfterSelection && !overrideReopenFlag) {\n            this.openPanel();\n        }\n        else {\n            // If the panel isn't reopened immediately, we must re-subscribe to the closing actions\n            this.closingActionsSubscription = this.subscribeToClosingActions();\n        }\n    }\n    /**\n     * Handle the focus event\n     */\n    handleFocus() {\n        if (!this.canOpenOnNextFocus) {\n            this.canOpenOnNextFocus = true;\n        }\n        else if (this.canOpen()) {\n            this.previousValue = this.elementRef.nativeElement.value;\n            this.attachOverlay();\n            this.floatLabel(true);\n        }\n    }\n    /**\n     * Handle input into the autocomplete trigger\n     *\n     * @param event - The keyboard event\n     */\n    handleInput(event) {\n        const target = event.target;\n        let value = target.value;\n        // Based on `NumberValueAccessor` from forms\n        if (target.type === 'number') {\n            value = value === '' ? null : parseFloat(value);\n        }\n        // If the input has a placeholder, IE will fire the `input` event on page load, focus and blur, in addition to when the user actually\n        // changed the value. To filter out all of the extra events, we save the value on focus and between `input` events, and we check\n        // whether it changed. See: https://connect.microsoft.com/IE/feedback/details/885747/\n        if (this.previousValue !== value && this.document.activeElement === event.target) {\n            this.previousValue = value;\n            this.onChange(value);\n            if (this.canOpen()) {\n                this.openPanel();\n            }\n        }\n    }\n    /**\n     * Handle keydown events\n     *\n     * @param event - The keyboard event\n     */\n    handleKeydown(event) {\n        const keyCode = event.code;\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE in line with other browsers. By default,\n        // pressing escape on IE will cause it to revert the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === KEYS.ESCAPE.code) {\n            event.preventDefault();\n        }\n        if (this.activeOption && keyCode === KEYS.ENTER.code && this.panelOpen) {\n            this.activeOption.selectViaInteraction();\n            this.resetActiveItem();\n            event.preventDefault();\n        }\n        else if (this.autocompletePanel) {\n            const prevActiveItem = this.autocompletePanel.keyManager.activeItem;\n            const isArrowKey = keyCode === KEYS.UP_ARROW.code || keyCode === KEYS.DOWN_ARROW.code;\n            if (this.panelOpen || keyCode === KEYS.TAB.code) {\n                this.autocompletePanel.keyManager.onKeydown(event);\n            }\n            else if (isArrowKey && this.canOpen()) {\n                this.openPanel();\n            }\n            if (isArrowKey || this.autocompletePanel.keyManager.activeItem !== prevActiveItem) {\n                this.scrollToOption();\n            }\n        }\n    }\n    /**\n     * Open the autocomplete suggestion panel\n     * Subscribe to click event stream and if two conditions described below met,\n     * close the panel.\n     */\n    openPanel() {\n        this.attachOverlay();\n        this.floatLabel();\n    }\n    /**\n     * Register the onChange function\n     *\n     * NOTE: Implemented as part of ControlValueAccessor\n     *\n     * @param fn - The new onChange function\n     */\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    /**\n     * Register the onTouched function\n     *\n     * NOTE: Implemented as part of ControlValueAccessor\n     *\n     * @param fn - The new onTouched function\n     */\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    /**\n     * Set the disabled state\n     *\n     * NOTE: Implemented as part of ControlValueAccessor\n     *\n     * @param isDisabled - Whether the element should be set to disabled\n     */\n    setDisabledState(isDisabled) {\n        this.elementRef.nativeElement.disabled = isDisabled;\n    }\n    /**\n     * Function used to write the value by the model\n     *\n     * NOTE: Implemented as part of ControlValueAccessor\n     *\n     * @param value - The value to write\n     */\n    writeValue(value) {\n        Promise.resolve(null).then(() => this.setTriggerValue(value));\n    }\n    /**\n     * Attach the overlay\n     */\n    attachOverlay() {\n        if (!this.autocompletePanel && isDevMode()) {\n            throw new TsUILibraryError('TsAutocompleteTriggerDirective: Attempting to open an undefined instance of `ts-autocomplete-panel`.');\n        }\n        if (this.overlayRef) {\n            // Update the panel width in case anything has changed\n            this.overlayRef.updateSize({ width: this.getPanelWidth() });\n        }\n        else {\n            this.portal = new TemplatePortal(this.autocompletePanel.template, this.viewContainerRef);\n            this.overlayRef = this.overlay.create(this.getOverlayConfig());\n            // Use the `keydownEvents` in order to take advantage of the overlay event targeting provided by the CDK overlay.\n            this.overlayRef.keydownEvents().subscribe(event => {\n                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                if (event.code === KEYS.ESCAPE.code || (event.code === KEYS.UP_ARROW.code && event.altKey)) {\n                    this.resetActiveItem();\n                    this.closeKeyEventStream.next();\n                }\n            });\n            this.viewportSubscription = this.viewportRuler.change().subscribe(() => {\n                if (this.panelOpen && this.overlayRef) {\n                    this.overlayRef.updateSize({ width: this.getPanelWidth() });\n                }\n            });\n        }\n        if (this.overlayRef && !this.overlayRef.hasAttached()) {\n            this.overlayRef.attach(this.portal);\n            this.closingActionsSubscription = this.subscribeToClosingActions();\n        }\n        const wasOpen = this.panelOpen;\n        this.autocompletePanel.setVisibility();\n        this.autocompletePanel.isOpen = this.overlayAttached = true;\n        // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n            this.autocompletePanel.opened.emit();\n        }\n    }\n    /**\n     * Determine whether the panel can be opened\n     */\n    canOpen() {\n        const element = this.elementRef.nativeElement;\n        return !element.readOnly && !element.disabled && !this.autocompleteDisabled;\n    }\n    /**\n     * Clear any previous selected option and emit a selection change event for this option\n     *\n     * @param skip\n     */\n    clearPreviousSelectedOption(skip) {\n        this.autocompletePanel.options.forEach(option => {\n            // istanbul ignore else\n            // NOTE: Loose check (`!=`) needed for comparing classes\n            // eslint-disable-next-line eqeqeq\n            if (option != skip && option.selected) {\n                option.deselect();\n            }\n        });\n    }\n    /**\n     * Destroy the autocomplete suggestion panel\n     */\n    destroyPanel() {\n        // istanbul ignore else\n        if (this.overlayRef) {\n            this.closePanel();\n            this.overlayRef.dispose();\n            this.overlayRef = null;\n        }\n    }\n    /**\n     * In 'auto' mode, the label will animate down as soon as focus is lost.  This causes the value to jump when selecting an option with the\n     * mouse. This method manually floats the label until the panel can be closed.\n     *\n     * @param shouldAnimate - Whether the label should be animated when it is floated\n     */\n    floatLabel(shouldAnimate = false) {\n        if (this.formField && this.formField.floatLabel === 'auto') {\n            if (shouldAnimate) {\n                this.formField.animateAndLockLabel();\n            }\n            else {\n                this.formField.floatLabel = 'always';\n            }\n            this.manuallyFloatingLabel = true;\n        }\n    }\n    /**\n     * Return the connected element\n     *\n     * @returns The ElementRef\n     */\n    getConnectedElement() {\n        return this.formField ? this.formField.getConnectedOverlayOrigin() : this.elementRef;\n    }\n    /**\n     * Returns the width of the input element, so the panel width can match it\n     */\n    getHostWidth() {\n        return this.getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n    /**\n     * Create a config for an overlay\n     *\n     * @returns The overlay config\n     */\n    getOverlayConfig() {\n        return new OverlayConfig({\n            backdropClass: 'ts-autocomplete__backdrop',\n            direction: 'ltr',\n            hasBackdrop: true,\n            positionStrategy: this.getOverlayPosition(),\n            scrollStrategy: this.scrollStrategy(),\n            width: this.getPanelWidth(),\n        });\n    }\n    /**\n     * Get the overlay position strategy\n     *\n     * @returns The position strategy\n     */\n    getOverlayPosition() {\n        this.positionStrategy = this.overlay.position()\n            .flexibleConnectedTo(this.getConnectedElement())\n            .withFlexibleDimensions(false)\n            .withPush(false)\n            .withPositions([\n            {\n                originX: 'start',\n                originY: 'bottom',\n                overlayX: 'start',\n                overlayY: 'top',\n            },\n            {\n                originX: 'start',\n                originY: 'top',\n                overlayX: 'start',\n                overlayY: 'bottom',\n            },\n        ]);\n        return this.positionStrategy;\n    }\n    /**\n     * Return the panel width\n     *\n     * @returns The width\n     */\n    getPanelWidth() {\n        return this.getHostWidth();\n    }\n    /**\n     * Resets the active item to -1 so arrow events will activate the correct options, or to 0 if the consumer opted into it\n     */\n    resetActiveItem() {\n        this.autocompletePanel.keyManager.setActiveItem(-1);\n    }\n    /**\n     * If the label has been manually elevated, return it to its normal state\n     */\n    resetLabel() {\n        // istanbul ignore else\n        if (this.manuallyFloatingLabel) {\n            this.formField.floatLabel = 'auto';\n            this.manuallyFloatingLabel = false;\n        }\n    }\n    /**\n     * Scroll to an option\n     *\n     * Given that we are not actually focusing active options, we must manually adjust scroll to reveal options below the fold. First, we find\n     * the offset of the option from the top of the panel. If that offset is below the fold, the new scrollTop will be the offset - the panel\n     * height + the option height, so the active option will be just visible at the bottom of the panel. If that offset is above the top of\n     * the visible panel, the new scrollTop will become the offset. If that offset is visible within the panel already, the scrollTop is not\n     * adjusted.\n     */\n    scrollToOption() {\n        const index = this.autocompletePanel.keyManager.activeItemIndex || 0;\n        const labelCount = countGroupLabelsBeforeOption(index, this.autocompletePanel.options, this.autocompletePanel.optionGroups);\n        const newScrollPosition = getOptionScrollPosition(index + labelCount, \n        // FIXME: can this height be dynamic like the TsSelectComponent? https://github.com/GetTerminus/terminus-ui/issues/1153\n        AUTOCOMPLETE_OPTION_HEIGHT, this.autocompletePanel.getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\n        this.autocompletePanel.setScrollTop(newScrollPosition);\n    }\n    /**\n     * Set the value of the trigger\n     *\n     * @param value - The value to set\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    setTriggerValue(value) {\n        const displayFn = this.autocompletePanel && this.autocompletePanel.displayWith;\n        const toDisplay = displayFn ? displayFn(value) : value;\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\n        // The display value can also be the number zero and should not fall back to an empty string.\n        const inputValue = isUnset(toDisplay) ? toDisplay : '';\n        // If it is used within a {@link TsFormFieldComponent}, we should set it through the property so it can go through change detection\n        if (this.formField) {\n            this.formField.control.value = inputValue;\n        }\n        else {\n            this.elementRef.nativeElement.value = inputValue;\n        }\n    }\n    /**\n     * This method closes the panel, and if a value is specified, also sets the associated control to that value.\n     * It will also mark the control as dirty if this interaction stemmed from the user.\n     *\n     * @param event - The event containing the option\n     */\n    setValueAndClose(event) {\n        this.clearPreviousSelectedOption(event.source);\n        this.setTriggerValue(event.source.value);\n        this.onChange(event.source.value);\n        this.elementRef.nativeElement.focus();\n        this.autocompletePanel.emitSelectEvent(event.source);\n        this.closePanel();\n    }\n    /**\n     * This method listens to a stream of panel closing actions and resets the stream every time the option list changes\n     *\n     * @returns The subscription\n     */\n    subscribeToClosingActions() {\n        const firstStable = this.ngZone.onStable.asObservable().pipe(take(1));\n        const optionChanges = this.autocompletePanel.options.changes.pipe(\n        // TODO: Refactor deprecation\n        // eslint-disable-next-line deprecation/deprecation\n        tap(() => this.positionStrategy.reapplyLastPosition()), \n        // Defer emitting to the stream until the next tick, because changing bindings in here will cause \"changed after checked\" errors.\n        delay(0));\n        // When the zone is stable initially, and when the option list changes...\n        // eslint-disable-next-line deprecation/deprecation\n        return merge(firstStable, optionChanges)\n            .pipe(\n        // Create a new stream of panelClosingActions, replacing any previous streams that were created, and flatten it so our stream only\n        // emits closing events...\n        // TODO: Refactor deprecation\n        // eslint-disable-next-line deprecation/deprecation\n        switchMap(() => {\n            this.resetActiveItem();\n            this.autocompletePanel.setVisibility();\n            return this.panelClosingActions;\n        }), take(1), untilComponentDestroyed(this))\n            // Set the value, close the panel, and complete.\n            .subscribe((event) => {\n            if (event && event.source && event.source.value !== undefined) {\n                this.setValueAndClose(event);\n            }\n        });\n    }\n};\nTsAutocompleteTriggerDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Overlay },\n    { type: ViewContainerRef },\n    { type: NgZone },\n    { type: ChangeDetectorRef },\n    { type: TsDocumentService },\n    { type: ViewportRuler },\n    { type: undefined, decorators: [{ type: Inject, args: [TS_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },\n    { type: TsFormFieldComponent, decorators: [{ type: Optional }, { type: Host }] }\n];\n__decorate([\n    Input('autocomplete'),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteTriggerDirective.prototype, \"autocompleteAttribute\", void 0);\n__decorate([\n    Input('tsAutocompleteDisabled'),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [Boolean])\n], TsAutocompleteTriggerDirective.prototype, \"autocompleteDisabled\", null);\n__decorate([\n    Input('tsAutocompleteTrigger'),\n    __metadata(\"design:type\", TsAutocompletePanelComponent)\n], TsAutocompleteTriggerDirective.prototype, \"autocompletePanel\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [Boolean])\n], TsAutocompleteTriggerDirective.prototype, \"reopenAfterSelection\", null);\nTsAutocompleteTriggerDirective = TsAutocompleteTriggerDirective_1 = __decorate([\n    Directive({\n        selector: '[tsAutocompleteTrigger]',\n        host: {\n            'class': 'ts-autocomplete-trigger qa-autocomplete-trigger',\n            '[attr.autocomplete]': 'autocompleteAttribute',\n            '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n            '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n            '[attr.aria-activedescendant]': 'activeOption?.id',\n            '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n            '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocompletePanel?.id',\n            // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n            // a little earlier. This avoids issues where IE delays the focusing of the input.\n            '(focusin)': 'handleFocus()',\n            '(blur)': 'onTouched()',\n            '(input)': 'handleInput($event)',\n            '(keydown)': 'handleKeydown($event)',\n        },\n        providers: [\n            {\n                provide: NG_VALUE_ACCESSOR,\n                // eslint-disable-next-line deprecation/deprecation\n                useExisting: forwardRef(() => TsAutocompleteTriggerDirective_1),\n                multi: true,\n            },\n        ],\n        exportAs: 'tsAutocompleteTrigger',\n    }),\n    __param(7, Inject(TS_AUTOCOMPLETE_SCROLL_STRATEGY)),\n    __param(8, Optional()), __param(8, Host()),\n    __metadata(\"design:paramtypes\", [ElementRef,\n        Overlay,\n        ViewContainerRef,\n        NgZone,\n        ChangeDetectorRef,\n        TsDocumentService,\n        ViewportRuler, Object, TsFormFieldComponent])\n], TsAutocompleteTriggerDirective);\n\nvar TsAutocompleteComponent_1;\nclass TsAutocompleteSelectedEvent extends MatAutocompleteSelectedEvent {\n}\n// Unique ID for each instance\n// @internal\nlet nextUniqueId$2 = 0;\nconst DEFAULT_MINIMUM_CHARACTER_COUNT = 2;\nconst DEFAULT_DEBOUNCE_DELAY = 200;\n/**\n * The event object that is emitted when the select value has changed\n */\nclass TsAutocompleteChange {\n    constructor(\n    // eslint-disable-next-line deprecation/deprecation\n    source, value) {\n        this.source = source;\n        this.value = value;\n    }\n}\n/**\n * The autocomplete UI Component\n *\n * @deprecated Please use `TsSelectionListComponent`\n *\n * @example\n * <ts-autocomplete\n *              [allowMultiple]=\"allowMultiple\"\n *              [displayFormatter]=\"formatterFunc\"\n *              [valueComparator]=\"comparatorFunc\"\n *              debounceDelay=\"300\"\n *              displayWith=\"(v) => v.name\"\n *              hint=\"Begin typing to search..\"\n *              [isDisabled]=\"isDisabled\"\n *              label=\"Select options:\"\n *              name=\"product selections\"\n *              options=\"[{}, {}, ...]\"\n *              [showProgress]=\"inProgress\"\n *              theme=\"primary\"\n *              (closed)=\"panelWasClosed($event)\"\n *              (opened)=\"panelWasOpened($event)\"\n *              (optionSelected)=\"mySelected($event)\"\n *              (optionRemoved)=\"myRemoved($event)\"\n *              (query)=\"myQuery($event)\"\n *              (selection)=\"mySelection($event)\"\n * ></ts-autocomplete>\n *\n * <example-url>https://getterminus.github.io/ui-demos-release/components/autocomplete</example-url>\n */\nlet TsAutocompleteComponent = TsAutocompleteComponent_1 = class TsAutocompleteComponent {\n    constructor(changeDetectorRef, documentService, elementRef, ngControl) {\n        this.changeDetectorRef = changeDetectorRef;\n        this.documentService = documentService;\n        this.elementRef = elementRef;\n        this.ngControl = ngControl;\n        /**\n         * Give the component an explicit name\n         *\n         * @internal\n         */\n        this.componentName = 'TsAutocompleteComponent';\n        /**\n         * Define the FormControl\n         *\n         * @internal\n         */\n        this.autocompleteFormControl = new FormControl([]);\n        /**\n         * Subject used to alert the parent {@link TsFormFieldComponent} when the label gap should be recalculated\n         *\n         * Implemented as part of TsFormFieldControl.\n         *\n         * @internal\n         */\n        this.labelChanges = new Subject();\n        /**\n         * The IDs of child options to be passed to the aria-owns attribute.\n         *\n         * @internal\n         */\n        this.optionIds = '';\n        /**\n         * Whether or not the overlay panel is open\n         */\n        this.panelOpen = false;\n        /**\n         * Since the {@link TsFormFieldComponent} is inside this template, we cannot use a provider to pass this component instance to the form\n         * field. Instead, we pass it manually through the template with this reference.\n         *\n         * @internal\n         */\n        this.selfReference = this;\n        /*\n         * Implemented as part of {@link TsFormFieldControl}\n         *\n         * @internal\n         */\n        this.stateChanges = new Subject();\n        /**\n         * Define the default component ID\n         *\n         * @internal\n         */\n        this.uid = `ts-autocomplete-${nextUniqueId$2++}`;\n        /**\n         * Management of the query string\n         *\n         * @internal\n         */\n        this.querySubject = new BehaviorSubject('');\n        /**\n         * Define if multiple selections are allowed\n         */\n        this.allowMultiple = false;\n        /**\n         * Define if should allow duplicate selections\n         */\n        this.allowDuplicateSelections = false;\n        /**\n         * Define if the panel should reopen after a selection is made\n         *\n         * NOTE: Though it is technically 're-opening', it happens fast enough so that it doesn't appear to close at all.\n         */\n        this.reopenAfterSelection = false;\n        this._debounceDelay = DEFAULT_DEBOUNCE_DELAY;\n        /**\n         * Define if the required marker should be hidden\n         */\n        this.hideRequiredMarker = false;\n        this._id = this.uid;\n        /**\n         * Define if the control should be disabled\n         */\n        this.isDisabled = false;\n        this._isRequired = false;\n        this._minimumCharacters = DEFAULT_MINIMUM_CHARACTER_COUNT;\n        /**\n         * Define if the input should currently be showing a progress spinner\n         */\n        this.showProgress = false;\n        /**\n         * Define the component theme\n         */\n        this.theme = 'primary';\n        /**\n         * Define if validation messages should be shown immediately or on blur\n         */\n        this.validateOnChange = false;\n        /**\n         * Define the formatter for the selected items.\n         *\n         * @param v\n         */\n        this.displayFormatter = v => v;\n        /**\n         * Define the comparator for the values of the options\n         *\n         * @param a\n         * @param b\n         */\n        this.valueComparator = (a, b) => a === b;\n        /**\n         * Event for when the panel is closed\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event for when a duplicate selection is made\n         */\n        this.duplicateSelection = new EventEmitter();\n        /**\n         * Event for when the panel is opened\n         */\n        this.opened = new EventEmitter();\n        /**\n         * Emit the selected chip\n         */\n        this.optionSelected = new EventEmitter();\n        /**\n         * Event for when an option is removed\n         */\n        this.optionDeselected = new EventEmitter();\n        /**\n         * Emit the current selection\n         */\n        this.selection = new EventEmitter();\n        /**\n         * Emit the query string\n         */\n        this.query = new EventEmitter();\n        /**\n         * Event for when the query has changed\n         */\n        this.queryChange = new EventEmitter();\n        /**\n         * Event for when the selections change\n         */\n        this.selectionChange = new EventEmitter();\n        /**\n         * Event that emits whenever the raw value of the select changes. This is here primarily\n         * to facilitate the two-way binding for the `value` input.\n         *\n         * Needed for {@link TsFormFieldComponent}.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Stub in onChange\n         *\n         * @internal\n         *\n         * Needed for ControlValueAccessor (View -> model callback called when value changes)\n         */\n        // istanbul ignore next\n        this.onChange = () => { };\n        /**\n         * Stub in onTouched\n         *\n         * @internal\n         *\n         * Needed for ControlValueAccessor (View -> model callback called when select has been touched)\n         */\n        // istanbul ignore next\n        this.onTouched = () => { };\n        this.document = this.documentService.document;\n        // This is the assigned FormControl or NgModel\n        // istanbul ignore else\n        if (this.ngControl) {\n            // Note: we provide the value accessor through here, instead of the `providers` to avoid running into a circular import.\n            this.ngControl.valueAccessor = this;\n        }\n    }\n    /**\n     * Whether the select has a value\n     */\n    get empty() {\n        return !this.autocompleteFormControl.value.length;\n    }\n    /**\n     * Whether the input has focus\n     */\n    get focused() {\n        const el = this.inputElement && this.inputElement.nativeElement;\n        return (this.document.activeElement === el) || this.panelOpen;\n    }\n    /**\n     * Determine if the label should float\n     */\n    get shouldLabelFloat() {\n        return this.focused || !this.empty;\n    }\n    /**\n     * Define a debounce delay for the query stream\n     *\n     * @param value\n     */\n    set debounceDelay(value) {\n        this._debounceDelay = coerceNumberProperty(value, DEFAULT_DEBOUNCE_DELAY);\n    }\n    get debounceDelay() {\n        return this._debounceDelay;\n    }\n    /**\n     * Define a hint for the input\n     *\n     * @param value\n     */\n    set hint(value) {\n        this._hint = value;\n    }\n    get hint() {\n        return this._hint;\n    }\n    /**\n     * Define an ID for the component\n     *\n     * @param value\n     */\n    set id(value) {\n        this._id = value || this.uid;\n    }\n    get id() {\n        return this._id;\n    }\n    /**\n     * Define if the control is required\n     *\n     * @param value\n     */\n    set isRequired(value) {\n        this._isRequired = value;\n    }\n    get isRequired() {\n        const ctrl = this.ngControl && this.ngControl.control;\n        const requiredFormControl = !!ctrl && hasRequiredControl(ctrl);\n        return this._isRequired || requiredFormControl;\n    }\n    /**\n     * Define a minimum character count for queries\n     *\n     * @param value\n     */\n    set minimumCharacters(value) {\n        this._minimumCharacters = coerceNumberProperty(value, DEFAULT_MINIMUM_CHARACTER_COUNT);\n    }\n    get minimumCharacters() {\n        return this._minimumCharacters;\n    }\n    /**\n     * Value of the select control\n     *\n     * @param newValue\n     */\n    set value(newValue) {\n        if (newValue !== this._value) {\n            this._value = newValue;\n        }\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Seed initial control values\n     */\n    ngOnInit() {\n        // Seed the control value\n        // NOTE: When the consumer is using an ngModel, the value is not set on the first cycle.\n        // We need to push it to the next event loop. When using a FormControl the value is there on the first run.\n        // eslint-disable-next-line dot-notation\n        if (this.ngControl && this.ngControl['form']) {\n            // istanbul ignore else\n            if (this.ngControl.value && !isArray(this.ngControl.value)) {\n                throw Error('form control values must be an array of values');\n            }\n            else if (this.ngControl.value) {\n                this.autocompleteFormControl.setValue(this.ngControl.value);\n                if (!this.allowMultiple) {\n                    this.searchQuery = this.displayFormatter(this.ngControl.value[0]);\n                }\n            }\n            // Support dynamic form control updates\n            // istanbul ignore else\n            if (this.ngControl.valueChanges) {\n                this.ngControl.valueChanges\n                    .pipe(untilComponentDestroyed(this))\n                    .subscribe(newValue => {\n                    // istanbul ignore else\n                    if (newValue) {\n                        this.autocompleteFormControl.setValue(newValue, { emitEvent: false });\n                        if (!this.allowMultiple) {\n                            this.searchQuery = this.displayFormatter(newValue[0]);\n                        }\n                    }\n                });\n            }\n        }\n        else {\n            // HACK: Wait until the next detection cycle to set the value from an ngModel.\n            // NOTE: Using CDR.detectChanges causes errors in children that expect TsOptionComponent to exist.\n            setTimeout(() => {\n                // istanbul ignore else\n                if (this.ngControl && this.ngControl.value) {\n                    if (!isArray(this.ngControl.value)) {\n                        throw Error('ngModel must be an array of values');\n                    }\n                    this.autocompleteFormControl.setValue(this.ngControl.value);\n                    if (!this.allowMultiple) {\n                        this.searchQuery = this.displayFormatter(this.ngControl.value[0]);\n                    }\n                }\n            });\n        }\n        // Take a stream of query changes\n        this.querySubject.pipe(untilComponentDestroyed(this), \n        // Debounce the query changes\n        debounceTime(this.debounceDelay), \n        // If the query is shorter than allowed, convert to an empty string\n        // eslint-disable-next-line deprecation/deprecation\n        switchMap(query => of((query && (query.length >= this.minimumCharacters)) ? query : '')), \n        // Only allow a query through if it is different from the previous query\n        distinctUntilChanged()).subscribe((query) => {\n            // NOTE: When an option is selected, the full string value comes through this stream. We are checking the stream value against the\n            // input element value to verify we are sending a query rather than a selected option.\n            const inputValue = this.inputElement.nativeElement.value;\n            const queryIsValid = (query === inputValue) || (query === '');\n            this.queryChange.emit(queryIsValid ? query : inputValue);\n            if (!this.panelOpen) {\n                this.open();\n            }\n        });\n        // Propagate changes from form control\n        this.autocompleteFormControl.valueChanges.pipe(untilComponentDestroyed(this)).subscribe(v => {\n            this.propagateChanges();\n        });\n    }\n    /**\n     * Subscribe to the querySubject and pass values to the query emitter\n     *\n     * NOTE: When an option is selected, the full selected value is piped through this stream\n     * somehow. Have not figured out why. Best guess is it's something due to the `matAutocomplete`\n     * directive. For now, we are filtering out anything that is not a string.\n     */\n    ngAfterViewInit() {\n        // Take a stream of query changes\n        this.querySubject.pipe(untilComponentDestroyed(this), filter(v => (typeof v === 'string') && v.length >= this.minimumCharacters), \n        // Debounce the query changes\n        debounceTime(this.debounceDelay), \n        // Only allow a query through if it is different from the previous query\n        distinctUntilChanged()).subscribe((query) => {\n            this.query.next(query);\n        });\n    }\n    /**\n     * Needed for untilComponentDestroyed\n     */\n    ngOnDestroy() { }\n    /**\n     * Close the overlay panel\n     */\n    close() {\n        if (this.autocompleteTrigger.panelOpen) {\n            this.panelOpen = false;\n            this.changeDetectorRef.markForCheck();\n            this.onTouched();\n            this.updateValueAndValidity();\n            // Alert the consumer\n            this.closed.emit();\n        }\n    }\n    /**\n     * Set up a key manager to listen to keyboard events on the overlay panel\n     */\n    initKeyManager() {\n        // We need to initialize with wrapping turned on\n        this.keyManager = new ActiveDescendantKeyManager(this.options)\n            .withTypeAhead()\n            .withVerticalOrientation()\n            .withHorizontalOrientation('ltr')\n            .withWrap();\n    }\n    /**\n     * Focus the text input\n     *\n     * @internal\n     */\n    focus() {\n        this.inputElement.nativeElement.focus();\n    }\n    /**\n     * Open the overlay panel\n     */\n    open() {\n        if (this.isDisabled || !this.options || !this.options.length || this.panelOpen) {\n            return;\n        }\n        this.opened.emit();\n    }\n    /**\n     * Emit a change event to set the model value\n     *\n     */\n    propagateChanges() {\n        const valueToEmit = this.autocompleteFormControl.value;\n        this.value = valueToEmit;\n        this.valueChange.emit(valueToEmit);\n        this.onChange(valueToEmit);\n        this.selectionChange.emit(new TsAutocompleteChange(this, valueToEmit));\n        this.changeDetectorRef.markForCheck();\n    }\n    /**\n     * Call FormControl updateValueAndValidity function to ensure value and valid status get updated.\n     */\n    updateValueAndValidity() {\n        if (this.ngControl && this.ngControl.control) {\n            this.ngControl.control.updateValueAndValidity();\n        }\n    }\n    /**\n     * Sets the select's value. Part of the ControlValueAccessor interface required to integrate with Angular's core forms API.\n     *\n     * NOTE: Currently we are not using this, but it still must be present since this component is acting as a CVA.\n     *\n     * @internal\n     *\n     * @param value - New value to be written to the model\n     */\n    writeValue(value) { }\n    /**\n     * Save a callback function to be invoked when the select's value changes from user input.\n     * Part of the ControlValueAccessor interface required to integrate with Angular's core forms API.\n     *\n     * @internal\n     *\n     * @param fn - Callback to be triggered when the value changes\n     */\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    /**\n     * Save a callback function to be invoked when the select is blurred by the user.\n     * Part of the ControlValueAccessor interface required to integrate with Angular's core forms API.\n     *\n     * @internal\n     *\n     * @param fn - Callback to be triggered when the component has been touched\n     */\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    /**\n     * Disables the select.\n     * Part of the ControlValueAccessor interface required to integrate with Angular's core forms API.\n     *\n     * @param isDisabled - If the component is disabled\n     */\n    setDisabledState(isDisabled) {\n        this.isDisabled = isDisabled;\n        this.changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n    }\n    /**\n     * Ensure the correct element gets focus when the primary container is clicked.\n     *\n     * @internal\n     *\n     * Implemented as part of TsFormFieldControl.\n     */\n    onContainerClick() {\n        this.focus();\n    }\n    /**\n     * Close the dropdown and reset the query when the user leaves the input\n     *\n     * @param event - The keyboard or mouse event\n     */\n    handleInputBlur(event) {\n        // FIXME: cannot use dot syntax here since 'relatedTarget' doesn't exist on a KeyboardEvent\n        // eslint-disable-next-line dot-notation\n        const hasRelatedTarget = !!(event && event['relatedTarget']);\n        // eslint-disable-next-line dot-notation\n        const hasNodeName = !!(hasRelatedTarget && event['relatedTarget'].nodeName);\n        if (hasRelatedTarget && hasNodeName) {\n            // If the blur event comes from the user clicking an option, `event.relatedTarget.nodeName`\n            // will be `TS-OPTION`.\n            // istanbul ignore else\n            // NOTE: TypeScript warns `Property 'nodeName' does not exist on type 'EventTarget'.`\n            // eslint-disable-next-line dot-notation\n            if (event['relatedTarget'].nodeName !== 'TS-OPTION') {\n                this.resetAutocompleteQuery();\n            }\n        }\n        else if (this.autocompleteTrigger.panelOpen) {\n            this.close();\n            this.autocompleteTrigger.closePanel(true);\n        }\n        // Mark this control as 'touched' to trigger any validations needed on blur\n        this.onTouched();\n        this.updateValueAndValidity();\n    }\n    /**\n     * Reset input\n     */\n    resetAutocompleteQuery() {\n        // istanbul ignore else\n        if (!this.keyManager) {\n            this.initKeyManager();\n        }\n        // Deselect the option from the key manager\n        this.keyManager.updateActiveItem(-1);\n        this.inputElement.nativeElement.value = '';\n    }\n    /**\n     * Select an item\n     *\n     * @param selection - The item to select\n     */\n    autocompleteSelectItem(selection) {\n        const isDuplicate = (this.autocompleteFormControl.value || []).findIndex(o => this.valueComparator(o, selection.option.value)) >= 0;\n        // istanbul ignore else\n        if (isDuplicate) {\n            this.duplicateSelection.emit(new TsAutocompleteChange(this, selection.option.value));\n        }\n        // Stop the flow if the selection already exists in the array and duplicates aren't allowed\n        if (!this.allowDuplicateSelections && isDuplicate) {\n            return;\n        }\n        if (this.allowMultiple) {\n            // If supporting multiple selections, reset the input text value as long as the panel should NOT reopen\n            // istanbul ignore else\n            if (!this.reopenAfterSelection) {\n                this.close();\n                this.resetAutocompleteQuery();\n            }\n            // Update the form control\n            const options = (this.autocompleteFormControl.value || []).concat(selection.option.value);\n            this.autocompleteFormControl.setValue(options);\n        }\n        else {\n            // Update the form control\n            this.autocompleteFormControl.setValue([selection.option.value]);\n            // In single selection mode, set the query input to the selection so the user can see what was selected\n            this.inputElement.nativeElement.value = selection.option.viewValue;\n        }\n        // Update the panel position in case the addition of a chip causes the select height to change\n        // istanbul ignore else\n        if (this.autocompleteTrigger.overlayRef) {\n            this.autocompleteTrigger.overlayRef.updatePosition();\n            this.changeDetectorRef.detectChanges();\n        }\n        // Notify consumers about changes\n        this.optionSelected.emit(new TsAutocompleteChange(this, selection.option.value));\n        this.selectionChange.emit(new TsAutocompleteChange(this, this.autocompleteFormControl.value));\n    }\n    /**\n     * Chip component emit a focusInput event, autocomplete puts focus on input field.\n     */\n    focusInput() {\n        this.focus();\n    }\n    /**\n     * Deselect an item\n     *\n     * @param option - The value of the item to remove\n     */\n    autocompleteDeselectItem(option) {\n        // Remove the selection from the array of selections\n        const options = (this.autocompleteFormControl.value || []).filter(opt => !this.valueComparator(opt, option.value));\n        // Update the form control\n        this.autocompleteFormControl.setValue(options);\n        // If the only chip was removed, re-focus the input\n        // istanbul ignore else\n        if (options.length === 0) {\n            this.focus();\n        }\n        // HACK: For some reason, triggering change detection works in the selection method above, but not here. Same issue seems present in\n        // TsOptionComponent where `setActiveStyles` works by calling the CDR but `setInactiveStyles` required a timeout.\n        setTimeout(() => {\n            // Update the panel position in case the removal of a chip causes the select height to change\n            if (this.autocompleteTrigger.overlayRef) {\n                this.autocompleteTrigger.overlayRef.updatePosition();\n            }\n        });\n        // Notify consumers about changes\n        this.optionDeselected.emit(new TsAutocompleteChange(this, option));\n        this.selectionChange.emit(new TsAutocompleteChange(this, options));\n    }\n    /**\n     * Function for tracking for-loops changes\n     *\n     * @internal\n     *\n     * @param index - The item index\n     * @returns The unique ID\n     */\n    trackByFn(index) {\n        return index;\n    }\n};\nTsAutocompleteComponent.ctorParameters = () => [\n    { type: ChangeDetectorRef },\n    { type: TsDocumentService },\n    { type: ElementRef },\n    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] }\n];\n__decorate([\n    ViewChild('auto', { static: true }),\n    __metadata(\"design:type\", TsAutocompletePanelComponent)\n], TsAutocompleteComponent.prototype, \"autocompletePanel\", void 0);\n__decorate([\n    ViewChild(TsAutocompleteTriggerDirective),\n    __metadata(\"design:type\", TsAutocompleteTriggerDirective)\n], TsAutocompleteComponent.prototype, \"autocompleteTrigger\", void 0);\n__decorate([\n    ViewChild('chipCollection'),\n    __metadata(\"design:type\", TsChipCollectionComponent)\n], TsAutocompleteComponent.prototype, \"chipCollection\", void 0);\n__decorate([\n    ViewChild('input'),\n    __metadata(\"design:type\", ElementRef)\n], TsAutocompleteComponent.prototype, \"inputElement\", void 0);\n__decorate([\n    ContentChildren(TsOptionComponent, { descendants: true }),\n    __metadata(\"design:type\", QueryList)\n], TsAutocompleteComponent.prototype, \"options\", void 0);\n__decorate([\n    ContentChildren(TsOptgroupComponent),\n    __metadata(\"design:type\", QueryList)\n], TsAutocompleteComponent.prototype, \"optionGroups\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"allowMultiple\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"allowDuplicateSelections\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"reopenAfterSelection\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], TsAutocompleteComponent.prototype, \"debounceDelay\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"hideRequiredMarker\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsAutocompleteComponent.prototype, \"hint\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsAutocompleteComponent.prototype, \"id\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"isDisabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [Boolean])\n], TsAutocompleteComponent.prototype, \"isRequired\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], TsAutocompleteComponent.prototype, \"minimumCharacters\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"showProgress\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsAutocompleteComponent.prototype, \"theme\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"validateOnChange\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String),\n    __metadata(\"design:paramtypes\", [String])\n], TsAutocompleteComponent.prototype, \"value\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsAutocompleteComponent.prototype, \"label\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsAutocompleteComponent.prototype, \"name\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Function)\n], TsAutocompleteComponent.prototype, \"displayFormatter\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Function)\n], TsAutocompleteComponent.prototype, \"valueComparator\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"closed\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"duplicateSelection\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"opened\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"optionSelected\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"optionDeselected\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"selection\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"query\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"queryChange\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"selectionChange\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], TsAutocompleteComponent.prototype, \"valueChange\", void 0);\nTsAutocompleteComponent = TsAutocompleteComponent_1 = __decorate([\n    Component({\n        selector: 'ts-autocomplete',\n        template: \"<ts-form-field\\n  [validateOnChange]=\\\"validateOnChange\\\"\\n  [control]=\\\"selfReference\\\"\\n  [hideRequiredMarker]=\\\"hideRequiredMarker\\\"\\n  [hint]=\\\"hint\\\"\\n  [id]=\\\"id\\\"\\n  [theme]=\\\"theme\\\"\\n  cdk-overlay-origin\\n  #origin=\\\"cdkOverlayOrigin\\\"\\n>\\n  <ts-label *ngIf=\\\"label\\\">\\n    {{ label }}\\n  </ts-label>\\n\\n  <div class=\\\"ts-autocomplete__input-wrap\\\">\\n\\n    <ng-container *ngIf=\\\"allowMultiple\\\">\\n      <ts-chip-collection\\n        [allowMultipleSelections]=\\\"true\\\"\\n        [isDisabled]=\\\"false\\\"\\n        [isReadonly]=\\\"false\\\"\\n        (tabUpdateFocus)=\\\"focusInput()\\\"\\n        #chipCollection=\\\"tsChipCollection\\\"\\n      >\\n        <ts-chip\\n          *ngFor=\\\"let chip of autocompleteFormControl.value; trackBy: trackByFn\\\"\\n          [isRemovable]=\\\"true\\\"\\n          [isDisabled]=\\\"isDisabled\\\"\\n          [value]=\\\"chip\\\"\\n          (remove)=\\\"autocompleteDeselectItem($event.chip)\\\"\\n        >{{ displayFormatter(chip) }}</ts-chip>\\n\\n        <input\\n          class=\\\"ts-autocomplete__input qa-select-autocomplete-input\\\"\\n          [tsAutocompleteTrigger]=\\\"auto\\\"\\n          [reopenAfterSelection]=\\\"reopenAfterSelection\\\"\\n          [attr.id]=\\\"id\\\"\\n          [(ngModel)]=\\\"searchQuery\\\"\\n          [readonly]=\\\"isDisabled ? 'true' : null\\\"\\n          (ngModelChange)=\\\"querySubject.next($event)\\\"\\n          (blur)=\\\"handleInputBlur($event)\\\"\\n          #input\\n        />\\n      </ts-chip-collection>\\n      <ng-template *ngTemplateOutlet=\\\"spinnerTemplate\\\"></ng-template>\\n    </ng-container>\\n\\n    <ng-container *ngIf=\\\"!allowMultiple\\\">\\n      <input\\n        class=\\\"ts-autocomplete__input qa-select-autocomplete-input\\\"\\n        [tsAutocompleteTrigger]=\\\"auto\\\"\\n        [attr.id]=\\\"id\\\"\\n        [readonly]=\\\"isDisabled ? 'true' : null\\\"\\n        [(ngModel)]=\\\"searchQuery\\\"\\n        [value]=\\\"searchQuery\\\"\\n        (ngModelChange)=\\\"querySubject.next($event)\\\"\\n        (blur)=\\\"handleInputBlur($event)\\\"\\n        #input\\n      />\\n\\n      <ng-template *ngTemplateOutlet=\\\"spinnerTemplate\\\"></ng-template>\\n    </ng-container>\\n\\n  </div>\\n</ts-form-field>\\n\\n\\n<ts-autocomplete-panel\\n  class=\\\"ts-autocomplete\\\"\\n  #auto=\\\"tsAutocompletePanel\\\"\\n  [id]=\\\"id + '-panel'\\\"\\n  [options]=\\\"options\\\"\\n  [optionGroups]=\\\"optionGroups\\\"\\n  (optionSelected)=\\\"autocompleteSelectItem($event)\\\"\\n>\\n  <!-- Outlet for options passed in by consumer -->\\n  <ng-template *ngTemplateOutlet=\\\"contentTemplate\\\"></ng-template>\\n</ts-autocomplete-panel>\\n\\n\\n<ng-template #contentTemplate>\\n  <ng-content></ng-content>\\n</ng-template>\\n\\n<ng-template #spinnerTemplate>\\n  <mat-progress-spinner\\n    *ngIf=\\\"showProgress\\\"\\n    class=\\\"c-autocomplete__spinner c-autocomplete__spinner--{{theme}} qa-select-autocomplete-spinner\\\"\\n    [ngClass]=\\\"{'c-autocomplete__spinner--active': showProgress}\\\"\\n    diameter=\\\"21\\\"\\n    mode=\\\"indeterminate\\\"\\n  ></mat-progress-spinner>\\n</ng-template>\\n\",\n        host: {\n            'class': 'ts-autocomplete',\n            '[class.ts-autocomplete--required]': 'isRequired',\n            '[class.ts-autocomplete--disabled]': 'isDisabled',\n            '[attr.aria-owns]': 'panelOpen ? optionIds : null',\n            '[attr.aria-required]': 'isRequired.toString()',\n            '[attr.aria-multiselectable]': 'allowMultiple',\n        },\n        providers: [\n            {\n                provide: TsFormFieldControl,\n                // eslint-disable-next-line deprecation/deprecation\n                useExisting: TsAutocompleteComponent_1,\n            },\n            {\n                provide: TS_OPTION_PARENT_COMPONENT,\n                // eslint-disable-next-line deprecation/deprecation\n                useExisting: TsAutocompleteComponent_1,\n            },\n        ],\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        encapsulation: ViewEncapsulation.None,\n        exportAs: 'tsAutocomplete',\n        styles: [\":root{--swift-ease-out-duration:var(--ts-animation-time-duration-400);--swift-ease-out-timing-function:cubic-bezier(.25, .8, .25, 1);--swift-ease-in-duration:var(--ts-animation-time-duration-300);--swift-ease-in-timing-function:cubic-bezier(.55, 0, .55, .2)}.cdk-drag{position:relative}.cdk-drag:not(.cdk-drag-placeholder){transition:transform 250ms cubic-bezier(0,0,.2,1)}.cdk-drag .cdk-drag-handle{color:#cecdd1;cursor:ns-resize;position:absolute;right:8px}.cdk-drag.cdk-drag-preview{--shadow:0 5px 5px -3px rgba(0, 0, 0, .2),0 8px 10px 1px rgba(0, 0, 0, .14),0 3px 14px 2px rgba(0, 0, 0, .12);background-color:#fafafa;box-shadow:var(--shadow);min-height:50px;padding:0!important}.cdk-drag.cdk-drag-preview .c-checkbox{margin-left:16px}.cdk-drag-placeholder{--drop-bg:#cce8d5;--drop-border:#7fd09c;background:var(--drop-bg);border:2px dotted var(--drop-border);cursor:ns-resize;transition:transform 250ms cubic-bezier(0,0,.2,1)}.ts-autocomplete__input-wrap--hidden,.u-visually-hidden{border:0;-webkit-clip-path:rect(0,0,0,0);clip-path:rect(0,0,0,0);display:block;height:1px;margin:-1px;overflow:hidden;padding:0;pointer-events:none;position:absolute;visibility:hidden;width:1px}.ts-autocomplete__input-wrap .ts-chip{font-size:14px}.ts-autocomplete__input{background:0 0;border:none;color:currentColor;display:inline-block;flex:1 0 10px;font:inherit;max-width:100%;outline:0;padding:0;text-align:inherit;vertical-align:bottom;width:100%}.ts-autocomplete__input:-moz-ui-invalid{box-shadow:none}.cdk-overlay-container .ts-autocomplete__backdrop{background:0 0}\"]\n    }),\n    __param(3, Self()), __param(3, Optional()),\n    __metadata(\"design:paramtypes\", [ChangeDetectorRef,\n        TsDocumentService,\n        ElementRef,\n        NgControl])\n], TsAutocompleteComponent);\n\n/* eslint-disable deprecation/deprecation */\n// @deprecated Please use `TsSelectionListModule`\nlet TsAutocompleteModule = class TsAutocompleteModule {\n};\nTsAutocompleteModule = __decorate([\n    NgModule({\n        imports: [\n            CommonModule,\n            FormsModule,\n            ReactiveFormsModule,\n            FlexLayoutModule,\n            MatInputModule,\n            MatProgressSpinnerModule,\n            MatRippleModule,\n            OverlayModule,\n            TsCheckboxModule,\n            TsChipModule,\n            TsIconModule,\n            TsFormFieldModule,\n            TsOptionModule,\n            TsValidationMessagesModule,\n            TsInputModule,\n        ],\n        providers: [TS_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n        declarations: [\n            TsAutocompleteComponent,\n            TsAutocompletePanelComponent,\n            TsAutocompleteTriggerDirective,\n        ],\n        exports: [\n            TsAutocompleteComponent,\n            TsAutocompletePanelComponent,\n            TsAutocompleteTriggerDirective,\n        ],\n    })\n], TsAutocompleteModule);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, TS_AUTOCOMPLETE_SCROLL_STRATEGY, TS_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, TS_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, TsAutocompleteChange, TsAutocompleteComponent, TsAutocompleteModule, TsAutocompletePanelComponent, TsAutocompletePanelSelectedEvent, TsAutocompleteSelectedEvent, TsAutocompleteTriggerDirective };\n//# sourceMappingURL=terminus-ui-autocomplete.js.map\n","<ts-form-field\n  [validateOnChange]=\"validateOnChange\"\n  [control]=\"selfReference\"\n  [hideRequiredMarker]=\"hideRequiredMarker\"\n  [hint]=\"hint\"\n  [id]=\"id\"\n  [theme]=\"theme\"\n  cdk-overlay-origin\n  #origin=\"cdkOverlayOrigin\"\n>\n  <ts-label *ngIf=\"label\">\n    {{ label }}\n  </ts-label>\n\n  <div class=\"ts-autocomplete__input-wrap\">\n\n    <ng-container *ngIf=\"allowMultiple\">\n      <ts-chip-collection\n        [allowMultipleSelections]=\"true\"\n        [isDisabled]=\"false\"\n        [isReadonly]=\"false\"\n        (tabUpdateFocus)=\"focusInput()\"\n        #chipCollection=\"tsChipCollection\"\n      >\n        <ts-chip\n          *ngFor=\"let chip of autocompleteFormControl.value; trackBy: trackByFn\"\n          [isRemovable]=\"true\"\n          [isDisabled]=\"isDisabled\"\n          [value]=\"chip\"\n          (remove)=\"autocompleteDeselectItem($event.chip)\"\n        >{{ displayFormatter(chip) }}</ts-chip>\n\n        <input\n          class=\"ts-autocomplete__input qa-select-autocomplete-input\"\n          [tsAutocompleteTrigger]=\"auto\"\n          [reopenAfterSelection]=\"reopenAfterSelection\"\n          [attr.id]=\"id\"\n          [(ngModel)]=\"searchQuery\"\n          [readonly]=\"isDisabled ? 'true' : null\"\n          (ngModelChange)=\"querySubject.next($event)\"\n          (blur)=\"handleInputBlur($event)\"\n          #input\n        />\n      </ts-chip-collection>\n      <ng-template *ngTemplateOutlet=\"spinnerTemplate\"></ng-template>\n    </ng-container>\n\n    <ng-container *ngIf=\"!allowMultiple\">\n      <input\n        class=\"ts-autocomplete__input qa-select-autocomplete-input\"\n        [tsAutocompleteTrigger]=\"auto\"\n        [attr.id]=\"id\"\n        [readonly]=\"isDisabled ? 'true' : null\"\n        [(ngModel)]=\"searchQuery\"\n        [value]=\"searchQuery\"\n        (ngModelChange)=\"querySubject.next($event)\"\n        (blur)=\"handleInputBlur($event)\"\n        #input\n      />\n\n      <ng-template *ngTemplateOutlet=\"spinnerTemplate\"></ng-template>\n    </ng-container>\n\n  </div>\n</ts-form-field>\n\n\n<ts-autocomplete-panel\n  class=\"ts-autocomplete\"\n  #auto=\"tsAutocompletePanel\"\n  [id]=\"id + '-panel'\"\n  [options]=\"options\"\n  [optionGroups]=\"optionGroups\"\n  (optionSelected)=\"autocompleteSelectItem($event)\"\n>\n  <!-- Outlet for options passed in by consumer -->\n  <ng-template *ngTemplateOutlet=\"contentTemplate\"></ng-template>\n</ts-autocomplete-panel>\n\n\n<ng-template #contentTemplate>\n  <ng-content></ng-content>\n</ng-template>\n\n<ng-template #spinnerTemplate>\n  <mat-progress-spinner\n    *ngIf=\"showProgress\"\n    class=\"c-autocomplete__spinner c-autocomplete__spinner--{{theme}} qa-select-autocomplete-spinner\"\n    [ngClass]=\"{'c-autocomplete__spinner--active': showProgress}\"\n    diameter=\"21\"\n    mode=\"indeterminate\"\n  ></mat-progress-spinner>\n</ng-template>\n","<ng-template>\n  <div\n    class=\"ts-autocomplete-panel__inner\"\n    [class.ts-autocomplete-visible]=\"showPanel\"\n    role=\"listbox\"\n    [attr.id]=\"id\"\n    #panel\n  >\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n","import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { InjectionToken, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, Inject, ViewChild, TemplateRef, ContentChildren, Input, Output, Directive, forwardRef, ViewContainerRef, NgZone, Optional, Host, NgModule } from '@angular/core';\nimport { mixinDisableRipple, MAT_OPTION_PARENT_COMPONENT, MatOption, MatOptgroup, MatOptionSelectionChange, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionModule, MatCommonModule } from '@angular/material/core';\nimport { Subscription, Subject, defer, merge, of, fromEvent } from 'rxjs';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { ViewportRuler, CdkScrollableModule } from '@angular/cdk/scrolling';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ESCAPE, ENTER, UP_ARROW, DOWN_ARROW, TAB } from '@angular/cdk/keycodes';\nimport { _getShadowRoot } from '@angular/cdk/platform';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { MatFormField, MAT_FORM_FIELD } from '@angular/material/form-field';\nimport { take, switchMap, filter, map, tap, delay } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/autocomplete/autocomplete.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n * @type {?}\n */\nlet _uniqueAutocompleteIdCounter = 0;\n/**\n * Event object that is emitted when an autocomplete option is selected.\n */\nclass MatAutocompleteSelectedEvent {\n    /**\n     * @param {?} source\n     * @param {?} option\n     */\n    constructor(source, option) {\n        this.source = source;\n        this.option = option;\n    }\n}\nif (false) {\n    /**\n     * Reference to the autocomplete panel that emitted the event.\n     * @type {?}\n     */\n    MatAutocompleteSelectedEvent.prototype.source;\n    /**\n     * Option that was selected.\n     * @type {?}\n     */\n    MatAutocompleteSelectedEvent.prototype.option;\n}\n/**\n * Event object that is emitted when an autocomplete option is activated.\n * @record\n */\nfunction MatAutocompleteActivatedEvent() { }\nif (false) {\n    /**\n     * Reference to the autocomplete panel that emitted the event.\n     * @type {?}\n     */\n    MatAutocompleteActivatedEvent.prototype.source;\n    /**\n     * Option that was selected.\n     * @type {?}\n     */\n    MatAutocompleteActivatedEvent.prototype.option;\n}\n// Boilerplate for applying mixins to MatAutocomplete.\n/**\n * \\@docs-private\n */\nclass MatAutocompleteBase {\n}\n/** @type {?} */\nconst _MatAutocompleteMixinBase = mixinDisableRipple(MatAutocompleteBase);\n/**\n * Default `mat-autocomplete` options that can be overridden.\n * @record\n */\nfunction MatAutocompleteDefaultOptions() { }\nif (false) {\n    /**\n     * Whether the first option should be highlighted when an autocomplete panel is opened.\n     * @type {?|undefined}\n     */\n    MatAutocompleteDefaultOptions.prototype.autoActiveFirstOption;\n}\n/**\n * Injection token to be used to override the default options for `mat-autocomplete`.\n * @type {?}\n */\nconst MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken('mat-autocomplete-default-options', {\n    providedIn: 'root',\n    factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n    return { autoActiveFirstOption: false };\n}\nclass MatAutocomplete extends _MatAutocompleteMixinBase {\n    /**\n     * @param {?} _changeDetectorRef\n     * @param {?} _elementRef\n     * @param {?} defaults\n     */\n    constructor(_changeDetectorRef, _elementRef, defaults) {\n        super();\n        this._changeDetectorRef = _changeDetectorRef;\n        this._elementRef = _elementRef;\n        this._activeOptionChanges = Subscription.EMPTY;\n        /**\n         * Whether the autocomplete panel should be visible, depending on option length.\n         */\n        this.showPanel = false;\n        this._isOpen = false;\n        /**\n         * Function that maps an option's control value to its display value in the trigger.\n         */\n        this.displayWith = null;\n        /**\n         * Event that is emitted whenever an option from the list is selected.\n         */\n        this.optionSelected = new EventEmitter();\n        /**\n         * Event that is emitted when the autocomplete panel is opened.\n         */\n        this.opened = new EventEmitter();\n        /**\n         * Event that is emitted when the autocomplete panel is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Emits whenever an option is activated using the keyboard.\n         */\n        this.optionActivated = new EventEmitter();\n        this._classList = {};\n        /**\n         * Unique ID to be used by autocomplete trigger's \"aria-owns\" property.\n         */\n        this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\n        this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n    }\n    /**\n     * Whether the autocomplete panel is open.\n     * @return {?}\n     */\n    get isOpen() { return this._isOpen && this.showPanel; }\n    /**\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\n     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n     * @return {?}\n     */\n    get autoActiveFirstOption() { return this._autoActiveFirstOption; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set autoActiveFirstOption(value) {\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\n    }\n    /**\n     * Takes classes set on the host mat-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     * @param {?} value\n     * @return {?}\n     */\n    set classList(value) {\n        if (value && value.length) {\n            this._classList = value.split(' ').reduce((/**\n             * @param {?} classList\n             * @param {?} className\n             * @return {?}\n             */\n            (classList, className) => {\n                classList[className.trim()] = true;\n                return classList;\n            }), (/** @type {?} */ ({})));\n        }\n        else {\n            this._classList = {};\n        }\n        this._setVisibilityClasses(this._classList);\n        this._elementRef.nativeElement.className = '';\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();\n        this._activeOptionChanges = this._keyManager.change.subscribe((/**\n         * @param {?} index\n         * @return {?}\n         */\n        index => {\n            this.optionActivated.emit({ source: this, option: this.options.toArray()[index] || null });\n        }));\n        // Set the initial visibility state.\n        this._setVisibility();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._activeOptionChanges.unsubscribe();\n    }\n    /**\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\n     * above or below the fold, as they are not actually being focused when active.\n     * @param {?} scrollTop\n     * @return {?}\n     */\n    _setScrollTop(scrollTop) {\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n    /**\n     * Returns the panel's scrollTop.\n     * @return {?}\n     */\n    _getScrollTop() {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n    /**\n     * Panel should hide itself when the option list is empty.\n     * @return {?}\n     */\n    _setVisibility() {\n        this.showPanel = !!this.options.length;\n        this._setVisibilityClasses(this._classList);\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Emits the `select` event.\n     * @param {?} option\n     * @return {?}\n     */\n    _emitSelectEvent(option) {\n        /** @type {?} */\n        const event = new MatAutocompleteSelectedEvent(this, option);\n        this.optionSelected.emit(event);\n    }\n    /**\n     * Sets the autocomplete visibility classes on a classlist based on the panel is visible.\n     * @private\n     * @param {?} classList\n     * @return {?}\n     */\n    _setVisibilityClasses(classList) {\n        classList['mat-autocomplete-visible'] = this.showPanel;\n        classList['mat-autocomplete-hidden'] = !this.showPanel;\n    }\n}\nMatAutocomplete.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-autocomplete',\n                template: \"<ng-template>\\n  <div class=\\\"mat-autocomplete-panel\\\" role=\\\"listbox\\\" [id]=\\\"id\\\" [ngClass]=\\\"_classList\\\" #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\",\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                exportAs: 'matAutocomplete',\n                inputs: ['disableRipple'],\n                host: {\n                    'class': 'mat-autocomplete'\n                },\n                providers: [\n                    { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }\n                ],\n                styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}\\n\"]\n            }] }\n];\n/** @nocollapse */\nMatAutocomplete.ctorParameters = () => [\n    { type: ChangeDetectorRef },\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }\n];\nMatAutocomplete.propDecorators = {\n    template: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],\n    panel: [{ type: ViewChild, args: ['panel',] }],\n    options: [{ type: ContentChildren, args: [MatOption, { descendants: true },] }],\n    optionGroups: [{ type: ContentChildren, args: [MatOptgroup, { descendants: true },] }],\n    displayWith: [{ type: Input }],\n    autoActiveFirstOption: [{ type: Input }],\n    panelWidth: [{ type: Input }],\n    optionSelected: [{ type: Output }],\n    opened: [{ type: Output }],\n    closed: [{ type: Output }],\n    optionActivated: [{ type: Output }],\n    classList: [{ type: Input, args: ['class',] }]\n};\nif (false) {\n    /** @type {?} */\n    MatAutocomplete.ngAcceptInputType_autoActiveFirstOption;\n    /** @type {?} */\n    MatAutocomplete.ngAcceptInputType_disableRipple;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocomplete.prototype._activeOptionChanges;\n    /**\n     * Manages active item in option list based on key events.\n     * @type {?}\n     */\n    MatAutocomplete.prototype._keyManager;\n    /**\n     * Whether the autocomplete panel should be visible, depending on option length.\n     * @type {?}\n     */\n    MatAutocomplete.prototype.showPanel;\n    /** @type {?} */\n    MatAutocomplete.prototype._isOpen;\n    /**\n     * \\@docs-private\n     * @type {?}\n     */\n    MatAutocomplete.prototype.template;\n    /**\n     * Element for the panel containing the autocomplete options.\n     * @type {?}\n     */\n    MatAutocomplete.prototype.panel;\n    /**\n     * \\@docs-private\n     * @type {?}\n     */\n    MatAutocomplete.prototype.options;\n    /**\n     * \\@docs-private\n     * @type {?}\n     */\n    MatAutocomplete.prototype.optionGroups;\n    /**\n     * Function that maps an option's control value to its display value in the trigger.\n     * @type {?}\n     */\n    MatAutocomplete.prototype.displayWith;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocomplete.prototype._autoActiveFirstOption;\n    /**\n     * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n     * match the width of its host.\n     * @type {?}\n     */\n    MatAutocomplete.prototype.panelWidth;\n    /**\n     * Event that is emitted whenever an option from the list is selected.\n     * @type {?}\n     */\n    MatAutocomplete.prototype.optionSelected;\n    /**\n     * Event that is emitted when the autocomplete panel is opened.\n     * @type {?}\n     */\n    MatAutocomplete.prototype.opened;\n    /**\n     * Event that is emitted when the autocomplete panel is closed.\n     * @type {?}\n     */\n    MatAutocomplete.prototype.closed;\n    /**\n     * Emits whenever an option is activated using the keyboard.\n     * @type {?}\n     */\n    MatAutocomplete.prototype.optionActivated;\n    /** @type {?} */\n    MatAutocomplete.prototype._classList;\n    /**\n     * Unique ID to be used by autocomplete trigger's \"aria-owns\" property.\n     * @type {?}\n     */\n    MatAutocomplete.prototype.id;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocomplete.prototype._changeDetectorRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocomplete.prototype._elementRef;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/autocomplete/autocomplete-origin.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\nclass MatAutocompleteOrigin {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n    }\n}\nMatAutocompleteOrigin.decorators = [\n    { type: Directive, args: [{\n                selector: '[matAutocompleteOrigin]',\n                exportAs: 'matAutocompleteOrigin',\n            },] }\n];\n/** @nocollapse */\nMatAutocompleteOrigin.ctorParameters = () => [\n    { type: ElementRef }\n];\nif (false) {\n    /**\n     * Reference to the element on which the directive is applied.\n     * @type {?}\n     */\n    MatAutocompleteOrigin.prototype.elementRef;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/autocomplete/autocomplete-trigger.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The height of each autocomplete option.\n * @type {?}\n */\nconst AUTOCOMPLETE_OPTION_HEIGHT = 48;\n/**\n * The total height of the autocomplete panel.\n * @type {?}\n */\nconst AUTOCOMPLETE_PANEL_HEIGHT = 256;\n/**\n * Injection token that determines the scroll handling while the autocomplete panel is open.\n * @type {?}\n */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken('mat-autocomplete-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n    return (/**\n     * @return {?}\n     */\n    () => overlay.scrollStrategies.reposition());\n}\n/**\n * \\@docs-private\n * @type {?}\n */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n};\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * \\@docs-private\n * @type {?}\n */\nconst MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef((/**\n     * @return {?}\n     */\n    () => MatAutocompleteTrigger)),\n    multi: true\n};\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * \\@docs-private\n * @return {?}\n */\nfunction getMatAutocompleteMissingPanelError() {\n    return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\n        'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n        'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\nclass MatAutocompleteTrigger {\n    /**\n     * @param {?} _element\n     * @param {?} _overlay\n     * @param {?} _viewContainerRef\n     * @param {?} _zone\n     * @param {?} _changeDetectorRef\n     * @param {?} scrollStrategy\n     * @param {?} _dir\n     * @param {?} _formField\n     * @param {?} _document\n     * @param {?=} _viewportRuler\n     */\n    constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler) {\n        this._element = _element;\n        this._overlay = _overlay;\n        this._viewContainerRef = _viewContainerRef;\n        this._zone = _zone;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._formField = _formField;\n        this._document = _document;\n        this._viewportRuler = _viewportRuler;\n        this._componentDestroyed = false;\n        this._autocompleteDisabled = false;\n        /**\n         * Whether or not the label state is being overridden.\n         */\n        this._manuallyFloatingLabel = false;\n        /**\n         * Subscription to viewport size changes.\n         */\n        this._viewportSubscription = Subscription.EMPTY;\n        /**\n         * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n         * closed autocomplete from being reopened if the user switches to another browser tab and then\n         * comes back.\n         */\n        this._canOpenOnNextFocus = true;\n        /**\n         * Stream of keyboard events that can close the panel.\n         */\n        this._closeKeyEventStream = new Subject();\n        /**\n         * Event handler for when the window is blurred. Needs to be an\n         * arrow function in order to preserve the context.\n         */\n        this._windowBlurHandler = (/**\n         * @return {?}\n         */\n        () => {\n            // If the user blurred the window while the autocomplete is focused, it means that it'll be\n            // refocused when they come back. In this case we want to skip the first focus event, if the\n            // pane was closed, in order to avoid reopening it unintentionally.\n            this._canOpenOnNextFocus =\n                this._document.activeElement !== this._element.nativeElement || this.panelOpen;\n        });\n        /**\n         * `View -> model callback called when value changes`\n         */\n        this._onChange = (/**\n         * @return {?}\n         */\n        () => { });\n        /**\n         * `View -> model callback called when autocomplete has been touched`\n         */\n        this._onTouched = (/**\n         * @return {?}\n         */\n        () => { });\n        /**\n         * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n         * will render the panel underneath the trigger if there is enough space for it to fit in\n         * the viewport, otherwise the panel will be shown above it. If the position is set to\n         * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n         * whether it fits completely in the viewport.\n         */\n        this.position = 'auto';\n        /**\n         * `autocomplete` attribute to be set on the input element.\n         * \\@docs-private\n         */\n        this.autocompleteAttribute = 'off';\n        this._overlayAttached = false;\n        /**\n         * Stream of autocomplete option selections.\n         */\n        this.optionSelections = (/** @type {?} */ (defer((/**\n         * @return {?}\n         */\n        () => {\n            if (this.autocomplete && this.autocomplete.options) {\n                return merge(...this.autocomplete.options.map((/**\n                 * @param {?} option\n                 * @return {?}\n                 */\n                option => option.onSelectionChange)));\n            }\n            // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n            // Return a stream that we'll replace with the real one once everything is in place.\n            return this._zone.onStable\n                .asObservable()\n                .pipe(take(1), switchMap((/**\n             * @return {?}\n             */\n            () => this.optionSelections)));\n        }))));\n        this._scrollStrategy = scrollStrategy;\n    }\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     * @return {?}\n     */\n    get autocompleteDisabled() { return this._autocompleteDisabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set autocompleteDisabled(value) {\n        this._autocompleteDisabled = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        /** @type {?} */\n        const window = this._getWindow();\n        if (typeof window !== 'undefined') {\n            this._zone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                window.addEventListener('blur', this._windowBlurHandler);\n            }));\n            this._isInsideShadowRoot = !!_getShadowRoot(this._element.nativeElement);\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes['position'] && this._positionStrategy) {\n            this._setStrategyPositions(this._positionStrategy);\n            if (this.panelOpen) {\n                (/** @type {?} */ (this._overlayRef)).updatePosition();\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        /** @type {?} */\n        const window = this._getWindow();\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('blur', this._windowBlurHandler);\n        }\n        this._viewportSubscription.unsubscribe();\n        this._componentDestroyed = true;\n        this._destroyPanel();\n        this._closeKeyEventStream.complete();\n    }\n    /**\n     * Whether or not the autocomplete panel is open.\n     * @return {?}\n     */\n    get panelOpen() {\n        return this._overlayAttached && this.autocomplete.showPanel;\n    }\n    /**\n     * Opens the autocomplete suggestion panel.\n     * @return {?}\n     */\n    openPanel() {\n        this._attachOverlay();\n        this._floatLabel();\n    }\n    /**\n     * Closes the autocomplete suggestion panel.\n     * @return {?}\n     */\n    closePanel() {\n        this._resetLabel();\n        if (!this._overlayAttached) {\n            return;\n        }\n        if (this.panelOpen) {\n            // Only emit if the panel was visible.\n            this.autocomplete.closed.emit();\n        }\n        this.autocomplete._isOpen = this._overlayAttached = false;\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\n            this._overlayRef.detach();\n            this._closingActionsSubscription.unsubscribe();\n        }\n        // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n        if (!this._componentDestroyed) {\n            // We need to trigger change detection manually, because\n            // `fromEvent` doesn't seem to do it at the proper time.\n            // This ensures that the label is reset when the\n            // user clicks outside.\n            this._changeDetectorRef.detectChanges();\n        }\n    }\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     * @return {?}\n     */\n    updatePosition() {\n        if (this._overlayAttached) {\n            (/** @type {?} */ (this._overlayRef)).updatePosition();\n        }\n    }\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     * @return {?}\n     */\n    get panelClosingActions() {\n        return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter((/**\n         * @return {?}\n         */\n        () => this._overlayAttached))), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?\n            this._overlayRef.detachments().pipe(filter((/**\n             * @return {?}\n             */\n            () => this._overlayAttached))) :\n            of()).pipe(\n        // Normalize the output so we return a consistent type.\n        map((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => event instanceof MatOptionSelectionChange ? event : null)));\n    }\n    /**\n     * The currently active option, coerced to MatOption type.\n     * @return {?}\n     */\n    get activeOption() {\n        if (this.autocomplete && this.autocomplete._keyManager) {\n            return this.autocomplete._keyManager.activeItem;\n        }\n        return null;\n    }\n    /**\n     * Stream of clicks outside of the autocomplete panel.\n     * @private\n     * @return {?}\n     */\n    _getOutsideClickStream() {\n        return merge((/** @type {?} */ (fromEvent(this._document, 'click'))), (/** @type {?} */ (fromEvent(this._document, 'touchend'))))\n            .pipe(filter((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n            // fall back to check the first element in the path of the click event.\n            /** @type {?} */\n            const clickTarget = (/** @type {?} */ ((this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :\n                event.target)));\n            /** @type {?} */\n            const formField = this._formField ? this._formField._elementRef.nativeElement : null;\n            return this._overlayAttached && clickTarget !== this._element.nativeElement &&\n                (!formField || !formField.contains(clickTarget)) &&\n                (!!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget));\n        })));\n    }\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    writeValue(value) {\n        Promise.resolve(null).then((/**\n         * @return {?}\n         */\n        () => this._setTriggerValue(value)));\n    }\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    registerOnChange(fn) {\n        this._onChange = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    registerOnTouched(fn) {\n        this._onTouched = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    setDisabledState(isDisabled) {\n        this._element.nativeElement.disabled = isDisabled;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        /** @type {?} */\n        const keyCode = event.keyCode;\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === ESCAPE) {\n            event.preventDefault();\n        }\n        if (this.activeOption && keyCode === ENTER && this.panelOpen) {\n            this.activeOption._selectViaInteraction();\n            this._resetActiveItem();\n            event.preventDefault();\n        }\n        else if (this.autocomplete) {\n            /** @type {?} */\n            const prevActiveItem = this.autocomplete._keyManager.activeItem;\n            /** @type {?} */\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n            if (this.panelOpen || keyCode === TAB) {\n                this.autocomplete._keyManager.onKeydown(event);\n            }\n            else if (isArrowKey && this._canOpen()) {\n                this.openPanel();\n            }\n            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n                this._scrollToOption();\n            }\n        }\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    _handleInput(event) {\n        /** @type {?} */\n        let target = (/** @type {?} */ (event.target));\n        /** @type {?} */\n        let value = target.value;\n        // Based on `NumberValueAccessor` from forms.\n        if (target.type === 'number') {\n            value = value == '' ? null : parseFloat(value);\n        }\n        // If the input has a placeholder, IE will fire the `input` event on page load,\n        // focus and blur, in addition to when the user actually changed the value. To\n        // filter out all of the extra events, we save the value on focus and between\n        // `input` events, and we check whether it changed.\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\n        if (this._previousValue !== value) {\n            this._previousValue = value;\n            this._onChange(value);\n            if (this._canOpen() && this._document.activeElement === event.target) {\n                this.openPanel();\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _handleFocus() {\n        if (!this._canOpenOnNextFocus) {\n            this._canOpenOnNextFocus = true;\n        }\n        else if (this._canOpen()) {\n            this._previousValue = this._element.nativeElement.value;\n            this._attachOverlay();\n            this._floatLabel(true);\n        }\n    }\n    /**\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\n     * This causes the value to jump when selecting an option with the mouse.\n     * This method manually floats the label until the panel can be closed.\n     * @private\n     * @param {?=} shouldAnimate Whether the label should be animated when it is floated.\n     * @return {?}\n     */\n    _floatLabel(shouldAnimate = false) {\n        if (this._formField && this._formField.floatLabel === 'auto') {\n            if (shouldAnimate) {\n                this._formField._animateAndLockLabel();\n            }\n            else {\n                this._formField.floatLabel = 'always';\n            }\n            this._manuallyFloatingLabel = true;\n        }\n    }\n    /**\n     * If the label has been manually elevated, return it to its normal state.\n     * @private\n     * @return {?}\n     */\n    _resetLabel() {\n        if (this._manuallyFloatingLabel) {\n            this._formField.floatLabel = 'auto';\n            this._manuallyFloatingLabel = false;\n        }\n    }\n    /**\n     * Given that we are not actually focusing active options, we must manually adjust scroll\n     * to reveal options below the fold. First, we find the offset of the option from the top\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n     * the panel height + the option height, so the active option will be just visible at the\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\n     * not adjusted.\n     * @private\n     * @return {?}\n     */\n    _scrollToOption() {\n        /** @type {?} */\n        const index = this.autocomplete._keyManager.activeItemIndex || 0;\n        /** @type {?} */\n        const labelCount = _countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);\n        if (index === 0 && labelCount === 1) {\n            // If we've got one group label before the option and we're at the top option,\n            // scroll the list to the top. This is better UX than scrolling the list to the\n            // top of the option, because it allows the user to read the top group's label.\n            this.autocomplete._setScrollTop(0);\n        }\n        else {\n            /** @type {?} */\n            const newScrollPosition = _getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\n            this.autocomplete._setScrollTop(newScrollPosition);\n        }\n    }\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     * @private\n     * @return {?}\n     */\n    _subscribeToClosingActions() {\n        /** @type {?} */\n        const firstStable = this._zone.onStable.asObservable().pipe(take(1));\n        /** @type {?} */\n        const optionChanges = this.autocomplete.options.changes.pipe(tap((/**\n         * @return {?}\n         */\n        () => this._positionStrategy.reapplyLastPosition())), \n        // Defer emitting to the stream until the next tick, because changing\n        // bindings in here will cause \"changed after checked\" errors.\n        delay(0));\n        // When the zone is stable initially, and when the option list changes...\n        return merge(firstStable, optionChanges)\n            .pipe(\n        // create a new stream of panelClosingActions, replacing any previous streams\n        // that were created, and flatten it so our stream only emits closing events...\n        switchMap((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const wasOpen = this.panelOpen;\n            this._resetActiveItem();\n            this.autocomplete._setVisibility();\n            if (this.panelOpen) {\n                (/** @type {?} */ (this._overlayRef)).updatePosition();\n                // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n                // event, because we may not have emitted it when the panel was attached. This\n                // can happen if the users opens the panel and there are no options, but the\n                // options come in slightly later or as a result of the value changing.\n                if (wasOpen !== this.panelOpen) {\n                    this.autocomplete.opened.emit();\n                }\n            }\n            return this.panelClosingActions;\n        })), \n        // when the first closing event occurs...\n        take(1))\n            // set the value, close the panel, and complete.\n            .subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => this._setValueAndClose(event)));\n    }\n    /**\n     * Destroys the autocomplete suggestion panel.\n     * @private\n     * @return {?}\n     */\n    _destroyPanel() {\n        if (this._overlayRef) {\n            this.closePanel();\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n    }\n    /**\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n    _setTriggerValue(value) {\n        /** @type {?} */\n        const toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n            this.autocomplete.displayWith(value) :\n            value;\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\n        /** @type {?} */\n        const inputValue = toDisplay != null ? toDisplay : '';\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\n        // through change detection.\n        if (this._formField) {\n            this._formField._control.value = inputValue;\n        }\n        else {\n            this._element.nativeElement.value = inputValue;\n        }\n        this._previousValue = inputValue;\n    }\n    /**\n     * This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _setValueAndClose(event) {\n        if (event && event.source) {\n            this._clearPreviousSelectedOption(event.source);\n            this._setTriggerValue(event.source.value);\n            this._onChange(event.source.value);\n            this._element.nativeElement.focus();\n            this.autocomplete._emitSelectEvent(event.source);\n        }\n        this.closePanel();\n    }\n    /**\n     * Clear any previous selected option and emit a selection change event for this option\n     * @private\n     * @param {?} skip\n     * @return {?}\n     */\n    _clearPreviousSelectedOption(skip) {\n        this.autocomplete.options.forEach((/**\n         * @param {?} option\n         * @return {?}\n         */\n        option => {\n            if (option != skip && option.selected) {\n                option.deselect();\n            }\n        }));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _attachOverlay() {\n        if (!this.autocomplete) {\n            throw getMatAutocompleteMissingPanelError();\n        }\n        /** @type {?} */\n        let overlayRef = this._overlayRef;\n        if (!overlayRef) {\n            this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);\n            overlayRef = this._overlay.create(this._getOverlayConfig());\n            this._overlayRef = overlayRef;\n            // Use the `keydownEvents` in order to take advantage of\n            // the overlay event targeting provided by the CDK overlay.\n            overlayRef.keydownEvents().subscribe((/**\n             * @param {?} event\n             * @return {?}\n             */\n            event => {\n                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {\n                    this._resetActiveItem();\n                    this._closeKeyEventStream.next();\n                    // We need to stop propagation, otherwise the event will eventually\n                    // reach the input itself and cause the overlay to be reopened.\n                    event.stopPropagation();\n                    event.preventDefault();\n                }\n            }));\n            if (this._viewportRuler) {\n                this._viewportSubscription = this._viewportRuler.change().subscribe((/**\n                 * @return {?}\n                 */\n                () => {\n                    if (this.panelOpen && overlayRef) {\n                        overlayRef.updateSize({ width: this._getPanelWidth() });\n                    }\n                }));\n            }\n        }\n        else {\n            // Update the trigger, panel width and direction, in case anything has changed.\n            this._positionStrategy.setOrigin(this._getConnectedElement());\n            overlayRef.updateSize({ width: this._getPanelWidth() });\n        }\n        if (overlayRef && !overlayRef.hasAttached()) {\n            overlayRef.attach(this._portal);\n            this._closingActionsSubscription = this._subscribeToClosingActions();\n        }\n        /** @type {?} */\n        const wasOpen = this.panelOpen;\n        this.autocomplete._setVisibility();\n        this.autocomplete._isOpen = this._overlayAttached = true;\n        // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n            this.autocomplete.opened.emit();\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _getOverlayConfig() {\n        return new OverlayConfig({\n            positionStrategy: this._getOverlayPosition(),\n            scrollStrategy: this._scrollStrategy(),\n            width: this._getPanelWidth(),\n            direction: this._dir\n        });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _getOverlayPosition() {\n        /** @type {?} */\n        const strategy = this._overlay.position()\n            .flexibleConnectedTo(this._getConnectedElement())\n            .withFlexibleDimensions(false)\n            .withPush(false);\n        this._setStrategyPositions(strategy);\n        this._positionStrategy = strategy;\n        return strategy;\n    }\n    /**\n     * Sets the positions on a position strategy based on the directive's input state.\n     * @private\n     * @param {?} positionStrategy\n     * @return {?}\n     */\n    _setStrategyPositions(positionStrategy) {\n        // Note that we provide horizontal fallback positions, even though by default the dropdown\n        // width matches the input, because consumers can override the width. See #18854.\n        /** @type {?} */\n        const belowPositions = [\n            { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },\n            { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top' }\n        ];\n        // The overlay edge connected to the trigger should have squared corners, while\n        // the opposite end has rounded corners. We apply a CSS class to swap the\n        // border-radius based on the overlay position.\n        /** @type {?} */\n        const panelClass = 'mat-autocomplete-panel-above';\n        /** @type {?} */\n        const abovePositions = [\n            { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', panelClass },\n            { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', panelClass }\n        ];\n        /** @type {?} */\n        let positions;\n        if (this.position === 'above') {\n            positions = abovePositions;\n        }\n        else if (this.position === 'below') {\n            positions = belowPositions;\n        }\n        else {\n            positions = [...belowPositions, ...abovePositions];\n        }\n        positionStrategy.withPositions(positions);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _getConnectedElement() {\n        if (this.connectedTo) {\n            return this.connectedTo.elementRef;\n        }\n        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _getPanelWidth() {\n        return this.autocomplete.panelWidth || this._getHostWidth();\n    }\n    /**\n     * Returns the width of the input element, so the panel width can match it.\n     * @private\n     * @return {?}\n     */\n    _getHostWidth() {\n        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n    /**\n     * Resets the active item to -1 so arrow events will activate the\n     * correct options, or to 0 if the consumer opted into it.\n     * @private\n     * @return {?}\n     */\n    _resetActiveItem() {\n        this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n    }\n    /**\n     * Determines whether the panel can be opened.\n     * @private\n     * @return {?}\n     */\n    _canOpen() {\n        /** @type {?} */\n        const element = this._element.nativeElement;\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n    }\n    /**\n     * Use defaultView of injected document if available or fallback to global window reference\n     * @private\n     * @return {?}\n     */\n    _getWindow() {\n        var _a;\n        return ((_a = this._document) === null || _a === void 0 ? void 0 : _a.defaultView) || window;\n    }\n}\nMatAutocompleteTrigger.decorators = [\n    { type: Directive, args: [{\n                selector: `input[matAutocomplete], textarea[matAutocomplete]`,\n                host: {\n                    'class': 'mat-autocomplete-trigger',\n                    '[attr.autocomplete]': 'autocompleteAttribute',\n                    '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n                    '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n                    '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n                    '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n                    '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n                    '[attr.aria-haspopup]': '!autocompleteDisabled',\n                    // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n                    // a little earlier. This avoids issues where IE delays the focusing of the input.\n                    '(focusin)': '_handleFocus()',\n                    '(blur)': '_onTouched()',\n                    '(input)': '_handleInput($event)',\n                    '(keydown)': '_handleKeydown($event)',\n                },\n                exportAs: 'matAutocompleteTrigger',\n                providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n            },] }\n];\n/** @nocollapse */\nMatAutocompleteTrigger.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Overlay },\n    { type: ViewContainerRef },\n    { type: NgZone },\n    { type: ChangeDetectorRef },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: MatFormField, decorators: [{ type: Optional }, { type: Inject, args: [MAT_FORM_FIELD,] }, { type: Host }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },\n    { type: ViewportRuler }\n];\nMatAutocompleteTrigger.propDecorators = {\n    autocomplete: [{ type: Input, args: ['matAutocomplete',] }],\n    position: [{ type: Input, args: ['matAutocompletePosition',] }],\n    connectedTo: [{ type: Input, args: ['matAutocompleteConnectedTo',] }],\n    autocompleteAttribute: [{ type: Input, args: ['autocomplete',] }],\n    autocompleteDisabled: [{ type: Input, args: ['matAutocompleteDisabled',] }]\n};\nif (false) {\n    /** @type {?} */\n    MatAutocompleteTrigger.ngAcceptInputType_autocompleteDisabled;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._overlayRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._portal;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._componentDestroyed;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._autocompleteDisabled;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._scrollStrategy;\n    /**\n     * Old value of the native input. Used to work around issues with the `input` event on IE.\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._previousValue;\n    /**\n     * Strategy that is used to position the panel.\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._positionStrategy;\n    /**\n     * Whether or not the label state is being overridden.\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._manuallyFloatingLabel;\n    /**\n     * The subscription for closing actions (some are bound to document).\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._closingActionsSubscription;\n    /**\n     * Subscription to viewport size changes.\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._viewportSubscription;\n    /**\n     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n     * closed autocomplete from being reopened if the user switches to another browser tab and then\n     * comes back.\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._canOpenOnNextFocus;\n    /**\n     * Whether the element is inside of a ShadowRoot component.\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._isInsideShadowRoot;\n    /**\n     * Stream of keyboard events that can close the panel.\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._closeKeyEventStream;\n    /**\n     * Event handler for when the window is blurred. Needs to be an\n     * arrow function in order to preserve the context.\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._windowBlurHandler;\n    /**\n     * `View -> model callback called when value changes`\n     * @type {?}\n     */\n    MatAutocompleteTrigger.prototype._onChange;\n    /**\n     * `View -> model callback called when autocomplete has been touched`\n     * @type {?}\n     */\n    MatAutocompleteTrigger.prototype._onTouched;\n    /**\n     * The autocomplete panel to be attached to this trigger.\n     * @type {?}\n     */\n    MatAutocompleteTrigger.prototype.autocomplete;\n    /**\n     * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n     * will render the panel underneath the trigger if there is enough space for it to fit in\n     * the viewport, otherwise the panel will be shown above it. If the position is set to\n     * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n     * whether it fits completely in the viewport.\n     * @type {?}\n     */\n    MatAutocompleteTrigger.prototype.position;\n    /**\n     * Reference relative to which to position the autocomplete panel.\n     * Defaults to the autocomplete trigger element.\n     * @type {?}\n     */\n    MatAutocompleteTrigger.prototype.connectedTo;\n    /**\n     * `autocomplete` attribute to be set on the input element.\n     * \\@docs-private\n     * @type {?}\n     */\n    MatAutocompleteTrigger.prototype.autocompleteAttribute;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._overlayAttached;\n    /**\n     * Stream of autocomplete option selections.\n     * @type {?}\n     */\n    MatAutocompleteTrigger.prototype.optionSelections;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._element;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._overlay;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._viewContainerRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._zone;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._changeDetectorRef;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._dir;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._formField;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._document;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatAutocompleteTrigger.prototype._viewportRuler;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/autocomplete/autocomplete-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatAutocompleteModule {\n}\nMatAutocompleteModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [MatOptionModule, OverlayModule, MatCommonModule, CommonModule],\n                exports: [\n                    CdkScrollableModule,\n                    MatAutocomplete,\n                    MatOptionModule,\n                    MatAutocompleteTrigger,\n                    MatAutocompleteOrigin,\n                    MatCommonModule\n                ],\n                declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\n                providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/autocomplete/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocomplete, MatAutocompleteModule, MatAutocompleteOrigin, MatAutocompleteSelectedEvent, MatAutocompleteTrigger, getMatAutocompleteMissingPanelError };\n//# sourceMappingURL=autocomplete.js.map\n","import { NgModule } from '@angular/core';\nimport {\n  RouterModule,\n  Routes,\n} from '@angular/router';\n\nimport { AutocompleteComponent } from './autocomplete.component';\n\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: AutocompleteComponent,\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class AutocompleteRoutingModule { }\n","<ts-card tsVerticalSpacing fxFlex>\n  <form\n    novalidate\n    fxLayout=\"column\"\n    fxLayout.gt-sm=\"row\"\n    fxLayoutGap=\"1rem\"\n  >\n    <aside class=\"deprecated\" tsVerticalSpacing>\n      <h2> DEPRECATED </h2>\n      <p>Please use <a [routerLink]=\"['/components/selection-list']\">TsSelectionList</a>.</p>\n    </aside>\n\n    <h3 tsCardTitle tsVerticalSpacing=\"small--1\">\n      Autocomplete (multiple)\n    </h3>\n\n    <ts-autocomplete\n      label=\"Autocomplete Example\"\n      hint=\"Begin typing to select..\"\n      [formControl]=\"stateCtrl\"\n      [allowMultiple]=\"true\"\n      [allowDuplicateSelections]=\"false\"\n      [reopenAfterSelection]=\"false\"\n      [showProgress]=\"fakeAsync\"\n      [displayFormatter]=\"formatter\"\n      (queryChange)=\"queryHasChanged($event)\"\n      (duplicateSelection)=\"duplicate($event)\"\n      tsVerticalSpacing\n    >\n\n      <ts-option\n        [value]=\"state\"\n        [option]=\"state\"\n        *ngFor=\"let state of filteredStates | async\"\n      >\n        {{ state.name }}\n      </ts-option>\n\n    </ts-autocomplete>\n\n    <div>\n      FormControl value: {{ stateCtrl.value | json }}\n    </div>\n  </form>\n</ts-card>\n\n<ts-card tsVerticalSpacing fxFlex>\n  <form\n    novalidate\n    fxLayout=\"column\"\n    fxLayout.gt-sm=\"row\"\n    fxLayoutGap=\"1rem\"\n  >\n    <h3 tsCardTitle tsVerticalSpacing=\"small--1\">\n      Autocomplete (single)\n    </h3>\n\n    <ts-autocomplete\n      label=\"Autocomplete Example\"\n      hint=\"Begin typing to select..\"\n      [formControl]=\"singleStateCtrl\"\n      [allowMultiple]=\"false\"\n      [allowDuplicateSelections]=\"true\"\n      [reopenAfterSelection]=\"false\"\n      [showProgress]=\"fakeAsync\"\n      [displayFormatter]=\"formatter\"\n      (queryChange)=\"queryHasChanged($event)\"\n      (duplicateSelection)=\"duplicate($event)\"\n      tsVerticalSpacing\n    >\n\n      <ts-option\n        [value]=\"state\"\n        [option]=\"state\"\n        *ngFor=\"let state of filteredStates | async\"\n      >\n        {{ state.name }}\n      </ts-option>\n\n    </ts-autocomplete>\n\n    <div>\n      FormControl value: {{ singleStateCtrl.value | json }}\n    </div>\n  </form>\n</ts-card>\n","import {\n  Component,\n  ViewChild,\n} from '@angular/core';\nimport {\n  FormControl,\n  Validators,\n} from '@angular/forms';\nimport {\n  BehaviorSubject,\n  Observable,\n} from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { TsChipCollectionComponent } from '@terminus/ui-chip';\n\n\nexport interface State {\n  name: string;\n  population: string;\n}\n\n\n@Component({\n  selector: 'demo-autocomplete',\n  templateUrl: './autocomplete.component.html',\n})\nexport class AutocompleteComponent {\n  @ViewChild(TsChipCollectionComponent, { static: false })\n  public list!: TsChipCollectionComponent;\n  states: State[] = [\n    {\n      name: 'Arkansas',\n      population: '2.978M',\n    },\n    {\n      name: 'Alabama',\n      population: '3.29M',\n    },\n    {\n      name: 'Alaska',\n      population: '1.341M',\n    },\n    {\n      name: 'CALIFORNIA',\n      population: '39.14M',\n    },\n    {\n      name: 'Florida',\n      population: '20.27M',\n    },\n    {\n      name: 'Texas',\n      population: '27.47M',\n    },\n    {\n      name: 'Arizona',\n      population: '24.112M',\n    },\n    {\n      name: 'Arkansas 2',\n      population: '2.978M',\n    },\n    {\n      name: 'Alabama 2',\n      population: '3.29M',\n    },\n    {\n      name: 'Alaska 2',\n      population: '1.341M',\n    },\n    {\n      name: 'California 2',\n      population: '39.14M',\n    },\n    {\n      name: 'Florida 2',\n      population: '20.27M',\n    },\n    {\n      name: 'Texas 2',\n      population: '27.47M',\n    },\n    {\n      name: 'Arizona 2',\n      population: '24.112M',\n    },\n    {\n      name: 'Arkansas 3',\n      population: '2.978M',\n    },\n    {\n      name: 'Alabama 3',\n      population: '3.29M',\n    },\n    {\n      name: 'Alaska 3',\n      population: '1.341M',\n    },\n    {\n      name: 'California 3',\n      population: '39.14M',\n    },\n    {\n      name: 'Florida 3',\n      population: '20.27M',\n    },\n    {\n      name: 'Texas 3',\n      population: '27.47M',\n    },\n    {\n      name: 'Arizona 3',\n      population: '24.112M',\n    },\n  ];\n  filteredStates!: Observable<State[]>;\n  myQuery$: BehaviorSubject<string> = new BehaviorSubject('');\n  fakeAsync = false;\n\n  stateCtrl = new FormControl([this.states[4]], [Validators.required]);\n  singleStateCtrl = new FormControl([this.states[4]], [Validators.required]);\n\n  constructor() {\n    this.filteredStates = this.myQuery$\n      .pipe(\n        map(state => {\n          const val = state ? this.filterStates(state) : [];\n          console.log('Demo: in pipe: ', state, val);\n          return val;\n        }),\n      );\n  }\n\n  private filterStates(value: string): State[] {\n    const filterValue = value.toLowerCase();\n    return this.states.filter(state => state.name.toLowerCase().indexOf(filterValue) === 0);\n  }\n\n  log(v: any): void {\n    console.log('DEMO: Form value: ', v);\n  }\n\n  queryHasChanged(v) {\n    console.log('DEMO: query string changed: ', v);\n    this.myQuery$.next(v);\n  }\n\n  duplicate(e) {\n    console.log('DEMO: Duplicate selection: ', e);\n  }\n\n  formatter(value: State): string {\n    return value.name;\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport {\n  FormsModule,\n  ReactiveFormsModule,\n} from '@angular/forms';\n\nimport { TsAutocompleteModule } from '@terminus/ui-autocomplete';\nimport { TsCardModule } from '@terminus/ui-card';\nimport { TsCheckboxModule } from '@terminus/ui-checkbox';\nimport { TsChipModule } from '@terminus/ui-chip';\nimport { TsIconModule } from '@terminus/ui-icon';\nimport { TsOptionModule } from '@terminus/ui-option';\nimport { TsSpacingModule } from '@terminus/ui-spacing';\n\nimport { AutocompleteRoutingModule } from './autocomplete-routing.module';\nimport { AutocompleteComponent } from './autocomplete.component';\n\n@NgModule({\n  imports: [\n    AutocompleteRoutingModule,\n    CommonModule,\n    FormsModule,\n    ReactiveFormsModule,\n    TsAutocompleteModule,\n    TsCheckboxModule,\n    TsCardModule,\n    TsChipModule,\n    TsIconModule,\n    TsOptionModule,\n    TsSpacingModule,\n  ],\n  declarations: [AutocompleteComponent],\n})\nexport class AutocompleteModule {}\n"],"sourceRoot":"webpack:///"}