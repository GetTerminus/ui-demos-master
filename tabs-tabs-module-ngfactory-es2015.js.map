{"version":3,"sources":["/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/tabs/fesm2015/terminus-ui-tabs.js","/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/tabs/terminus-ui-tabs.d.ts.TsTabBodyComponent.html","/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/tabs/terminus-ui-tabs.d.ts.TsTabCollectionComponent.html","/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/tabs/terminus-ui-tabs.d.ts.TsTabHeaderComponent.html","/home/runner/work/terminus-oss/terminus-oss/dist/libs/ui/tabs/terminus-ui-tabs.d.ts.TsTabComponent.html","./src/app/components/tabs/tabs-routing.module.ts","./src/app/components/tabs/tabs.component.html","./src/app/components/tabs/tabs.component.ts","./src/app/components/tabs/tabs.module.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwD;AACQ;AACP;AACsC;AAChD;AACkQ;AACzP;AACC;AACmB;AACJ;AACF;AACX;AACsB;AACb;AACb;AACF;AAC6B;AAC9B;;AAEpD;AACA,uBAAuB;AACvB;AACA;AACA;AACA,kBAAkB,oEAAO;AACzB;AACA,QAAQ,kEAAK,0DAA0D,kEAAK,EAAE,oBAAoB;AAClG;AACA;AACA;AACA,QAAQ,kEAAK,SAAS,kEAAK;AAC3B;AACA;AACA;AACA,SAAS;AACT,QAAQ,kEAAK,UAAU,kEAAK;AAC5B;AACA;AACA;AACA,SAAS;AACT,QAAQ,uEAAU,2DAA2D,oEAAO;AACpF,QAAQ,uEAAU;AAClB,YAAY,kEAAK,EAAE,wCAAwC;AAC3D,YAAY,oEAAO;AACnB;AACA,QAAQ,uEAAU;AAClB,YAAY,kEAAK,EAAE,uCAAuC;AAC1D,YAAY,oEAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6CAAO;AAC/C;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA,sCAAsC,0DAAY;AAClD;AACA;AACA;AACA,4BAA4B,0DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iFAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6FAAuB;AAC9D;AACA;AACA,QAAQ,2EAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU;AACtB;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU,gBAAgB,kEAAc;AAC5C;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,4DAAM;AACV,IAAI,wDAAU,gBAAgB,0DAAY;AAC1C;AACA,wDAAU;AACV,IAAI,4DAAM;AACV,IAAI,wDAAU,gBAAgB,0DAAY;AAC1C;AACA,wDAAU;AACV,IAAI,4DAAM;AACV,IAAI,wDAAU,gBAAgB,0DAAY;AAC1C;AACA,wDAAU;AACV,IAAI,4DAAM;AACV,IAAI,wDAAU,gBAAgB,0DAAY;AAC1C;AACA,qBAAqB,wDAAU;AAC/B,IAAI,+DAAS;AACb;AACA,4FAA4F,+BAA+B;AAC3H,eAAe,uBAAuB;AACtC;AACA,yBAAyB,qEAAuB;AAChD,uBAAuB,+DAAiB;AACxC;AACA,wBAAwB,gEAAgE,+DAA+D,+DAA+D,8DAA8D,UAAU,kBAAkB,qCAAqC,kDAAkD,2BAA2B,cAAc,iBAAiB,kBAAkB,UAAU,2BAA2B,8GAA8G,yBAAyB,yBAAyB,gBAAgB,oBAAoB,uCAAuC,iBAAiB,sBAAsB,kBAAkB,sBAAsB,0BAA0B,qCAAqC,iBAAiB,kDAAkD,mBAAmB,SAAS,gCAAgC,wBAAwB,cAAc,WAAW,YAAY,gBAAgB,UAAU,oBAAoB,kBAAkB,kBAAkB,UAAU,aAAa,SAAS,OAAO,kBAAkB,QAAQ,MAAM,cAAc,gBAAgB,gBAAgB,iCAAiC,YAAY,kBAAkB,kBAAkB,kBAAkB,UAAU,sBAAsB,yBAAyB,YAAY,gBAAgB,aAAa;AACz7C,KAAK;AACL,IAAI,wDAAU,uBAAuB,wDAAU;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,mEAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAS,uDAAuD,6FAAuB;AAC/F;AACA;AACA;AACA;AACA,SAAS;AACT,0CAA0C,6FAAuB;AACjE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,sEAAwB,EAAE;AACtC,KAAK,OAAO,8DAAgB,EAAE;AAC9B,KAAK,yCAAyC,OAAO,oDAAM,SAAS,gEAAU,8BAA8B;AAC5G;AACA,yBAAyB,wDAAU;AACnC,IAAI,+DAAS;AACb;AACA;AACA,KAAK;AACL,IAAI,qDAAO,IAAI,4DAAM,CAAC,gEAAU;AAChC,IAAI,wDAAU,uBAAuB,sEAAwB;AAC7D,QAAQ,8DAAgB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,yDAAW;AACvB;AACA,wBAAwB,wDAAU;AAClC,IAAI,+DAAS,EAAE,6BAA6B;AAC5C,IAAI,wDAAU,uBAAuB,yDAAW;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,oDAAM;AAClB;AACA,uBAAuB,wDAAU;AACjC,IAAI,+DAAS;AACb;AACA;AACA,eAAe,sBAAsB;AACrC,yBAAyB,qEAAuB;AAChD,uBAAuB,+DAAiB;AACxC;AACA,wBAAwB,gEAAgE,+DAA+D,+DAA+D,8DAA8D,UAAU,kBAAkB,qCAAqC,kDAAkD,2BAA2B,cAAc,iBAAiB,kBAAkB,UAAU,2BAA2B,8GAA8G,yBAAyB,yBAAyB,gBAAgB,oBAAoB,uCAAuC,iBAAiB,sBAAsB,kBAAkB,sBAAsB,0BAA0B,qCAAqC,iBAAiB,kDAAkD,mBAAmB,SAAS,gCAAgC,wBAAwB,cAAc,WAAW,YAAY,gBAAgB,UAAU,oBAAoB,kBAAkB,kBAAkB,UAAU,YAAY,SAAS,WAAW,kBAAkB,yCAAyC,6CAA6C,YAAY,SAAS,mBAAmB,gDAAgD,YAAY,MAAM,0DAA0D,yBAAyB,yDAAyD,yBAAyB,uDAAuD,yBAAyB;AAChnD,KAAK;AACL,IAAI,wDAAU,uBAAuB,wDAAU;AAC/C,QAAQ,oDAAM;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU;AACtB;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd,IAAI,wDAAU;AACd;AACA,6BAA6B,wDAAU;AACvC,IAAI,+DAAS;AACb;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,IAAI,wDAAU,uBAAuB,wDAAU;AAC/C;;AAEA;AACA;AACA;AACA,oCAAoC,8FAA+B,EAAE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAO;AACxC;AACA;AACA;AACA;AACA,gCAAgC,0DAAY;AAC5C;AACA;AACA;AACA,sCAAsC,0DAAY;AAClD;AACA;AACA,YAAY,uDAAS;AACrB,sBAAsB,6FAAuB;AAC7C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iFAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0FAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,6FAAuB;AACzF;AACA,SAAS;AACT;AACA;AACA;AACA,oCAAoC,6FAAuB;AAC3D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAS;AACjB,kBAAkB,6FAAuB;AACzC;AACA;AACA,SAAS;AACT;AACA,QAAQ,uDAAS;AACjB,kBAAkB,6FAAuB;AACzC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6EAAc;AAC1B;AACA;AACA;AACA,iBAAiB,kEAAI;AACrB;AACA;AACA;AACA,iBAAiB,kEAAI;AACrB;AACA;AACA;AACA,iBAAiB,kEAAI;AACrB,iBAAiB,kEAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAK;AACb;AACA,kBAAkB,6FAAuB,QAAQ,gEAAS;AAC1D;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,8DAAgB;AAC5B;AACA,wDAAU;AACV,IAAI,kEAAY;AAChB,cAAc,yDAAW;AACzB;AACA,KAAK;AACL,IAAI,wDAAU,gBAAgB,yDAAW;AACzC;AACA,wDAAU;AACV,IAAI,+DAAS,CAAC,yDAAW,GAAG,eAAe;AAC3C,IAAI,wDAAU,gBAAgB,yDAAW;AACzC;AACA,wDAAU;AACV,IAAI,kEAAY;AAChB,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,iBAAiB,wDAAU;AAC3B,IAAI,+DAAS;AACb;AACA;AACA,yBAAyB,qEAAuB;AAChD,uBAAuB,+DAAiB;AACxC;AACA,KAAK;AACL,IAAI,wDAAU,uBAAuB,8DAAgB;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0DAAY;AACjD;AACA;AACA;AACA,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAY;AACnD;AACA;AACA;AACA,qCAAqC,0DAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0FAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6FAAuB;AACtD;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0BAA0B;AAC5D;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,qBAAqB;AACxF,QAAQ,+BAA+B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAK;AACzC,kBAAkB,6FAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,+DAAiB;AAC7B;AACA,wDAAU;AACV,IAA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","file":"tabs-tabs-module-ngfactory-es2015.js","sourcesContent":["import { __decorate, __metadata, __param } from 'tslib';\nimport { FocusKeyManager, A11yModule } from '@angular/cdk/a11y';\nimport { ObserversModule } from '@angular/cdk/observers';\nimport { TemplatePortal, CdkPortalOutlet, CdkPortal, PortalModule } from '@angular/cdk/portal';\nimport { CommonModule } from '@angular/common';\nimport { EventEmitter, ElementRef, Input, Output, Component, ChangeDetectionStrategy, ViewEncapsulation, ComponentFactoryResolver, ViewContainerRef, Inject, forwardRef, Directive, TemplateRef, NgZone, ChangeDetectorRef, ViewChild, ContentChildren, QueryList, ContentChild, NgModule } from '@angular/core';\nimport { FlexLayoutModule } from '@angular/flex-layout';\nimport { MatRippleModule } from '@angular/material/core';\nimport { distinctUntilChanged, startWith, takeUntil } from 'rxjs/operators';\nimport { untilComponentDestroyed } from '@terminus/ngx-tools/utilities';\nimport { Subject, fromEvent, timer, Subscription, merge } from 'rxjs';\nimport { isNumber } from '@terminus/ngx-tools/type-guards';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { coerceNumberProperty } from '@terminus/ngx-tools/coercion';\nimport { hasModifierKey } from '@angular/cdk/keycodes';\nimport { ViewportRuler } from '@angular/cdk/overlay';\nimport { normalizePassiveListenerOptions, Platform } from '@angular/cdk/platform';\nimport { KEYS } from '@terminus/ngx-tools/keycodes';\n\n/**\n * Animations used by {@link TsTabCollectionComponent}\n */\nconst tsTabsAnimations = {\n    // This animation translates a tab along the X axis\n    translateTab: trigger('translateTab', [\n        // Note: transitions to `none` instead of 0, because some browsers might blur the content.\n        state('center, void, left-origin-center, right-origin-center', style({ transform: 'none' })),\n        // NOTE:  If the tab is either on the left or right, we additionally add a `min-height` of 1px in order to ensure that the element has a\n        // height before its state changes. This is necessary because Chrome does seem to skip the transition in RTL mode if the element does\n        // not have a static height and is not rendered. See related issue: https://github.com/angular/material2/issues/9465\n        state('left', style({\n            minHeight: '1px',\n            opacity: 0,\n            transform: 'translate3d(-50%, 0, 0)',\n        })),\n        state('right', style({\n            opacity: 0,\n            minHeight: '1px',\n            transform: 'translate3d(50%, 0, 0)',\n        })),\n        transition('* => left, * => right, left => center, right => center', animate('200ms cubic-bezier(0.35, 0, 0.25, 1)')),\n        transition('void => left-origin-center', [\n            style({ transform: 'translate3d(-100%, 0, 0)' }),\n            animate('200ms cubic-bezier(0.35, 0, 0.25, 1)'),\n        ]),\n        transition('void => right-origin-center', [\n            style({ transform: 'translate3d(100%, 0, 0)' }),\n            animate('200ms cubic-bezier(0.35, 0, 0.25, 1)'),\n        ]),\n    ]),\n};\n\n// Unique ID for each instance\nlet nextUniqueId = 0;\n/**\n * A component that displays the tab content.\n *\n * NOTE: Only used internally.\n */\nlet TsTabBodyComponent = class TsTabBodyComponent {\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n        /**\n         * A unique ID per instance\n         */\n        this.id = nextUniqueId++;\n        /**\n         * Emits when an animation on the tab is complete\n         */\n        this.translateTabComplete = new Subject();\n        /**\n         * Event emitted when the tab begins to animate towards the center as the active tab\n         */\n        this.centering = new EventEmitter();\n        /**\n         * Event emitted before the centering of the tab begins\n         */\n        this.beforeCentering = new EventEmitter();\n        /**\n         * Event emitted after the tab has left the center position\n         */\n        this.afterLeavingCenter = new EventEmitter();\n        /**\n         * Event emitted when the tab completes its animation towards the center\n         */\n        this.centered = new EventEmitter(true);\n    }\n    /**\n     * Computes the position state based on the specified origin position.\n     * This is used if the tab is becoming visible immediately after creation.\n     */\n    get computedPositionFromOrigin() {\n        return (isNumber(this.origin) && (this.origin < 1)) ? 'left-origin-center' : 'right-origin-center';\n    }\n    /**\n     * Determine the computed position state that will be used for the tab-body animation trigger\n     */\n    get computedPositionAnimationState() {\n        // eslint-disable-next-line no-negated-condition\n        const position = !this.positionIndex\n            ? 'center'\n            : (this.positionIndex < 0)\n                ? 'left'\n                : (this.positionIndex > 0)\n                    ? 'right'\n                    : 'center';\n        return position;\n    }\n    /**\n     * The shifted index position of the tab body, where zero represents the active center tab.\n     *\n     * @param position\n     */\n    set position(position) {\n        this.positionIndex = position;\n        this.positionState = this.computedPositionAnimationState;\n    }\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the special position states that transition the tab\n     * from the left or right before centering.\n     */\n    ngOnInit() {\n        // Emit the correct events when a tab is moving\n        this.translateTabComplete.pipe(untilComponentDestroyed(this), \n        // Ensure that we get unique animation events, because the `.done` callback can get invoked twice in some browsers.\n        // See https://github.com/angular/angular/issues/24084.\n        distinctUntilChanged((x, y) => x.fromState === y.fromState && x.toState === y.toState)).subscribe(event => {\n            // If the transition to the center is complete, emit an event.\n            if (this.isCenterPosition(event.toState) && this.isCenterPosition(this.positionState)) {\n                this.centered.emit();\n            }\n            if (this.isCenterPosition(event.fromState) && !this.isCenterPosition(this.positionState)) {\n                this.afterLeavingCenter.emit();\n            }\n        });\n        if (this.positionState === 'center' && this.origin !== null) {\n            this.positionState = this.computedPositionFromOrigin;\n        }\n    }\n    ngOnDestroy() {\n        // Needed for untilComponentDestroyed\n    }\n    /**\n     * Emit events when a tab translation begins\n     *\n     * @param event - The animation event\n     */\n    onTranslateTabStarted(event) {\n        const isCentering = this.isCenterPosition(event.toState);\n        this.beforeCentering.emit(isCentering);\n        if (isCentering) {\n            this.centering.emit(this.elementRef.nativeElement.clientHeight);\n        }\n    }\n    /**\n     * Determine whether the provided position state is considered center (regardless of origin)\n     *\n     * @param position - The toState of the animation\n     * @returns True if in a center position\n     */\n    isCenterPosition(position) {\n        return position === 'center' || position === 'left-origin-center' || position === 'right-origin-center';\n    }\n};\nTsTabBodyComponent.ctorParameters = () => [\n    { type: ElementRef }\n];\n__decorate([\n    Input(),\n    __metadata(\"design:type\", TemplatePortal)\n], TsTabBodyComponent.prototype, \"content\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], TsTabBodyComponent.prototype, \"origin\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], TsTabBodyComponent.prototype, \"position\", null);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsTabBodyComponent.prototype, \"centering\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsTabBodyComponent.prototype, \"beforeCentering\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsTabBodyComponent.prototype, \"afterLeavingCenter\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsTabBodyComponent.prototype, \"centered\", void 0);\nTsTabBodyComponent = __decorate([\n    Component({\n        selector: 'ts-tab-body',\n        template: \"<div\\n  class=\\\"ts-tab-body__content\\\"\\n  #content\\n  [@translateTab]=\\\"{\\n    value: positionState\\n  }\\\"\\n  (@translateTab.start)=\\\"onTranslateTabStarted($event)\\\"\\n  (@translateTab.done)=\\\"translateTabComplete.next($event)\\\"\\n>\\n  <ng-template tsTabBodyHost></ng-template>\\n</div>\\n\",\n        host: { class: 'ts-tab-body' },\n        animations: [tsTabsAnimations.translateTab],\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        encapsulation: ViewEncapsulation.None,\n        exportAs: 'tsTabBody',\n        styles: [\":root{--swift-ease-out-duration:var(--ts-animation-time-duration-400);--swift-ease-out-timing-function:cubic-bezier(.25, .8, .25, 1);--swift-ease-in-duration:var(--ts-animation-time-duration-300);--swift-ease-in-timing-function:cubic-bezier(.55, 0, .55, .2)}.cdk-drag{position:relative}.cdk-drag:not(.cdk-drag-placeholder){transition:transform 250ms cubic-bezier(0,0,.2,1)}.cdk-drag .cdk-drag-handle{color:#cecdd1;cursor:ns-resize;position:absolute;right:8px}.cdk-drag.cdk-drag-preview{--shadow:0 5px 5px -3px rgba(0, 0, 0, .2),0 8px 10px 1px rgba(0, 0, 0, .14),0 3px 14px 2px rgba(0, 0, 0, .12);background-color:#fafafa;box-shadow:var(--shadow);min-height:50px;padding:0!important}.cdk-drag.cdk-drag-preview .c-checkbox{margin-left:16px}.cdk-drag-placeholder{--drop-bg:#cce8d5;--drop-border:#7fd09c;background:var(--drop-bg);border:2px dotted var(--drop-border);cursor:ns-resize;transition:transform 250ms cubic-bezier(0,0,.2,1)}.u-visually-hidden{border:0;-webkit-clip-path:rect(0,0,0,0);clip-path:rect(0,0,0,0);display:block;height:1px;margin:-1px;overflow:hidden;padding:0;pointer-events:none;position:absolute;visibility:hidden;width:1px}.ts-tab-body{bottom:0;left:0;position:absolute;right:0;top:0;display:block;flex-basis:100%;overflow:hidden}.ts-tab-body.ts-tab-body--active{flex-grow:1;overflow-x:hidden;overflow-y:hidden;position:relative;z-index:1}.ts-tab-body__content{background-color:#fafafa;height:100%;overflow:hidden;padding:16px}\"]\n    }),\n    __metadata(\"design:paramtypes\", [ElementRef])\n], TsTabBodyComponent);\n\n// Unique ID for each instance\nlet nextUniqueId$1 = 0;\n/**\n * The portal host directive for the contents of the tab.\n *\n * NOTE: Only used internally.\n */\nlet TsTabBodyHostDirective = class TsTabBodyHostDirective extends CdkPortalOutlet {\n    constructor(componentFactoryResolver, viewContainerRef, host) {\n        super(componentFactoryResolver, viewContainerRef);\n        this.host = host;\n        /**\n         * A unique ID per instance\n         */\n        this.id = nextUniqueId$1++;\n    }\n    /**\n     * Set initial visibility or set up subscription for changing visibility\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this.host.beforeCentering\n            .pipe(\n        // eslint-disable-next-line deprecation/deprecation\n        startWith(this.host.isCenterPosition(this.host.positionState)), untilComponentDestroyed(this))\n            .subscribe((isCentering) => {\n            if (isCentering && !this.hasAttached()) {\n                this.attach(this.host.content);\n            }\n        });\n        this.host.afterLeavingCenter.pipe(untilComponentDestroyed(this)).subscribe(() => {\n            this.detach();\n        });\n    }\n    /**\n     * Trigger ngOnDestroy in the parent class\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n    }\n};\nTsTabBodyHostDirective.ctorParameters = () => [\n    { type: ComponentFactoryResolver },\n    { type: ViewContainerRef },\n    { type: TsTabBodyComponent, decorators: [{ type: Inject, args: [forwardRef(() => TsTabBodyComponent),] }] }\n];\nTsTabBodyHostDirective = __decorate([\n    Directive({\n        selector: '[tsTabBodyHost]',\n        exportAs: 'tsTabBodyHost',\n    }),\n    __param(2, Inject(forwardRef(() => TsTabBodyComponent))),\n    __metadata(\"design:paramtypes\", [ComponentFactoryResolver,\n        ViewContainerRef,\n        TsTabBodyComponent])\n], TsTabBodyHostDirective);\n\n/**\n * Decorates the `ng-template` tags and reads out the template from it\n *\n * @example\n * <ts-tab label=\"My tab\">\n *              <ng-template tsTabContent>\n *                My tab content\n *              </ng-template>\n * </ts-tab>\n *\n * <example-url>https://getterminus.github.io/ui-demos-release/components/tabs</example-url>\n */\nlet TsTabContentDirective = class TsTabContentDirective {\n    constructor(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    template) {\n        this.template = template;\n    }\n};\nTsTabContentDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\nTsTabContentDirective = __decorate([\n    Directive({ selector: '[tsTabContent]' }),\n    __metadata(\"design:paramtypes\", [TemplateRef])\n], TsTabContentDirective);\n\n/**\n * The ink bar is used to display and animate the line underneath the current active tab label\n *\n * NOTE: Only used internally\n */\nlet TsTabInkBarComponent = class TsTabInkBarComponent {\n    constructor(elementRef, ngZone) {\n        this.elementRef = elementRef;\n        this.ngZone = ngZone;\n    }\n    /**\n     * Calculate the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     *\n     * @param element\n     */\n    alignToElement(element) {\n        if (typeof requestAnimationFrame === 'undefined') {\n            this.setStyles(element);\n        }\n        else {\n            this.ngZone.runOutsideAngular(() => {\n                requestAnimationFrame(() => this.setStyles(element));\n            });\n        }\n    }\n    /**\n     * Sets the proper styles to the ink bar element.\n     *\n     * @param element - The element to align the ink bar to\n     */\n    setStyles(element) {\n        const positions = this.determineInkBarPositions(element);\n        const inkBar = this.elementRef.nativeElement;\n        inkBar.style.left = positions.left;\n        inkBar.style.width = positions.width;\n    }\n    /**\n     * Return an object representing the correct ink bar positions\n     *\n     * @param element - The element to align the ink bar to\n     * @returns The object of positions\n     */\n    determineInkBarPositions(element) {\n        return {\n            left: element ? `${(element.offsetLeft || 0)}px` : '0',\n            width: element ? `${(element.offsetWidth || 0)}px` : '0',\n        };\n    }\n};\nTsTabInkBarComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone }\n];\nTsTabInkBarComponent = __decorate([\n    Component({\n        selector: 'ts-tab-ink-bar',\n        template: ``,\n        host: { class: 'ts-ink-bar' },\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        encapsulation: ViewEncapsulation.None,\n        exportAs: 'tsTabInkBar',\n        styles: [\":root{--swift-ease-out-duration:var(--ts-animation-time-duration-400);--swift-ease-out-timing-function:cubic-bezier(.25, .8, .25, 1);--swift-ease-in-duration:var(--ts-animation-time-duration-300);--swift-ease-in-timing-function:cubic-bezier(.55, 0, .55, .2)}.cdk-drag{position:relative}.cdk-drag:not(.cdk-drag-placeholder){transition:transform 250ms cubic-bezier(0,0,.2,1)}.cdk-drag .cdk-drag-handle{color:#cecdd1;cursor:ns-resize;position:absolute;right:8px}.cdk-drag.cdk-drag-preview{--shadow:0 5px 5px -3px rgba(0, 0, 0, .2),0 8px 10px 1px rgba(0, 0, 0, .14),0 3px 14px 2px rgba(0, 0, 0, .12);background-color:#fafafa;box-shadow:var(--shadow);min-height:50px;padding:0!important}.cdk-drag.cdk-drag-preview .c-checkbox{margin-left:16px}.cdk-drag-placeholder{--drop-bg:#cce8d5;--drop-border:#7fd09c;background:var(--drop-bg);border:2px dotted var(--drop-border);cursor:ns-resize;transition:transform 250ms cubic-bezier(0,0,.2,1)}.u-visually-hidden{border:0;-webkit-clip-path:rect(0,0,0,0);clip-path:rect(0,0,0,0);display:block;height:1px;margin:-1px;overflow:hidden;padding:0;pointer-events:none;position:absolute;visibility:hidden;width:1px}.ts-ink-bar{bottom:0;height:2px;position:absolute;transition:.2s cubic-bezier(.35,0,.25,1)}@media screen and (-ms-high-contrast:active){.ts-ink-bar{height:0;outline:solid 2px}}.ts-tab-collection--inverted-header .ts-ink-bar{bottom:auto;top:0}.ts-tab-collection.ts-tab-collection--primary .ts-ink-bar{background-color:#00538a}.ts-tab-collection.ts-tab-collection--accent .ts-ink-bar{background-color:#2f854d}.ts-tab-collection.ts-tab-collection--warn .ts-ink-bar{background-color:#c8604d}\"]\n    }),\n    __metadata(\"design:paramtypes\", [ElementRef,\n        NgZone])\n], TsTabInkBarComponent);\n\n/**\n * Used in the `ts-tab-collection` view to display tab labels\n *\n * NOTE: Only used internally\n */\nlet TsTabLabelWrapperDirective = class TsTabLabelWrapperDirective {\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n        // This is needed by the CdkListKeyManager - they are checking for `disabled` rather than `isDisabled`\n        this.disabled = false;\n        this._isDisabled = false;\n    }\n    /**\n     * Determine the left offset\n     */\n    get offsetLeft() {\n        return this.elementRef.nativeElement.offsetLeft;\n    }\n    /**\n     * Determine the offset width\n     */\n    get offsetWidth() {\n        return this.elementRef.nativeElement.offsetWidth;\n    }\n    /**\n     * Define if the label is disabled\n     *\n     * @param value\n     */\n    set isDisabled(value) {\n        this._isDisabled = value;\n        this.disabled = value;\n    }\n    get isDisabled() {\n        return this._isDisabled;\n    }\n    /**\n     * Set focus on the wrapper element\n     */\n    focus() {\n        this.elementRef.nativeElement.focus();\n    }\n};\nTsTabLabelWrapperDirective.ctorParameters = () => [\n    { type: ElementRef }\n];\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean),\n    __metadata(\"design:paramtypes\", [Boolean])\n], TsTabLabelWrapperDirective.prototype, \"isDisabled\", null);\nTsTabLabelWrapperDirective = __decorate([\n    Directive({\n        selector: '[tsTabLabelWrapper]',\n        host: {\n            '[class.ts-tab-label--disabled]': 'isDisabled',\n            '[attr.aria-disabled]': '!!isDisabled',\n        },\n    }),\n    __metadata(\"design:paramtypes\", [ElementRef])\n], TsTabLabelWrapperDirective);\n\n/**\n * Config used to bind passive event listeners\n */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps provide a small affordance to the label\n * next to it.\n */\nconst EXAGGERATED_OVERSCROLL = 60;\n/**\n * Amount of milliseconds to wait before starting to scroll the header automatically.\n *\n * NOTE: This is set a little conservatively in order to handle fake events dispatched on touch devices.\n */\nconst HEADER_SCROLL_DELAY = 650;\n/**\n * Interval in milliseconds at which to scroll the header while the user is holding their pointer.\n */\nconst HEADER_SCROLL_INTERVAL = 100;\n/**\n * The header of the tab collection which displays a list of all the tabs in the tab collection. Includes an ink bar that follows the\n * currently selected tab. When the tabs list's width exceeds the width of the header container, then arrows will be displayed to allow the\n * user to scroll left and right across the header.\n *\n * NOTE: Only used internally.\n */\nlet TsTabHeaderComponent = class TsTabHeaderComponent {\n    constructor(elementRef, changeDetectorRef, viewportRuler, ngZone, platform) {\n        this.elementRef = elementRef;\n        this.changeDetectorRef = changeDetectorRef;\n        this.viewportRuler = viewportRuler;\n        this.ngZone = ngZone;\n        this.platform = platform;\n        /**\n         * Whether the tab list can be scrolled more towards the end of the tab label list\n         */\n        this.disableScrollAfter = true;\n        /**\n         * Whether the tab list can be scrolled more towards the beginning of the tab label list\n         */\n        this.disableScrollBefore = true;\n        /**\n         * The distance in pixels that the tab labels should be translated to the left\n         */\n        this._scrollDistance = 0;\n        /**\n         * Whether the scroll distance has changed and should be applied after the view is checked\n         */\n        this.scrollDistanceChanged = false;\n        /**\n         * Whether the header should scroll to the selected index after the view has been checked\n         */\n        this.selectedIndexChanged = false;\n        /**\n         * Whether the controls for pagination should be displayed\n         */\n        this.showPaginationControls = false;\n        /**\n         * Stream that will stop the automated scrolling\n         */\n        this.stopScrolling = new Subject();\n        this._selectedIndex = 0;\n        /**\n         * Event emitted when a label is focused\n         */\n        this.indexFocused = new EventEmitter();\n        /**\n         * Event emitted when the option is selected\n         */\n        this.selectFocusedIndex = new EventEmitter();\n        const bindEvent = () => {\n            // eslint-disable-next-line deprecation/deprecation\n            fromEvent(elementRef.nativeElement, 'mouseleave')\n                .pipe(untilComponentDestroyed(this))\n                .subscribe(() => {\n                this.stopInterval();\n            });\n        };\n        // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.\n        ngZone.runOutsideAngular(bindEvent);\n    }\n    /**\n     * Manually set the focus to the correct label\n     *\n     * @param value\n     */\n    set focusIndex(value) {\n        if (!this.isValidIndex(value) || this.focusIndex === value || !this.keyManager) {\n            return;\n        }\n        this.keyManager.setActiveItem(value);\n    }\n    /**\n     * Tracks which element has focus (used for keyboard navigation)\n     */\n    get focusIndex() {\n        if (this.keyManager && isNumber(this.keyManager.activeItemIndex)) {\n            return this.keyManager.activeItemIndex;\n        }\n        return 0;\n    }\n    /**\n     * Sets the distance in pixels that the tab header should be transformed in the X-axis\n     *\n     * @param value\n     */\n    set scrollDistance(value) {\n        this.scrollTo(value);\n    }\n    get scrollDistance() {\n        return this._scrollDistance;\n    }\n    /**\n     * The index of the active tab\n     *\n     * @param value\n     */\n    set selectedIndex(value) {\n        value = coerceNumberProperty(value);\n        this.selectedIndexChanged = this._selectedIndex !== value;\n        this._selectedIndex = value;\n        if (this.keyManager) {\n            this.keyManager.updateActiveItem(value);\n        }\n    }\n    get selectedIndex() {\n        return this._selectedIndex;\n    }\n    /**\n     * After content is checked, update internals as needed\n     */\n    ngAfterContentChecked() {\n        // If the number of tab labels have changed, check if scrolling should be enabled\n        if (this.tabLabelCount !== this.labelWrappers.length) {\n            this.updatePagination();\n            this.tabLabelCount = this.labelWrappers.length;\n            this.changeDetectorRef.markForCheck();\n        }\n        // If the selected index has changed, scroll to the label and check if the scrolling controls\n        // should be disabled.\n        if (this.selectedIndexChanged) {\n            this.scrollToLabel(this.selectedIndex);\n            this.checkScrollingControls();\n            this.alignInkBarToSelectedTab();\n            this.selectedIndexChanged = false;\n            this.changeDetectorRef.markForCheck();\n        }\n        // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n        // then translate the header to reflect this.\n        if (this.scrollDistanceChanged) {\n            this.updateTabScrollPosition();\n            this.scrollDistanceChanged = false;\n            this.changeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * Align the {@link TsTabInkBarComponent} to the selected tab on load\n     */\n    ngAfterContentInit() {\n        const realign = () => {\n            this.updatePagination();\n            this.alignInkBarToSelectedTab();\n        };\n        const viewportDefaultThrottleMs = 150;\n        this.keyManager = new FocusKeyManager(this.labelWrappers)\n            .withHorizontalOrientation('ltr')\n            .withWrap();\n        this.keyManager.updateActiveItem(0);\n        // Defer the first call in order to allow for slower browsers to lay out the elements.\n        // This helps in cases where the user lands directly on a page with paginated tabs.\n        typeof requestAnimationFrame === 'undefined' ? realign() : requestAnimationFrame(realign);\n        // On window resize, realign the ink bar.\n        this.viewportRuler.change(viewportDefaultThrottleMs).pipe(untilComponentDestroyed(this)).subscribe(() => {\n            realign();\n        });\n        // If there is a change in the focus key manager we need to emit the `indexFocused`\n        // event in order to provide a public event that notifies about focus changes. Also we realign\n        // the tabs container by scrolling the new focused tab into the visible section.\n        this.keyManager.change.pipe(untilComponentDestroyed(this)).subscribe(newFocusIndex => {\n            this.indexFocused.emit(newFocusIndex);\n            this.setTabFocus(newFocusIndex);\n        });\n    }\n    /**\n     * Wire up listeners for pagination clicks\n     * NOTE: We need to handle these events manually because we want to bind passive event listeners.\n     */\n    ngAfterViewInit() {\n        // eslint-disable-next-line deprecation/deprecation\n        fromEvent(this.previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n            .pipe(untilComponentDestroyed(this))\n            .subscribe(() => {\n            this.handlePaginatorPress('before');\n        });\n        // eslint-disable-next-line deprecation/deprecation\n        fromEvent(this.nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n            .pipe(untilComponentDestroyed(this))\n            .subscribe(() => {\n            this.handlePaginatorPress('after');\n        });\n    }\n    /**\n     * Needed for untilComponentDestroyed\n     */\n    ngOnDestroy() { }\n    /**\n     * Handle keyboard events on the header\n     *\n     * @param event - The keyboard event\n     */\n    handleKeydown(event) {\n        // We don't handle any key bindings with a modifier key.\n        if (hasModifierKey(event)) {\n            return;\n        }\n        switch (event.code) {\n            case KEYS.HOME.code:\n                this.keyManager.setFirstItemActive();\n                event.preventDefault();\n                break;\n            case KEYS.END.code:\n                this.keyManager.setLastItemActive();\n                event.preventDefault();\n                break;\n            case KEYS.ENTER.code:\n            case KEYS.SPACE.code:\n                this.selectFocusedIndex.emit(this.focusIndex);\n                event.preventDefault();\n                break;\n            default:\n                this.keyManager.onKeydown(event);\n        }\n    }\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     */\n    onContentChanges() {\n        const textContent = this.elementRef.nativeElement.textContent;\n        // We need to diff the text content of the header, because the MutationObserver callback will fire even if the text content didn't\n        // change which is inefficient and is prone to infinite loops if a poorly constructed expression is passed in.\n        // See https://github.com/angular/material2/issues/14249\n        if (textContent !== this.currentTextContent) {\n            this.currentTextContent = textContent;\n            const zoneCallback = () => {\n                this.updatePagination();\n                this.alignInkBarToSelectedTab();\n                this.changeDetectorRef.markForCheck();\n            };\n            // The content observer runs outside the `NgZone` by default, which means that we need to bring the callback back in ourselves\n            this.ngZone.run(zoneCallback);\n        }\n    }\n    /**\n     * Handle click events on the pagination arrows\n     *\n     * @param direction - The scroll direction\n     */\n    handlePaginatorClick(direction) {\n        this.stopInterval();\n        this.scrollHeader(direction);\n    }\n    /**\n     * Tell the {@link TsInkBarComponent} to align itself to the current label wrapper\n     */\n    alignInkBarToSelectedTab() {\n        const labelWrappersExist = this.labelWrappers && this.labelWrappers.length;\n        const selectedLabelWrapper = labelWrappersExist ? this.labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement : null;\n        this.inkBar.alignToElement(selectedLabelWrapper);\n    }\n    /**\n     * Stop the currently-running paginator interval\n     */\n    stopInterval() {\n        this.stopScrolling.next();\n    }\n    /**\n     * Handles the user pressing down on one of the paginators.\n     *\n     * Starts scrolling the header after a certain amount of time.\n     *\n     * @param direction - The direction to scroll\n     */\n    handlePaginatorPress(direction) {\n        // Avoid overlapping timers.\n        this.stopInterval();\n        // Start a timer after the delay and keep firing based on the interval\n        timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)\n            // Keep the timer going until something tells it to stop or the component is destroyed\n            .pipe(untilComponentDestroyed(this), takeUntil(this.stopScrolling))\n            .subscribe(() => {\n            const { maxScrollDistance, distance } = this.scrollHeader(direction);\n            // Stop the timer if we've reached the start or the end\n            if (distance === 0 || distance >= maxScrollDistance) {\n                this.stopInterval();\n            }\n        });\n    }\n    /**\n     * Updates the view whether pagination should be enabled or not\n     *\n     * NOTE: Calling this method can be very costly in terms of performance.  It should be called as infrequently as possible from outside\n     * of the {@link TsTabComponent} as it causes a reflow of the page.\n     */\n    updatePagination() {\n        this.checkPaginationEnabled();\n        this.checkScrollingControls();\n        this.updateTabScrollPosition();\n    }\n    /**\n     * Determines if an index is valid\n     *\n     * If the tabs are not ready yet, we assume that the user is providing a valid index and return true.\n     *\n     * @param index - The index to check\n     */\n    isValidIndex(index) {\n        if (!this.labelWrappers) {\n            return true;\n        }\n        const tab = this.labelWrappers.toArray()[index] || null;\n        return !!tab && !tab.isDisabled;\n    }\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if scrolling is enabled\n     *\n     * @param tabIndex - The index of the tab to focus\n     */\n    setTabFocus(tabIndex) {\n        if (this.showPaginationControls) {\n            this.scrollToLabel(tabIndex);\n        }\n        if (this.labelWrappers && this.labelWrappers.length) {\n            this.labelWrappers.toArray()[tabIndex].focus();\n            // Do not let the browser manage scrolling to focus the element, this will be handled by using translation.\n            this.tabListContainer.nativeElement.scrollLeft = 0;\n        }\n    }\n    /**\n     * Perform the CSS transformation on the tab list that will cause the list to scroll\n     */\n    updateTabScrollPosition() {\n        const scrollDistance = this.scrollDistance;\n        const platform = this.platform;\n        const translateX = -scrollDistance;\n        // Don't use `translate3d` here because we don't want to create a new layer. A new layer seems to cause flickering and overflow in\n        // Internet Explorer. For example, the ink bar and ripples will exceed the boundaries of the visible tab bar.\n        // See https://github.com/angular/material2/issues/10276\n        //\n        // We round the `transform` here, because transforms with sub-pixel precision cause some browsers to blur the content of the element.\n        const value = Math.round(translateX);\n        this.tabList.nativeElement.style.transform = `translateX(${value}px)`;\n        // Setting the `transform` on IE will change the scroll offset of the parent, causing the position to be thrown off in some cases. We\n        // have to reset it ourselves to ensure that it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing with\n        // the scroll position throws off Chrome 71+ in RTL mode.\n        // See https://github.com/angular/material2/issues/14689\n        if (platform.TRIDENT || platform.EDGE) {\n            this.tabListContainer.nativeElement.scrollLeft = 0;\n        }\n    }\n    /**\n     * Move the tab list in the 'before' or 'after' direction (towards the beginning of the list or the end of the list, respectively).\n     * The distance to scroll is computed to be a third of the length of the tab list view window.\n     *\n     * NOTE: This is an expensive call that forces a layout reflow to compute box and scroll metrics and should be called sparingly.\n     *\n     * @param direction - The scroll direction\n     * @returns An object defining scroll limitations\n     */\n    scrollHeader(direction) {\n        const viewLength = this.tabListContainer.nativeElement.offsetWidth;\n        // Move the scroll distance one-third the length of the tab list's viewport.\n        // eslint-disable-next-line @typescript-eslint/no-magic-numbers\n        const scrollAmount = (direction === 'before' ? -1 : 1) * viewLength / 3;\n        return this.scrollTo(this._scrollDistance + scrollAmount);\n    }\n    /**\n     * Move the tab list such that the desired tab label (marked by index) is moved into view\n     *\n     * NOTE: This is an expensive call that forces a layout reflow to compute box and scroll metrics and should be called sparingly.\n     *\n     * @param labelIndex - The index of the label to scroll into view\n     */\n    scrollToLabel(labelIndex) {\n        const selectedLabel = this.labelWrappers ? this.labelWrappers.toArray()[labelIndex] : null;\n        if (!selectedLabel) {\n            return;\n        }\n        const viewLength = this.tabListContainer.nativeElement.offsetWidth;\n        const labelBeforePosition = selectedLabel.offsetLeft;\n        const labelAfterPosition = labelBeforePosition + selectedLabel.offsetWidth;\n        const beforeVisiblePosition = this.scrollDistance;\n        const afterVisiblePosition = this.scrollDistance + viewLength;\n        if (labelBeforePosition < beforeVisiblePosition) {\n            // Scroll header to move label to the 'before' direction\n            this.scrollDistance -= beforeVisiblePosition - labelBeforePosition + EXAGGERATED_OVERSCROLL;\n        }\n        else if (labelAfterPosition > afterVisiblePosition) {\n            // Scroll header to move label to the 'after' direction\n            this.scrollDistance += labelAfterPosition - afterVisiblePosition + EXAGGERATED_OVERSCROLL;\n        }\n    }\n    /**\n     * Evaluate whether the pagination controls should be displayed\n     *\n     * If the scroll width of the tab list is wider than the size of the header container, then the pagination controls should be shown.\n     *\n     * NOTE: This is an expensive call that forces a layout reflow to compute box and scroll metrics and should be called sparingly.\n     */\n    checkPaginationEnabled() {\n        const isEnabled = this.tabList.nativeElement.scrollWidth > this.elementRef.nativeElement.offsetWidth;\n        if (!isEnabled) {\n            this.scrollDistance = 0;\n        }\n        if (isEnabled !== this.showPaginationControls) {\n            this.changeDetectorRef.markForCheck();\n        }\n        this.showPaginationControls = isEnabled;\n    }\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     *\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the before button. If the header is at the\n     * end of the list (scroll distance is equal to the maximum distance we can scroll), then disable the after button.\n     *\n     * NOTE: This is an expensive call that forces a layout reflow to compute box and scroll metrics and should be called sparingly.\n     */\n    checkScrollingControls() {\n        this.disableScrollBefore = this.scrollDistance === 0;\n        this.disableScrollAfter = this.scrollDistance === this.getMaxScrollDistance();\n        this.changeDetectorRef.markForCheck();\n    }\n    /**\n     * Determine what is the maximum length in pixels that can be set for the scroll distance\n     *\n     * This is equal to the difference in width between the tab list container and tab header container.\n     *\n     * NOTE: This is an expensive call that forces a layout reflow to compute box and scroll metrics and should be called sparingly.\n     *\n     * @returns The maximum scroll distance\n     */\n    getMaxScrollDistance() {\n        const lengthOfTabList = this.tabList.nativeElement.scrollWidth;\n        const viewLength = this.tabListContainer.nativeElement.offsetWidth;\n        return (lengthOfTabList - viewLength) || 0;\n    }\n    /**\n     * Scroll the header to a given position\n     *\n     * @param position - The position to scroll to\n     * @returns An object defining the desired scroll position\n     */\n    scrollTo(position) {\n        const maxScrollDistance = this.getMaxScrollDistance();\n        this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));\n        // Mark that the scroll distance has changed so that after the view is checked, the CSS transformation can move the header\n        this.scrollDistanceChanged = true;\n        this.checkScrollingControls();\n        return {\n            maxScrollDistance,\n            distance: this._scrollDistance,\n        };\n    }\n};\nTsTabHeaderComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: ChangeDetectorRef },\n    { type: ViewportRuler },\n    { type: NgZone },\n    { type: Platform }\n];\n__decorate([\n    ViewChild(TsTabInkBarComponent, { static: true }),\n    __metadata(\"design:type\", TsTabInkBarComponent)\n], TsTabHeaderComponent.prototype, \"inkBar\", void 0);\n__decorate([\n    ViewChild('previousPaginator', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], TsTabHeaderComponent.prototype, \"previousPaginator\", void 0);\n__decorate([\n    ViewChild('nextPaginator', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], TsTabHeaderComponent.prototype, \"nextPaginator\", void 0);\n__decorate([\n    ViewChild('tabListContainer', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], TsTabHeaderComponent.prototype, \"tabListContainer\", void 0);\n__decorate([\n    ViewChild('tabList', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], TsTabHeaderComponent.prototype, \"tabList\", void 0);\n__decorate([\n    ContentChildren(TsTabLabelWrapperDirective),\n    __metadata(\"design:type\", QueryList)\n], TsTabHeaderComponent.prototype, \"labelWrappers\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], TsTabHeaderComponent.prototype, \"selectedIndex\", null);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsTabHeaderComponent.prototype, \"indexFocused\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsTabHeaderComponent.prototype, \"selectFocusedIndex\", void 0);\nTsTabHeaderComponent = __decorate([\n    Component({\n        selector: 'ts-tab-header',\n        template: \"<div\\n  class=\\\"ts-tab-header__pagination ts-tab-header__pagination--before mat-elevation-z4\\\"\\n  #previousPaginator\\n  aria-hidden=\\\"true\\\"\\n  mat-ripple\\n  [matRippleDisabled]=\\\"disableScrollBefore\\\"\\n  [class.ts-tab-header__pagination--disabled]=\\\"disableScrollBefore\\\"\\n  (click)=\\\"handlePaginatorClick('before')\\\"\\n  (mousedown)=\\\"handlePaginatorPress('before')\\\"\\n  (touchend)=\\\"stopInterval()\\\"\\n>\\n  <div class=\\\"ts-tab-header__pagination-chevron\\\"></div>\\n</div>\\n\\n\\n<div\\n  class=\\\"ts-tab-header__labels-container\\\"\\n  #tabListContainer\\n  (keydown)=\\\"handleKeydown($event)\\\"\\n>\\n  <div\\n    class=\\\"ts-tab-header__labels-container-inner\\\"\\n    #tabList\\n    role=\\\"tablist\\\"\\n    (cdkObserveContent)=\\\"onContentChanges()\\\"\\n  >\\n    <div class=\\\"ts-tab-header__labels\\\">\\n      <ng-content></ng-content>\\n    </div>\\n\\n    <ts-tab-ink-bar></ts-tab-ink-bar>\\n  </div>\\n</div>\\n\\n\\n<div\\n  class=\\\"ts-tab-header__pagination ts-tab-header__pagination--after mat-elevation-z4\\\"\\n  #nextPaginator\\n  aria-hidden=\\\"true\\\"\\n  mat-ripple\\n  [matRippleDisabled]=\\\"disableScrollAfter\\\"\\n  [class.ts-tab-header__pagination--disabled]=\\\"disableScrollAfter\\\"\\n  (mousedown)=\\\"handlePaginatorPress('after')\\\"\\n  (click)=\\\"handlePaginatorClick('after')\\\"\\n  (touchend)=\\\"stopInterval()\\\"\\n>\\n  <div class=\\\"ts-tab-header__pagination-chevron\\\"></div>\\n</div>\\n\",\n        host: {\n            'class': 'ts-tab-header',\n            '[class.ts-tab-header__pagination--enabled]': 'showPaginationControls',\n        },\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        encapsulation: ViewEncapsulation.None,\n        exportAs: 'tsTabHeader',\n        styles: [\":root{--swift-ease-out-duration:var(--ts-animation-time-duration-400);--swift-ease-out-timing-function:cubic-bezier(.25, .8, .25, 1);--swift-ease-in-duration:var(--ts-animation-time-duration-300);--swift-ease-in-timing-function:cubic-bezier(.55, 0, .55, .2)}.cdk-drag{position:relative}.cdk-drag:not(.cdk-drag-placeholder){transition:transform 250ms cubic-bezier(0,0,.2,1)}.cdk-drag .cdk-drag-handle{color:#cecdd1;cursor:ns-resize;position:absolute;right:8px}.cdk-drag.cdk-drag-preview{--shadow:0 5px 5px -3px rgba(0, 0, 0, .2),0 8px 10px 1px rgba(0, 0, 0, .14),0 3px 14px 2px rgba(0, 0, 0, .12);background-color:#fafafa;box-shadow:var(--shadow);min-height:50px;padding:0!important}.cdk-drag.cdk-drag-preview .c-checkbox{margin-left:16px}.cdk-drag-placeholder{--drop-bg:#cce8d5;--drop-border:#7fd09c;background:var(--drop-bg);border:2px dotted var(--drop-border);cursor:ns-resize;transition:transform 250ms cubic-bezier(0,0,.2,1)}.u-visually-hidden{border:0;-webkit-clip-path:rect(0,0,0,0);clip-path:rect(0,0,0,0);display:block;height:1px;margin:-1px;overflow:hidden;padding:0;pointer-events:none;position:absolute;visibility:hidden;width:1px}.ts-tab-header{border-bottom:1px solid #cecdd1;display:flex;flex-shrink:0;overflow:hidden;position:relative}.ts-tab-label{align-items:center;box-sizing:border-box;color:#302d35;cursor:pointer;display:inline-flex;height:48px;justify-content:center;opacity:.6;padding:0 24px;position:relative;text-align:center;white-space:nowrap}.ts-tab-label:focus{outline:0}.ts-tab-label:focus:not(.ts-tab-label--disabled){opacity:1}.ts-tab-label.ts-tab-label--disabled{color:#cecdd1;cursor:not-allowed}@media screen and (-ms-high-contrast:active){.ts-tab-label{opacity:1}.ts-tab-label:focus{outline:dotted 2px}.ts-tab-label.ts-tab-label--disabled{opacity:.5}}.ts-tab-label .ts-tab-label__content{overflow:hidden;text-overflow:ellipsis;align-items:center;display:inline-block;justify-content:center;white-space:nowrap}.ts-tab-header__pagination{align-items:center;cursor:pointer;display:none;justify-content:center;min-width:32px;position:relative;-webkit-tap-highlight-color:transparent;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}.ts-tab-header__pagination--enabled .ts-tab-header__pagination{display:flex}.ts-tab-header__pagination .ts-tab-header__pagination-chevron{border-color:#302d35;border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.ts-tab-header__pagination--before{padding-left:4px}.ts-tab-header__pagination--before .ts-tab-header__pagination-chevron{transform:rotate(-135deg)}.ts-tab-header__pagination--after{padding-right:4px}.ts-tab-header__pagination--after .ts-tab-header__pagination-chevron{transform:rotate(45deg)}.ts-tab-header__pagination--disabled{box-shadow:none;cursor:default}.ts-tab-header__pagination--disabled .ts-tab-header__pagination-chevron{color:#999}.ts-tab-header__labels-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.ts-tab-header__labels-container-inner{flex-grow:1;position:relative;transition:transform .2s cubic-bezier(.35,0,.25,1)}.ts-tab-header__labels{display:flex}.ts-tab-collection.ts-tab-collection--primary .ts-tab-label{transition:background-color .2s cubic-bezier(.35,0,.25,1)}.ts-tab-collection.ts-tab-collection--primary .ts-tab-label:not(.ts-tab-label--disabled):focus{color:#00538a}.ts-tab-collection.ts-tab-collection--primary .ts-tab-label:not(.ts-tab-label--disabled):hover{background-color:rgba(0,83,138,.2);color:#00538a}.ts-tab-collection.ts-tab-collection--accent .ts-tab-label{transition:background-color .2s cubic-bezier(.35,0,.25,1)}.ts-tab-collection.ts-tab-collection--accent .ts-tab-label:not(.ts-tab-label--disabled):focus{color:#2f854d}.ts-tab-collection.ts-tab-collection--accent .ts-tab-label:not(.ts-tab-label--disabled):hover{background-color:rgba(47,133,77,.2);color:#2f854d}.ts-tab-collection.ts-tab-collection--warn .ts-tab-label{transition:background-color .2s cubic-bezier(.35,0,.25,1)}.ts-tab-collection.ts-tab-collection--warn .ts-tab-label:not(.ts-tab-label--disabled):focus{color:#c8604d}.ts-tab-collection.ts-tab-collection--warn .ts-tab-label:not(.ts-tab-label--disabled):hover{background-color:rgba(200,96,77,.2);color:#c8604d}.ts-tab-collection.ts-tab-collection--start .ts-tab-header__labels{justify-content:flex-start}.ts-tab-collection.ts-tab-collection--center .ts-tab-header__labels{justify-content:center}.ts-tab-collection.ts-tab-collection--end .ts-tab-header__labels{justify-content:flex-end}.ts-tab-collection.ts-tab-collection--stretch .ts-tab-header__labels .ts-tab-label{flex:1}.ts-tab-collection.ts-tab-collection--inverted-header .ts-tab-header{border-bottom:none;border-top:1px solid #cecdd1}\"]\n    }),\n    __metadata(\"design:paramtypes\", [ElementRef,\n        ChangeDetectorRef,\n        ViewportRuler,\n        NgZone,\n        Platform])\n], TsTabHeaderComponent);\n\n/**\n * Used to flag tab labels for use with the portal directive\n */\nlet TsTabLabelDirective = class TsTabLabelDirective extends CdkPortal {\n};\nTsTabLabelDirective = __decorate([\n    Directive({\n        selector: '[tsTabLabel]',\n        exportAs: 'tsTabLabel',\n    })\n], TsTabLabelDirective);\n\n// Unique ID for each instance\nlet nextUniqueId$2 = 0;\n/**\n * An individual tab component\n *\n * @example\n * <ts-tab\n *               ariaLabel=\"My label\"\n *               ariaLabelledby=\"myId\"\n *               [isDisabled]=\"true\"\n *               label=\"First\"\n * >\n *               My tab content!\n * </ts-tab>\n *\n * <example-url>https://getterminus.github.io/ui-demos-release/components/tabs</example-url>\n */\nlet TsTabComponent = class TsTabComponent {\n    constructor(viewContainerRef) {\n        this.viewContainerRef = viewContainerRef;\n        /**\n         * Define a unique ID for every instance\n         */\n        this.id = nextUniqueId$2++;\n        /**\n         * Portal that will be the hosted content of the tab\n         */\n        this.contentPortal = null;\n        /**\n         * Emits whenever the internal state of the tab changes\n         */\n        this.stateChanges = new Subject();\n        /**\n         * The relatively indexed position where 0 represents the center, negative numbers are left, and positive numbers represent the right.\n         */\n        this.position = null;\n        /**\n         * The initial relatively index origin of the tab if it was created and selected after there was already a selected tab.\n         * Provides context of what position the tab should originate from.\n         */\n        this.origin = null;\n        /**\n         * Whether the tab is currently active\n         */\n        this.isActive = false;\n        /**\n         * Define if the tab is disabled\n         */\n        this.isDisabled = false;\n        /**\n         * Simple text label for the tab (used when there is no template label)\n         */\n        this.label = '';\n    }\n    /**\n     * Provides quick access to the content portal\n     */\n    get content() {\n        return this.contentPortal;\n    }\n    /**\n     * Inject the tab content\n     */\n    ngOnInit() {\n        this.contentPortal = new TemplatePortal(this.explicitContent || this.implicitContent, this.viewContainerRef);\n    }\n    /**\n     * Trigger event emitter for property changes\n     *\n     * @param changes\n     */\n    ngOnChanges(changes) {\n        if (changes.hasOwnProperty('label') || changes.hasOwnProperty('isDisabled')) {\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Clean up any subscriptions\n     */\n    ngOnDestroy() {\n        this.stateChanges.complete();\n    }\n};\nTsTabComponent.ctorParameters = () => [\n    { type: ViewContainerRef }\n];\n__decorate([\n    ContentChild(TsTabContentDirective, {\n        read: TemplateRef,\n        static: true,\n    }),\n    __metadata(\"design:type\", TemplateRef)\n], TsTabComponent.prototype, \"explicitContent\", void 0);\n__decorate([\n    ViewChild(TemplateRef, { static: true }),\n    __metadata(\"design:type\", TemplateRef)\n], TsTabComponent.prototype, \"implicitContent\", void 0);\n__decorate([\n    ContentChild(TsTabLabelDirective),\n    __metadata(\"design:type\", TsTabLabelDirective)\n], TsTabComponent.prototype, \"templateLabel\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsTabComponent.prototype, \"ariaLabel\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsTabComponent.prototype, \"ariaLabelledby\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsTabComponent.prototype, \"isDisabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], TsTabComponent.prototype, \"label\", void 0);\nTsTabComponent = __decorate([\n    Component({\n        selector: 'ts-tab',\n        template: \"<ng-template>\\n  <ng-content></ng-content>\\n</ng-template>\\n\",\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        encapsulation: ViewEncapsulation.None,\n        exportAs: 'tsTab'\n    }),\n    __metadata(\"design:paramtypes\", [ViewContainerRef])\n], TsTabComponent);\n\n/**\n * A change event emitted on focus or selection changes\n */\nclass TsTabChangeEvent {\n    constructor(index, tab) {\n        this.index = index;\n        this.tab = tab;\n    }\n}\n// Unique ID for each instance\nlet nextUniqueId$3 = 0;\n/**\n * A collection of {@link TsTabComponent}s\n *\n * @example\n * <ts-tab-collection\n *               headerPosition=\"above\"\n *               [selectedIndex]=\"2\"\n *               tabAlignment=\"start\"\n *               theme=\"primary\"\n *               (animationFinished)=\"myFunc()\"\n *               (focusChange)=\"myFunc($event)\"\n *               (selectedIndexChange)=\"myFunc($event)\"\n *               (selectedTabChange)=\"myFunc($event)\"\n * >\n *              <ts-tab label=\"First\">\n *                Content 1\n *              </ts-tab>\n *\n *              <ts-tab label=\"Second\">\n *                Content 2\n *              </ts-tab>\n * </ts-tab-collection>\n *\n * <example-url>https://getterminus.github.io/ui-demos-release/components/tabs</example-url>\n */\nlet TsTabCollectionComponent = class TsTabCollectionComponent {\n    constructor(changeDetectorRef) {\n        this.changeDetectorRef = changeDetectorRef;\n        /**\n         * A unique ID per instance\n         */\n        this.collectionId = nextUniqueId$3++;\n        /**\n         * Internal reference used to enable two-way binding for `selectedIndex`\n         */\n        this._indexToSelect = 0;\n        /**\n         * Snapshot of the height of the tab body wrapper before another tab is activated\n         */\n        this.tabBodyWrapperHeight = 0;\n        /**\n         * Subscription to changes in the tab labels\n         */\n        this.tabLabelSubscription = Subscription.EMPTY;\n        /**\n         * Define the position of the tab header\n         */\n        this.headerPosition = 'above';\n        this._selectedIndex = null;\n        /**\n         * Define the horizontal layout for the tabs\n         */\n        this.tabAlignment = 'start';\n        /**\n         * Define the theme for the tabs\n         */\n        this.theme = 'primary';\n        /**\n         * Event emitted when the body animation has completed\n         */\n        this.animationFinished = new EventEmitter();\n        /**\n         * Event emitted when focus has changed within a tab collection\n         */\n        this.focusChange = new EventEmitter();\n        /**\n         * Event emitted when the selected index changes.\n         *\n         * NOTE: This is to enable support for two-way binding on `[(selectedIndex)]`\n         */\n        this.selectedIndexChange = new EventEmitter();\n        /**\n         * Event emitted when the tab selection has changed\n         */\n        this.selectedTabChange = new EventEmitter(true);\n    }\n    /**\n     * Define the index of the active tab\n     *\n     * @param value - The index to select\n     */\n    set selectedIndex(value) {\n        this._indexToSelect = coerceNumberProperty(value, null);\n    }\n    get selectedIndex() {\n        return this._selectedIndex;\n    }\n    /**\n     * Set up tab and label subscriptions\n     */\n    ngAfterContentInit() {\n        this.subscribeToTabLabels();\n        // Subscribe to changes in the amount of tabs, in order to be able to re-render the content as new tabs are added or removed\n        this.tabs.changes.pipe(untilComponentDestroyed(this)).subscribe(() => {\n            const indexToSelect = this.clampTabIndex(this._indexToSelect);\n            // Maintain the previously-selected tab if a new tab is added or removed and there is no explicit change that selects a different tab\n            if (indexToSelect === this._selectedIndex) {\n                const tabs = this.tabs.toArray();\n                for (let i = 0; i < tabs.length; i++) {\n                    if (tabs[i].isActive) {\n                        this._indexToSelect = this._selectedIndex = i;\n                        break;\n                    }\n                }\n            }\n            this.subscribeToTabLabels();\n            this.changeDetectorRef.markForCheck();\n        });\n    }\n    /**\n     * After the content is checked, this component knows what tabs have been defined and what the selected index should be. This is where we\n     * can know exactly what position each tab should be in according to the new selected index, and additionally we know how a new selected\n     * tab should transition in (from the left or right).\n     */\n    ngAfterContentChecked() {\n        // Don't clamp the `selectedIndex` immediately in the setter because it can happen that the amount of tabs changes before the actual\n        // change detection runs\n        const indexToSelect = this._indexToSelect = this.clampTabIndex(this._indexToSelect);\n        // If there is a change in selected index, emit a change event.\n        // This should not trigger if the selected index has not yet been initialized.\n        if (this._selectedIndex !== indexToSelect) {\n            const isFirstRun = this.selectedIndex === null;\n            if (!isFirstRun) {\n                this.selectedTabChange.emit(this.createChangeEvent(indexToSelect));\n            }\n            // Defer changing these values until after change detection has run since the checked content may contain references to them\n            Promise.resolve().then(() => {\n                this.tabs.forEach((tab, index) => {\n                    tab.isActive = index === indexToSelect;\n                    return tab.isActive;\n                });\n                if (!isFirstRun) {\n                    this.selectedIndexChange.emit(indexToSelect);\n                }\n            });\n        }\n        // Set up the position for each tab and optionally setup an origin on the next selected tab\n        this.tabs.forEach((tab, index) => {\n            tab.position = index - indexToSelect;\n            // If there is already a selected tab, then set up an origin for the next selected tab if it doesn't have one already\n            if (this._selectedIndex !== null && tab.position === 0 && !tab.origin) {\n                tab.origin = indexToSelect - this._selectedIndex;\n            }\n        });\n        if (this._selectedIndex !== indexToSelect) {\n            this._selectedIndex = indexToSelect;\n            this.changeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * Needed for untilComponentDestroyed\n     */\n    ngOnDestroy() { }\n    /**\n     * Re-align the ink bar to the selected tab element\n     */\n    realignInkBar() {\n        // istanbul ignore else\n        if (this.tabHeader) {\n            this.tabHeader.alignInkBarToSelectedTab();\n        }\n    }\n    /**\n     * Emit an event for focus change\n     *\n     * @param index - The focused index\n     */\n    focusChanged(index) {\n        this.focusChange.emit(this.createChangeEvent(index));\n    }\n    /**\n     * Set the height of the body wrapper to the height of the activating tab\n     *\n     * @param tabHeight - The desired tab height\n     */\n    setTabBodyWrapperHeight(tabHeight) {\n        if (!this.tabBodyWrapperHeight) {\n            return;\n        }\n        const wrapper = this.tabBodyWrapper.nativeElement;\n        wrapper.style.height = `${this.tabBodyWrapperHeight}px`;\n        // NOTE: This conditional forces the browser to paint the height so that the animation to the new height can have an origin\n        if (this.tabBodyWrapper.nativeElement.offsetHeight) {\n            wrapper.style.height = `${tabHeight}px`;\n        }\n    }\n    /**\n     * Remove the height of the tab body wrapper\n     */\n    removeTabBodyWrapperHeight() {\n        const wrapper = this.tabBodyWrapper.nativeElement;\n        this.tabBodyWrapperHeight = wrapper.clientHeight;\n        wrapper.style.height = '';\n        this.animationFinished.emit();\n    }\n    /**\n     * Handle click events & set a new selected index if appropriate\n     *\n     * @param tab - The tab that was clicked\n     * @param tabHeader - The header of the tab that was clicked\n     * @param index - The index of the tab that was clicked\n     */\n    handleClick(tab, tabHeader, index) {\n        if (!tab.isDisabled) {\n            this.selectedIndex = tabHeader.focusIndex = index;\n        }\n    }\n    /**\n     * Subscribes to changes in the tab labels.\n     *\n     * This is needed, because the @Input for the label is on the {@link TsTabComponent}, whereas the data binding is inside the\n     * {@link TsTabCollectionComponent}. In order for the binding to be updated, we need to subscribe to changes in it and trigger change\n     * detection manually.\n     */\n    subscribeToTabLabels() {\n        if (this.tabLabelSubscription) {\n            this.tabLabelSubscription.unsubscribe();\n        }\n        // eslint-disable-next-line deprecation/deprecation\n        this.tabLabelSubscription = merge(...this.tabs.map(tab => tab.stateChanges))\n            .pipe(untilComponentDestroyed(this))\n            .subscribe(() => this.changeDetectorRef.markForCheck());\n    }\n    /**\n     * Clamps the given index to the bounds of 0 and the tabs length\n     *\n     * @param index - The index\n     * @returns The clamped index\n     */\n    clampTabIndex(index) {\n        // NOTE: Using `|| 0` ensures that values like NaN can't get through and which would otherwise throw the component into an infinite\n        // loop (since `Math.max(NaN, 0) === NaN`).\n        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));\n    }\n    /**\n     * Create a new change event\n     *\n     * @param index - The tab index\n     * @returns The change event\n     */\n    createChangeEvent(index) {\n        let tab = null;\n        if (this.tabs && this.tabs.length) {\n            tab = this.tabs.toArray()[index];\n        }\n        return new TsTabChangeEvent(index, tab);\n    }\n    /**\n     * Function for tracking for-loops changes\n     *\n     * @param index - The item index\n     * @param item - The item\n     * @returns The unique ID\n     */\n    trackByFn(index, item) {\n        return item.id;\n    }\n};\nTsTabCollectionComponent.ctorParameters = () => [\n    { type: ChangeDetectorRef }\n];\n__decorate([\n    ViewChild('tabBodyWrapper', { static: true }),\n    __metadata(\"design:type\", ElementRef)\n], TsTabCollectionComponent.prototype, \"tabBodyWrapper\", void 0);\n__decorate([\n    ViewChild('tabHeader', { static: true }),\n    __metadata(\"design:type\", TsTabHeaderComponent)\n], TsTabCollectionComponent.prototype, \"tabHeader\", void 0);\n__decorate([\n    ContentChildren(TsTabComponent),\n    __metadata(\"design:type\", QueryList)\n], TsTabCollectionComponent.prototype, \"tabs\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsTabCollectionComponent.prototype, \"headerPosition\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number),\n    __metadata(\"design:paramtypes\", [Number])\n], TsTabCollectionComponent.prototype, \"selectedIndex\", null);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsTabCollectionComponent.prototype, \"tabAlignment\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], TsTabCollectionComponent.prototype, \"theme\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsTabCollectionComponent.prototype, \"animationFinished\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsTabCollectionComponent.prototype, \"focusChange\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsTabCollectionComponent.prototype, \"selectedIndexChange\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], TsTabCollectionComponent.prototype, \"selectedTabChange\", void 0);\nTsTabCollectionComponent = __decorate([\n    Component({\n        selector: 'ts-tab-collection',\n        template: \"<ts-tab-header\\n  #tabHeader\\n  [selectedIndex]=\\\"selectedIndex\\\"\\n  (indexFocused)=\\\"focusChanged($event)\\\"\\n  (selectFocusedIndex)=\\\"selectedIndex = $event\\\"\\n>\\n\\n  <div\\n    class=\\\"ts-tab-label\\\"\\n    [class.ts-tab-label--active]=\\\"selectedIndex === i\\\"\\n    role=\\\"tab\\\"\\n    tsTabLabelWrapper\\n    mat-ripple\\n    cdkMonitorElementFocus\\n    *ngFor=\\\"let tab of tabs; let i = index; trackBy: trackByFn\\\"\\n    [id]=\\\"'ts-tab-label-' + collectionId + '-' + i\\\"\\n    [attr.tabIndex]=\\\"tab.isDisabled ? null : selectedIndex === i ? 0 : -1\\\"\\n    [attr.aria-posinset]=\\\"i + 1\\\"\\n    [attr.aria-setsize]=\\\"tabs.length\\\"\\n    [attr.aria-controls]=\\\"'ts-tab-content-' + collectionId + '-' + i\\\"\\n    [attr.aria-selected]=\\\"selectedIndex === i\\\"\\n    [attr.aria-label]=\\\"tab.ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\\\"\\n    [attr.title]=\\\"tab.label || ''\\\"\\n    [isDisabled]=\\\"tab.isDisabled || false\\\"\\n    [matRippleDisabled]=\\\"tab.isDisabled\\\"\\n    (click)=\\\"handleClick(tab, tabHeader, i)\\\"\\n  >\\n\\n    <div class=\\\"ts-tab-label__content\\\">\\n      <!-- If there is a label template, use it. -->\\n      <ng-template [ngIf]=\\\"tab.templateLabel\\\">\\n        <ng-template [cdkPortalOutlet]=\\\"tab.templateLabel\\\"></ng-template>\\n      </ng-template>\\n\\n      <!-- If there is not a label template, fall back to the text label. -->\\n      <ng-template [ngIf]=\\\"!tab.templateLabel\\\">\\n        {{ tab.label }}\\n      </ng-template>\\n    </div>\\n  </div>\\n</ts-tab-header>\\n\\n<div\\n  class=\\\"ts-tab-collection__body-wrapper\\\"\\n  #tabBodyWrapper\\n>\\n  <ts-tab-body\\n    role=\\\"tabpanel\\\"\\n    *ngFor=\\\"let tab of tabs; let i = index; trackBy: trackByFn\\\"\\n    [id]=\\\"'ts-tab-content-' + collectionId + '-' + i\\\"\\n    [attr.aria-labelledby]=\\\"'ts-tab-label-' + collectionId + '-' + i\\\"\\n    [class.ts-tab-body--active]=\\\"selectedIndex === i\\\"\\n    [content]=\\\"tab.content\\\"\\n    [position]=\\\"tab.position\\\"\\n    [origin]=\\\"tab.origin\\\"\\n    (centered)=\\\"removeTabBodyWrapperHeight()\\\"\\n    (centering)=\\\"setTabBodyWrapperHeight($event)\\\"\\n  ></ts-tab-body>\\n</div>\\n\",\n        host: {\n            'class': 'ts-tab-collection',\n            '[class.ts-tab-collection--inverted-header]': 'headerPosition === \"below\"',\n            // Themes:\n            '[class.ts-tab-collection--primary]': 'theme === \"primary\"',\n            '[class.ts-tab-collection--accent]': 'theme === \"accent\"',\n            '[class.ts-tab-collection--warn]': 'theme === \"warn\"',\n            // Tab alignment:\n            '[class.ts-tab-collection--start]': 'tabAlignment === \"start\"',\n            '[class.ts-tab-collection--center]': 'tabAlignment === \"center\"',\n            '[class.ts-tab-collection--end]': 'tabAlignment === \"end\"',\n            '[class.ts-tab-collection--stretch]': 'tabAlignment === \"stretch\"',\n        },\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        encapsulation: ViewEncapsulation.None,\n        exportAs: 'tsTabCollection',\n        styles: [\":root{--swift-ease-out-duration:var(--ts-animation-time-duration-400);--swift-ease-out-timing-function:cubic-bezier(.25, .8, .25, 1);--swift-ease-in-duration:var(--ts-animation-time-duration-300);--swift-ease-in-timing-function:cubic-bezier(.55, 0, .55, .2)}.cdk-drag{position:relative}.cdk-drag:not(.cdk-drag-placeholder){transition:transform 250ms cubic-bezier(0,0,.2,1)}.cdk-drag .cdk-drag-handle{color:#cecdd1;cursor:ns-resize;position:absolute;right:8px}.cdk-drag.cdk-drag-preview{--shadow:0 5px 5px -3px rgba(0, 0, 0, .2),0 8px 10px 1px rgba(0, 0, 0, .14),0 3px 14px 2px rgba(0, 0, 0, .12);background-color:#fafafa;box-shadow:var(--shadow);min-height:50px;padding:0!important}.cdk-drag.cdk-drag-preview .c-checkbox{margin-left:16px}.cdk-drag-placeholder{--drop-bg:#cce8d5;--drop-border:#7fd09c;background:var(--drop-bg);border:2px dotted var(--drop-border);cursor:ns-resize;transition:transform 250ms cubic-bezier(0,0,.2,1)}.u-visually-hidden{border:0;-webkit-clip-path:rect(0,0,0,0);clip-path:rect(0,0,0,0);display:block;height:1px;margin:-1px;overflow:hidden;padding:0;pointer-events:none;position:absolute;visibility:hidden;width:1px}.ts-tab-collection{display:flex;flex-direction:column}.ts-tab-collection.ts-tab-collection--inverted-header{flex-direction:column-reverse}.ts-tab-collection__body-wrapper{display:flex;overflow:hidden;position:relative;transition:height .2s cubic-bezier(.35,0,.25,1)}\"]\n    }),\n    __metadata(\"design:paramtypes\", [ChangeDetectorRef])\n], TsTabCollectionComponent);\n\nlet TsTabsModule = class TsTabsModule {\n};\nTsTabsModule = __decorate([\n    NgModule({\n        imports: [\n            A11yModule,\n            CommonModule,\n            FlexLayoutModule,\n            MatRippleModule,\n            ObserversModule,\n            PortalModule,\n        ],\n        declarations: [\n            TsTabBodyComponent,\n            TsTabBodyHostDirective,\n            TsTabCollectionComponent,\n            TsTabComponent,\n            TsTabContentDirective,\n            TsTabHeaderComponent,\n            TsTabInkBarComponent,\n            TsTabLabelDirective,\n            TsTabLabelWrapperDirective,\n        ],\n        exports: [\n            TsTabCollectionComponent,\n            TsTabComponent,\n            TsTabContentDirective,\n            TsTabLabelDirective,\n            TsTabHeaderComponent,\n            TsTabInkBarComponent,\n            TsTabLabelWrapperDirective,\n            TsTabBodyComponent,\n            TsTabBodyHostDirective,\n        ],\n    })\n], TsTabsModule);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TsTabBodyComponent, TsTabBodyHostDirective, TsTabChangeEvent, TsTabCollectionComponent, TsTabComponent, TsTabContentDirective, TsTabHeaderComponent, TsTabInkBarComponent, TsTabLabelDirective, TsTabLabelWrapperDirective, TsTabsModule, tsTabsAnimations };\n//# sourceMappingURL=terminus-ui-tabs.js.map\n","<div\n  class=\"ts-tab-body__content\"\n  #content\n  [@translateTab]=\"{\n    value: positionState\n  }\"\n  (@translateTab.start)=\"onTranslateTabStarted($event)\"\n  (@translateTab.done)=\"translateTabComplete.next($event)\"\n>\n  <ng-template tsTabBodyHost></ng-template>\n</div>\n","<ts-tab-header\n  #tabHeader\n  [selectedIndex]=\"selectedIndex\"\n  (indexFocused)=\"focusChanged($event)\"\n  (selectFocusedIndex)=\"selectedIndex = $event\"\n>\n\n  <div\n    class=\"ts-tab-label\"\n    [class.ts-tab-label--active]=\"selectedIndex === i\"\n    role=\"tab\"\n    tsTabLabelWrapper\n    mat-ripple\n    cdkMonitorElementFocus\n    *ngFor=\"let tab of tabs; let i = index; trackBy: trackByFn\"\n    [id]=\"'ts-tab-label-' + collectionId + '-' + i\"\n    [attr.tabIndex]=\"tab.isDisabled ? null : selectedIndex === i ? 0 : -1\"\n    [attr.aria-posinset]=\"i + 1\"\n    [attr.aria-setsize]=\"tabs.length\"\n    [attr.aria-controls]=\"'ts-tab-content-' + collectionId + '-' + i\"\n    [attr.aria-selected]=\"selectedIndex === i\"\n    [attr.aria-label]=\"tab.ariaLabel || null\"\n    [attr.aria-labelledby]=\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\"\n    [attr.title]=\"tab.label || ''\"\n    [isDisabled]=\"tab.isDisabled || false\"\n    [matRippleDisabled]=\"tab.isDisabled\"\n    (click)=\"handleClick(tab, tabHeader, i)\"\n  >\n\n    <div class=\"ts-tab-label__content\">\n      <!-- If there is a label template, use it. -->\n      <ng-template [ngIf]=\"tab.templateLabel\">\n        <ng-template [cdkPortalOutlet]=\"tab.templateLabel\"></ng-template>\n      </ng-template>\n\n      <!-- If there is not a label template, fall back to the text label. -->\n      <ng-template [ngIf]=\"!tab.templateLabel\">\n        {{ tab.label }}\n      </ng-template>\n    </div>\n  </div>\n</ts-tab-header>\n\n<div\n  class=\"ts-tab-collection__body-wrapper\"\n  #tabBodyWrapper\n>\n  <ts-tab-body\n    role=\"tabpanel\"\n    *ngFor=\"let tab of tabs; let i = index; trackBy: trackByFn\"\n    [id]=\"'ts-tab-content-' + collectionId + '-' + i\"\n    [attr.aria-labelledby]=\"'ts-tab-label-' + collectionId + '-' + i\"\n    [class.ts-tab-body--active]=\"selectedIndex === i\"\n    [content]=\"tab.content\"\n    [position]=\"tab.position\"\n    [origin]=\"tab.origin\"\n    (centered)=\"removeTabBodyWrapperHeight()\"\n    (centering)=\"setTabBodyWrapperHeight($event)\"\n  ></ts-tab-body>\n</div>\n","<div\n  class=\"ts-tab-header__pagination ts-tab-header__pagination--before mat-elevation-z4\"\n  #previousPaginator\n  aria-hidden=\"true\"\n  mat-ripple\n  [matRippleDisabled]=\"disableScrollBefore\"\n  [class.ts-tab-header__pagination--disabled]=\"disableScrollBefore\"\n  (click)=\"handlePaginatorClick('before')\"\n  (mousedown)=\"handlePaginatorPress('before')\"\n  (touchend)=\"stopInterval()\"\n>\n  <div class=\"ts-tab-header__pagination-chevron\"></div>\n</div>\n\n\n<div\n  class=\"ts-tab-header__labels-container\"\n  #tabListContainer\n  (keydown)=\"handleKeydown($event)\"\n>\n  <div\n    class=\"ts-tab-header__labels-container-inner\"\n    #tabList\n    role=\"tablist\"\n    (cdkObserveContent)=\"onContentChanges()\"\n  >\n    <div class=\"ts-tab-header__labels\">\n      <ng-content></ng-content>\n    </div>\n\n    <ts-tab-ink-bar></ts-tab-ink-bar>\n  </div>\n</div>\n\n\n<div\n  class=\"ts-tab-header__pagination ts-tab-header__pagination--after mat-elevation-z4\"\n  #nextPaginator\n  aria-hidden=\"true\"\n  mat-ripple\n  [matRippleDisabled]=\"disableScrollAfter\"\n  [class.ts-tab-header__pagination--disabled]=\"disableScrollAfter\"\n  (mousedown)=\"handlePaginatorPress('after')\"\n  (click)=\"handlePaginatorClick('after')\"\n  (touchend)=\"stopInterval()\"\n>\n  <div class=\"ts-tab-header__pagination-chevron\"></div>\n</div>\n","<ng-template>\n  <ng-content></ng-content>\n</ng-template>\n","import { NgModule } from '@angular/core';\nimport {\n  RouterModule,\n  Routes,\n} from '@angular/router';\n\nimport { TabsComponent } from './tabs.component';\n\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: TabsComponent,\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class TabsRoutingModule { }\n","<h3>Basic Example</h3>\n\n<ts-tab-collection tsVerticalSpacing=\"large--2\">\n  <ts-tab label=\"Tab 1 with a longer name\">\n    Tab content 1\n\n    <p>\n      Dicta temporibus ea nostrum quam id. Delectus harum minima asperiores. Molestias aperiam dolor laboriosam fugit.\n    </p>\n\n    <p>\n      Blanditiis repudiandae alias eum. Culpa dolorem quidem iste velit modi. Esse sint quidem expedita.\n    </p>\n\n    <p>\n      Odit perferendis sit in. Excepturi voluptate libero est earum excepturi iure cupiditate. Quam perferendis fugiat magni repellat quidem\n      consectetur officiis.\n    </p>\n  </ts-tab>\n\n  <ts-tab label=\"2\">\n    Tab content 2\n\n    <div>\n      <button>Click</button>\n    </div>\n\n    <p>\n      Odit perferendis sit in. Excepturi voluptate libero est earum excepturi iure cupiditate. Quam perferendis fugiat magni repellat quidem\n      consectetur officiis.\n    </p>\n\n    <p>\n      Dicta temporibus ea nostrum quam id. Delectus harum minima asperiores. Molestias aperiam dolor laboriosam fugit.\n    </p>\n\n    <div>\n      <button>Click</button>\n    </div>\n\n    <p>\n      Blanditiis repudiandae alias eum. Culpa dolorem quidem iste velit modi. Esse sint quidem expedita.\n    </p>\n  </ts-tab>\n\n  <ts-tab label=\"Tab 3\" [isDisabled]=\"true\">\n    Tab content 3\n  </ts-tab>\n\n  <ts-tab label=\"Tab 4\">\n    Tab content 4\n\n    <p>\n      Dicta temporibus ea nostrum quam id. Delectus harum minima asperiores. Molestias aperiam dolor laboriosam fugit.\n    </p>\n\n    <p>\n      Blanditiis repudiandae alias eum. Culpa dolorem quidem iste velit modi. Esse sint quidem expedita.\n    </p>\n\n    <p>\n      Odit perferendis sit in. Excepturi voluptate libero est earum excepturi iure cupiditate. Quam perferendis fugiat magni repellat quidem\n      consectetur officiis.\n    </p>\n  </ts-tab>\n</ts-tab-collection>\n\n\n<!-- TAB LAYOUTS -->\n\n<h3>Tab layouts</h3>\n\n<div>\n  <div>\n    Header position below:\n    <input type=\"checkbox\" [(ngModel)]=\"isBelow\">\n  </div>\n\n  <div>\n    Tabs horizontal alignment:\n    <select id=\"alignment\" name=\"alignment\" [formControl]=\"alignmentControl\">\n      <option value=\"start\">Start</option>\n      <option value=\"center\">Center</option>\n      <option value=\"end\">End</option>\n      <option value=\"stretch\">Stretch</option>\n    </select>\n  </div>\n</div>\n\n<ts-tab-collection\n  [headerPosition]=\"isBelow ? 'below' : 'above'\"\n  [tabAlignment]=\"alignmentControl.value\"\n  tsVerticalSpacing=\"large--2\"\n  #tabCollection\n>\n  <ts-tab label=\"First\">\n    Content 1\n  </ts-tab>\n\n  <ts-tab label=\"Second\">\n    Content 2\n  </ts-tab>\n</ts-tab-collection>\n\n\n<!-- EVENTS -->\n\n<h3>Events (check the console)</h3>\n\n<div>\n  <button (click)=\"updateIndex()\">\n    Update the selected index to {{ !eventsIndex ? '1' : '0'}}\n  </button>\n\n  {{ (eventsIndex | json) || 'undefined' }}\n</div>\n\n<ts-tab-collection\n  [(selectedIndex)]=\"eventsIndex\"\n  (animationFinished)=\"animationFinished()\"\n  (focusChange)=\"focusChange($event)\"\n  (selectedIndexChange)=\"indexChange($event)\"\n  (selectedTabChange)=\"tabChange($event)\"\n  tsVerticalSpacing=\"large--2\"\n>\n  <ts-tab label=\"First\">\n    Content 1\n  </ts-tab>\n\n  <ts-tab label=\"Second\">\n    <ng-template tsTabContent>\n      Content 2 (dynamic)\n    </ng-template>\n  </ts-tab>\n</ts-tab-collection>\n\n\n<!-- DYNAMIC TABS -->\n\n<h3>Dynamic Tabs</h3>\n\n<div>\n  <button (click)=\"insertTab()\">\n    Insert a new tab at the end\n  </button>\n\n  <button (click)=\"insertTabAtLocation(1)\">\n    Insert a new tab at location `1`\n  </button>\n</div>\n\n<ts-tab-collection tsVerticalSpacing=\"large--2\">\n  <ts-tab *ngFor=\"let tab of dynamicTabs; let index = index\" [label]=\"tab\">\n    Content for {{ tab }} tab\n  </ts-tab>\n</ts-tab-collection>\n\n\n<!-- CUSTOM LABELS -->\n\n<h3>Custom label templates</h3>\n\n<ts-tab-collection>\n  <ts-tab>\n    <ng-template tsTabLabel>\n      <ts-icon style=\"position: relative; top: 5px;\">home</ts-icon>\n      First\n    </ng-template>\n\n    Content 1\n  </ts-tab>\n\n  <ts-tab>\n    <ng-template tsTabLabel>\n      <ts-icon style=\"position: relative; top: 5px;\">help</ts-icon>\n      Second\n    </ng-template>\n\n    Content 2\n  </ts-tab>\n</ts-tab-collection>\n","import {\n  Component,\n  OnInit,\n  ViewChild,\n} from '@angular/core';\nimport { FormControl } from '@angular/forms';\nimport { BehaviorSubject } from 'rxjs';\n\nimport { TsTabCollectionComponent } from '@terminus/ui-tabs';\n\n\n@Component({\n  selector: 'demo-tabs',\n  templateUrl: './tabs.component.html',\n})\nexport class TabsComponent implements OnInit {\n  isBelow = false;\n  tabAlignment$ = new BehaviorSubject('start');\n  tabAlignment = 'start';\n  eventsIndex: number | undefined;\n  alignmentControl = new FormControl('start');\n  dynamicTabs = ['First', 'Second', 'Third'];\n\n  @ViewChild('tabCollection', { static: true })\n  public tabCollection!: TsTabCollectionComponent;\n\n\n  /**\n   * Helper for layout demo\n   */\n  ngOnInit() {\n    this.alignmentControl.valueChanges.subscribe(newValue => {\n      // Realign the ink bar when programmatically moving tab labels\n      this.tabCollection.realignInkBar();\n    });\n  }\n\n  /**\n   * Helpers for dynamic tabs demo\n   */\n  insertTab() {\n    this.dynamicTabs.push('Fourth');\n  }\n\n  insertTabAtLocation(index) {\n    this.dynamicTabs.splice(index, 0, 'New New!');\n  }\n\n  /**\n   * Helpers for events demo\n   */\n  updateIndex() {\n    this.eventsIndex = this.eventsIndex ? 0 : 1;\n  }\n\n  animationFinished() {\n    console.log('DEMO: Tab animation finished.');\n  }\n\n  focusChange(e) {\n    console.log('DEMO: Tab focus changed ', e);\n  }\n\n  indexChange(e) {\n    console.log('DEMO: Tab selected index changed: ', e);\n  }\n\n  tabChange(e) {\n    console.log('DEMO: Selected tab changed: ', e);\n  }\n\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport {\n  FormsModule,\n  ReactiveFormsModule,\n} from '@angular/forms';\n\nimport { TsIconModule } from '@terminus/ui-icon';\nimport { TsSpacingModule } from '@terminus/ui-spacing';\nimport { TsTabsModule } from '@terminus/ui-tabs';\n\nimport { TabsRoutingModule } from './tabs-routing.module';\nimport { TabsComponent } from './tabs.component';\n\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule,\n    ReactiveFormsModule,\n    TabsRoutingModule,\n    TsIconModule,\n    TsSpacingModule,\n    TsTabsModule,\n  ],\n  declarations: [\n    TabsComponent,\n  ],\n})\nexport class TabsModule {}\n"],"sourceRoot":"webpack:///"}